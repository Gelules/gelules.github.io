<!DOCTYPE HTML>
<html lang="fr" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Mémoire - Pédiluve</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../introduction/introduction.html">Introduction</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">1.</strong> Préliminaires</div></li><li><ol class="section"><li class="chapter-item expanded "><a href="../preliminaires/base_10.html"><strong aria-hidden="true">1.1.</strong> Base 10</a></li><li class="chapter-item expanded "><a href="../preliminaires/base_2.html"><strong aria-hidden="true">1.2.</strong> Base 2</a></li><li class="chapter-item expanded "><a href="../preliminaires/base_16.html"><strong aria-hidden="true">1.3.</strong> Base 16</a></li><li class="chapter-item expanded "><a href="../preliminaires/bit_byte.html"><strong aria-hidden="true">1.4.</strong> Bit et octet</a></li><li class="chapter-item expanded "><a href="../preliminaires/logic.html"><strong aria-hidden="true">1.5.</strong> Portes logiques</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Système</li><li class="chapter-item expanded "><a href="../linux/systeme.html"><strong aria-hidden="true">2.</strong> Choix du système</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../linux/ubuntu.html"><strong aria-hidden="true">2.1.</strong> Ubuntu</a></li><li class="chapter-item expanded "><a href="../linux/arch.html"><strong aria-hidden="true">2.2.</strong> Arch Linux</a></li><li class="chapter-item expanded "><a href="../linux/manjaro.html"><strong aria-hidden="true">2.3.</strong> Manjaro</a></li><li class="chapter-item expanded "><a href="../linux/fedora.html"><strong aria-hidden="true">2.4.</strong> Fedora</a></li><li class="chapter-item expanded "><a href="../linux/nixos.html"><strong aria-hidden="true">2.5.</strong> NixOS</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Shell</li><li class="chapter-item expanded "><a href="../shell/introduction.html"><strong aria-hidden="true">3.</strong> Shell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../shell/usage.html"><strong aria-hidden="true">3.1.</strong> Utilisation</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../shell/deplacements.html"><strong aria-hidden="true">3.1.1.</strong> Se déplacer</a></li><li class="chapter-item expanded "><a href="../shell/rtfm.html"><strong aria-hidden="true">3.1.2.</strong> RTFM : Read The Fucking Manual</a></li><li class="chapter-item expanded "><a href="../shell/read_write_files.html"><strong aria-hidden="true">3.1.3.</strong> Lire et écrire dans des fichiers</a></li><li class="chapter-item expanded "><a href="../shell/permissions.html"><strong aria-hidden="true">3.1.4.</strong> Permissions</a></li><li class="chapter-item expanded "><a href="../shell/tips_tricks.html"><strong aria-hidden="true">3.1.5.</strong> Tips and tricks</a></li></ol></li><li class="chapter-item expanded "><a href="../shell/editors.html"><strong aria-hidden="true">3.2.</strong> Editeurs de texte</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../shell/vscode.html"><strong aria-hidden="true">3.2.1.</strong> VSCode</a></li><li class="chapter-item expanded "><a href="../shell/vim.html"><strong aria-hidden="true">3.2.2.</strong> Vim</a></li></ol></li><li class="chapter-item expanded "><a href="../shell/run_command.html"><strong aria-hidden="true">3.3.</strong> Run Command</a></li><li class="chapter-item expanded "><a href="../shell/wm.html"><strong aria-hidden="true">3.4.</strong> Window Manager</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../shell/awesome.html"><strong aria-hidden="true">3.4.1.</strong> Awesome</a></li></ol></li><li class="chapter-item expanded "><a href="../shell/shell.html"><strong aria-hidden="true">3.5.</strong> Programmation Shell</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../shell/flux.html"><strong aria-hidden="true">3.5.1.</strong> Flux systèmes</a></li><li class="chapter-item expanded "><a href="../shell/job_control.html"><strong aria-hidden="true">3.5.2.</strong> Job control</a></li><li class="chapter-item expanded "><a href="../shell/scripts.html"><strong aria-hidden="true">3.5.3.</strong> Scripts</a></li><li class="chapter-item expanded "><a href="../shell/variable.html"><strong aria-hidden="true">3.5.4.</strong> Variables</a></li><li class="chapter-item expanded "><a href="../shell/maths.html"><strong aria-hidden="true">3.5.5.</strong> Mathématiques</a></li><li class="chapter-item expanded "><a href="../shell/env.html"><strong aria-hidden="true">3.5.6.</strong> Variables d'environnement</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../shell/path.html"><strong aria-hidden="true">3.5.6.1.</strong> PATH</a></li></ol></li><li class="chapter-item expanded "><a href="../shell/quotting.html"><strong aria-hidden="true">3.5.7.</strong> Quotting</a></li><li class="chapter-item expanded "><a href="../shell/tests.html"><strong aria-hidden="true">3.5.8.</strong> Tests et conditions</a></li><li class="chapter-item expanded "><a href="../shell/loops.html"><strong aria-hidden="true">3.5.9.</strong> Boucles</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">Git</li><li class="chapter-item expanded "><a href="../git/introduction.html"><strong aria-hidden="true">4.</strong> Git</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../git/bases.html"><strong aria-hidden="true">4.1.</strong> Commandes de bases</a></li><li class="chapter-item expanded "><a href="../git/github.html"><strong aria-hidden="true">4.2.</strong> Cas pratique avec GitHub</a></li></ol></li><li class="chapter-item expanded "><li class="part-title">Langage C</li><li class="chapter-item expanded "><a href="../c/introduction.html"><strong aria-hidden="true">5.</strong> Langage C</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c/abecedaire.html"><strong aria-hidden="true">5.1.</strong> Abécédaire</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c/compilation_test.html"><strong aria-hidden="true">5.1.1.</strong> Compilation de test</a></li><li class="chapter-item expanded "><a href="../c/main.html"><strong aria-hidden="true">5.1.2.</strong> La fonction main et l'environnement de développement</a></li><li class="chapter-item expanded "><a href="../c/types.html"><strong aria-hidden="true">5.1.3.</strong> Types prédéfinis</a></li><li class="chapter-item expanded "><a href="../c/functions.html"><strong aria-hidden="true">5.1.4.</strong> Fonctions</a></li><li class="chapter-item expanded "><a href="../c/maths.html"><strong aria-hidden="true">5.1.5.</strong> Mathématiques</a></li><li class="chapter-item expanded "><a href="../c/if_else_switch.html"><strong aria-hidden="true">5.1.6.</strong> Structures de contrôles</a></li><li class="chapter-item expanded "><a href="../c/arrays.html"><strong aria-hidden="true">5.1.7.</strong> Tableaux</a></li><li class="chapter-item expanded "><a href="../c/string.html"><strong aria-hidden="true">5.1.8.</strong> Chaîne de caractères</a></li><li class="chapter-item expanded "><a href="../c/pointers.html"><strong aria-hidden="true">5.1.9.</strong> Pointeurs</a></li><li class="chapter-item expanded "><a href="../c/loops.html"><strong aria-hidden="true">5.1.10.</strong> Boucles</a></li><li class="chapter-item expanded "><a href="../c/exercises.html"><strong aria-hidden="true">5.1.11.</strong> Exercices</a></li><li class="chapter-item expanded "><a href="../c/corrections.html"><strong aria-hidden="true">5.1.12.</strong> Corrections</a></li><li class="chapter-item expanded "><a href="../c/struct.html"><strong aria-hidden="true">5.1.13.</strong> Structures de données</a></li></ol></li><li class="chapter-item expanded "><a href="../c/advanced_notions.html"><strong aria-hidden="true">5.2.</strong> Notions avancées</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../c/compilation_flags.html"><strong aria-hidden="true">5.2.1.</strong> Flags de compilation</a></li><li class="chapter-item expanded "><a href="../c/multiple_files.html"><strong aria-hidden="true">5.2.2.</strong> Plusieurs fichiers</a></li><li class="chapter-item expanded "><a href="../c/makefile.html"><strong aria-hidden="true">5.2.3.</strong> Makefile</a></li><li class="chapter-item expanded "><a href="../c/recursive.html"><strong aria-hidden="true">5.2.4.</strong> Récursivité</a></li><li class="chapter-item expanded "><a href="../c/advanced_pointers.html"><strong aria-hidden="true">5.2.5.</strong> Pointeurs avancés</a></li><li class="chapter-item expanded "><a href="../c/memory.html" class="active"><strong aria-hidden="true">5.2.6.</strong> Mémoire</a></li><li class="chapter-item expanded "><a href="../c/linked_lists.html"><strong aria-hidden="true">5.2.7.</strong> Listes chainées</a></li><li class="chapter-item expanded "><a href="../c/gdb.html"><strong aria-hidden="true">5.2.8.</strong> GDB</a></li></ol></li></ol></li><li class="chapter-item expanded "><li class="part-title">TODO: Assembleur</li><li class="chapter-item expanded "><a href="../asm/introduction.html"><strong aria-hidden="true">6.</strong> Assembleur</a></li><li class="chapter-item expanded affix "><li class="spacer"></li><li class="chapter-item expanded affix "><a href="../misc/authors.html">Auteurs</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pédiluve</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="mémoire"><a class="header" href="#mémoire">Mémoire</a></h1>
<p>Pour l'instant, tu n'as fait que jouer avec des variables locales aux fonctions
que tu codes. Rappelle toi que ces variables ne sont vivantes que le temps
d'exécution de la fonction.</p>
<p>Comment créer une zone mémoire qui survivrait à la fonction ? Comment créer une
<em>tableau</em> à taille variable ?</p>
<p>Dis bonjour à malloc et free.</p>
<h2 id="malloc"><a class="header" href="#malloc">Malloc</a></h2>
<p>Malloc (<strong>m</strong>emory <strong>alloc</strong>ator) alloue une zone mémoire dynamique appelée la
<strong>heap</strong> dans laquelle tu peux faire ce que bon te semble. Tu peux y accéder
comme un tableau.</p>
<p>Je t'invite à lire le <strong>man 3 malloc</strong>.</p>
<pre><code class="language-c">void *malloc(size_t size);
</code></pre>
<p>Malloc renvoie un <strong>pointeur sur void</strong>. Ca veut dire que tu peux créer un
pointeur du type que tu veux. Mais il peut aussi renvoyer <strong>NULL</strong>, qui est un
<em>alias</em> sur <strong>(void *) 0</strong>. C'est un <strong>pointeur sur l'adresse 0</strong>. Cette
adresse est particulière, tu n'as pas le droit de la déréférencer, sinon ton
programme crashera et t'affichera un <strong>segfault</strong>.</p>
<p>Il prend en entrée un <strong>size_t</strong>. C'est un <em>alias</em> sur <strong>unsigned int</strong>. cf.
<strong>man 3type size_t</strong>. C'est aussi ce que retourne <strong>strlen</strong>, profitons-en.</p>
<p>C'est le kernel (noyau) de Linux qui s'occupe de te trouver une zone dans ta
mémoire vive qui est libre.</p>
<p>Mettons que tu veuilles créer une zone mémoire pour accueillir une chaîne de
caractères de la taille que tu veux pour copier le contenu de <strong>argv[1]</strong> (le
premier argument de ton programme).</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *arg_copy(char *arg_to_copy)
{
    size_t size = strlen(arg_to_copy);
    char *arg = malloc(size + 1);

    if (arg == NULL)
    {
        return NULL;
    }

    for (size_t i = 0; i &lt; size; ++i)
    {
        arg[i] = arg_to_copy[i];
    }

    arg[size] = '\0';

    return arg;
}

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s ARG\n", argv[0]);
        return 1;
    }

    char *text = arg_copy(argv[1]);
    if (text == NULL)
    {
        printf("malloc failed\n");
        return 2;
    }

    printf("%s\n", text);

    return 0;
}
</code></pre>
<p>Décortiquons tout ça.</p>
<p><strong>text</strong> est un pointeur sur char, il faut que ma fonction <strong>arg_copy</strong> retourne
un pointeur sur char. J'envoie en paramètre <strong>argv[1]</strong>.</p>
<p>Dans la fonction <strong>arg_copy</strong>, je crée le pointeur sur char <strong>arg</strong>. Je demande
à malloc de lui allouer la taille de l'entrée <strong>+ 1</strong>. J'ai besoin de ce
caractère en plus pour écrire le caractère de fin de chaîne de caractères :
<strong>\0</strong>.</p>
<p>Admettons que j'envoie <strong>coucou</strong> en entrée. <strong>size</strong> a la valeur de retour de
<strong>strlen("coucou");</strong>, soit 6.</p>
<div class="table-wrapper"><table><thead><tr><th>Index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody>
<tr><td>Emplacement</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr><td>Valeur</td><td>c</td><td>o</td><td>u</td><td>c</td><td>o</td><td>u</td><td>\0</td></tr>
</tbody></table>
</div>
<p>Dans ce tableau, la taille <strong>size</strong> est de 6, et le caractère <strong>\0</strong> est au 7ème
emplacement pour indiquer la fin de la chaîne de caractère. D'où l'utilisation
du <strong>+ 1</strong>.</p>
<p>Maintenant que j'ai ma zone mémoire, je vais copier le contenu de
<strong>arg_to_copy</strong> dans cette zone avec une boucle.</p>
<p>L'avant-dernière ligne de la fonction peut être difficile à comprendre. Etant
donné que <strong>size</strong> égale 6, alors <strong>arg[size]</strong> = <strong>arg[6]</strong>. Si tu reprends le
tableau, l'<strong>index</strong> 6 est l'emplacement où doit se trouver le caractère <strong>\0</strong>.</p>
<p>Etant donné que ma boucle s'arrête juste avant de caractère, je l'écris après
les itérations.</p>
<p>J'aurai aussi pu changer la condition de ma boucle ainsi :</p>
<pre><code class="language-c">for (size_t i = 0; i &lt;= size; ++i)
</code></pre>
<p>Ce qui fait que <strong>i</strong> aurai atteint la valeur de <strong>size</strong>.</p>
<p>Mais je voulais réappuyer sur l'utilisation des index sur les chaînes de
caractères.</p>
<h3 id="segfault"><a class="header" href="#segfault">Segfault</a></h3>
<p>Pour te montrer pourquoi il est important de <strong>tester</strong> les retours de malloc,
tu vas faire un code qui segfault.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void *my_malloc(size_t length)
{
    (void) length;
    return NULL;
}

int main(void)
{
    char *text = my_malloc(10);

    text[0] = 'B';

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Segmentation fault (core dumped)
$
</code></pre>
<p>Voilà pourquoi il est essentiel de <strong>toujours</strong> vérifier le retour de malloc.
Imagine que tu livres un programme qui crash en production pour une erreur aussi
simple. Quelle honte !</p>
<h2 id="free"><a class="header" href="#free">Free</a></h2>
<p>Une fois que tu n'as plus besoin de ta zone mémoire, il faut la <strong>libérer</strong>.</p>
<p>La mémoire vive de ton PC est limitée. Si tu demandes sans cesse de la mémoire
sans la libérer, tu utiliseras de la mémoire inutilement que d'autres programmes
pourraient utiliser. C'est ce qu'on appelle une fuite mémoire (momory leak).</p>
<p>Imagine qu'à chaque fois que tu ouvres un onglet sur ton navigateur Internet,
celui-ci demande 100 Mo au kernel, mais qu'une fois l'onglet fermé, ton
navigateur ne libère pas les 100 Mo alloués. Si tu cumules les onglets, tu vas
vite te retrouver sans beaucoup de mémoire vive libre. Tu seras obligé de fermer
ton navigateur pour tout libérer.</p>
<p>Pour libérer la mémoire, tu peux faire appel à free. Je t'invite à lire le <strong>man
3 free</strong>.</p>
<pre><code class="language-c">char *text = malloc(10);

// du code...

free(text);
</code></pre>
<p>Après l'appel de free, tu ne dois surtout pas réutiliser la variable libérée. Tu
utiliserais une zone mémoire que ton programme considèrerait comme libre de ta
portée et qui pourrait contenir des valeurs allouées par ton programme et pas
par toi. Tes résultats se retrouveraient faussés.</p>
<p>Si on reprend le premier code de cette page, il faut donc ajouter <strong>free</strong> juste
après le <strong>printf</strong> de la fonction <strong>main</strong> qui est le dernier endroit où la
zone mémoire allouée est utilisée.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *arg_copy(char *arg_to_copy)
{
    size_t size = strlen(arg_to_copy);
    char *arg = malloc(size + 1);

    if (arg == NULL)
    {
        return NULL;
    }

    for (size_t i = 0; i &lt; size; ++i)
    {
        arg[i] = arg_to_copy[i];
    }

    arg[size] = '\0';

    return arg;
}

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s ARG\n", argv[0]);
        return 1;
    }

    char *text = arg_copy(argv[1]);
    if (text == NULL)
    {
        printf("malloc failed\n");
        return 2;
    }

    printf("%s\n", text);

    free(text);

    return 0;
}
</code></pre>
<p><strong>Vive la mémoire libre !</strong></p>
<h2 id="sécurité-avec-free"><a class="header" href="#sécurité-avec-free">Sécurité avec free</a></h2>
<p>Pour faire preuve de sécurité quand tu utilises free, tu peux utiliser une
fonction qui va libérer la zone mémoire et mettre l'adresse du pointeur sur
NULL.</p>
<p>free ne laisse ton pointeur sur laquelle il pointe, donc si tu tt'en sers encore
après, tu liras des valeurs qui ne t'appartiennent plus.</p>
<pre><code class="language-c">char *text = malloc(10);

// du code...

free(text);

printf("%s\n", text);
text[0] = 'g';
printf("%s\n", text);
</code></pre>
<p>Ce code compile et peut s'exécuter en donnant un comportement indéfini.</p>
<p>Pour ne pas rencontrer ce genre de bug, tu vas créer une fonction qui va libérer
la zone mémoire et mettre le pointeur sur NULL <strong>pour de bon</strong>. Ainsi si tu
utilises ton pointeur, tu auras un segfault. C'est très bien pour des phases de
tests.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

void ptr_char_destructor(char **ptr)
{
    free(*ptr);
    *ptr = NULL;
}

int main(void)
{
    char *text = malloc(2600);

    // du code

    ptr_char_destructor(&amp;text);

    // du code

    return 0;
}
</code></pre>
<p>Oulah oulah. Quelle est cette écriture ?</p>
<p>Etant donné que tu dois mettre <strong>pour de bon</strong> le pointeur à NULL, tu vas
coder une fonction qui va utiliser un <strong>pointeur de pointeur</strong>. Un double
pointeur.</p>
<p>Si un pointeur est une adresse qui pointe un type, alors un pointeur de pointeur
est une adresse qui pointe sur... une adresse.</p>
<p><img src="./memory/pointer_pointer.png" alt="multi pointeur" title="multi pointeur" /></p>
<p>Donc si tu modifies l'adresse pointée en la mettant à NULL, au retour de la
fonction <strong>ptr_char_destructor</strong>, la valeur du pointeur sera toujours à NULL.</p>
<p>Si tu l'utilises sans faire exprès, tu auras un segfault à l'exécution.</p>
<p>Par exemple, ce code segfault :</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void ptr_char_destructor(char **ptr)
{
    free(*ptr);
    *ptr = NULL;
}

int main(void)
{
    char *text = malloc(2600);

    // du code

    ptr_char_destructor(&amp;text);

    // du code

    text[0] = 'g';

    return 0;
}
</code></pre>
<h2 id="valgrind"><a class="header" href="#valgrind">Valgrind</a></h2>
<p>Valgrind (qu'on prononce <a href="https://valgrind.org/docs/manual/faq.html#faq.pronounce">"Val grine de"</a>)
est un outil pour déboguer et profiler tes programmes. Pour l'occasion, tu vas
l'utiliser pour vérifier que tu as bien libérer ta mémoire.</p>
<p>Prenons un simple et incorrect code.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *arg_copy(char *arg_to_copy)
{
    size_t size = strlen(arg_to_copy);
    char *arg = malloc(size + 1);

    if (arg == NULL)
    {
        return NULL;
    }

    for (size_t i = 0; i &lt; size; ++i)
    {
        arg[i] = arg_to_copy[i];
    }

    arg[size] = '\0';

    return arg;
}

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s ARG\n", argv[0]);
        return 1;
    }

    char *text = arg_copy(argv[1]);
    if (text == NULL)
    {
        printf("malloc failed\n");
        return 2;
    }

    printf("%s\n", text);

    // free(text);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ valgrind ./mon_super_programme coucou
==4902== Memcheck, a memory error detector
==4902== Copyright (C) 2002-2024, and GNU GPL'd, by Julian Seward et al.
==4902== Using Valgrind-3.23.0 and LibVEX; rerun with -h for copyright info
==4902== Command: ./mon_super_programme coucou
==4902==
coucou
==4902==
==4902== HEAP SUMMARY:
==4902==     in use at exit: 7 bytes in 1 blocks
==4902==   total heap usage: 2 allocs, 1 frees, 1,031 bytes allocated
==4902==
==4902== LEAK SUMMARY:
==4902==    definitely lost: 7 bytes in 1 blocks
==4902==    indirectly lost: 0 bytes in 0 blocks
==4902==      possibly lost: 0 bytes in 0 blocks
==4902==    still reachable: 0 bytes in 0 blocks
==4902==         suppressed: 0 bytes in 0 blocks
==4902== Rerun with --leak-check=full to see details of leaked memory
==4902==
==4902== For lists of detected and suppressed errors, rerun with: -s
==4902== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<p>Décortiquons tout ça.</p>
<p>Tu peux voir au début la commande exécutée.</p>
<pre><code class="language-text">==4902== Command: ./mon_super_programme coucou
</code></pre>
<p>Tu peux voir l'effet du <strong>printf</strong> au milieu des lignes.</p>
<p>Ensuite il y a deux parties qui nous résument l'utilisation mémoire.</p>
<pre><code class="language-text">==4902== HEAP SUMMARY:
==4902==     in use at exit: 7 bytes in 1 blocks
==4902==   total heap usage: 2 allocs, 1 frees, 1,031 bytes allocated
</code></pre>
<p><strong>in use at exit: 7 bytes in 1 blocks</strong> : c'est notre <strong>coucou\0</strong> qui n'a pas
été libéré.</p>
<p><strong>total heap usage: 2 allocs, 1 frees, 1,031 bytes allocated</strong> : la heap est la
zone mémoire dynamique. Comment peut-il y avoir 2 allocations alors que nous ne
faisons appel à malloc qu'une seule fois ?</p>
<p>Parce que nous ne faisons pas appel à malloc qu'une seule fois.</p>
<p><strong>printf</strong> fait aussi appel à malloc pour afficher le texte. Mais à l'inverse de
notre code, <strong>printf</strong> fait appel à free, c'est pour ça qu'on peut lire ensuite
qu'il y a un appel à free.</p>
<p>A la fin des logs, on nous indique qu'on peut relancer Valgrind avec l'argument
suivant :</p>
<pre><code class="language-text">==4902== Rerun with --leak-check=full to see details of leaked memory
</code></pre>
<pre><code class="language-text">$ valgrind --leak-check=full ./mon_super_programme coucou
==5307== Memcheck, a memory error detector
==5307== Copyright (C) 2002-2024, and GNU GPL'd, by Julian Seward et al.
==5307== Using Valgrind-3.23.0 and LibVEX; rerun with -h for copyright info
==5307== Command: ./mon_super_programme coucou
==5307==
coucou
==5307==
==5307== HEAP SUMMARY:
==5307==     in use at exit: 7 bytes in 1 blocks
==5307==   total heap usage: 2 allocs, 1 frees, 1,031 bytes allocated
==5307==
==5307== 7 bytes in 1 blocks are definitely lost in loss record 1 of 1
==5307==    at 0x48447A8: malloc (vg_replace_malloc.c:446)
==5307==    by 0x109194: arg_copy (in /tmp/tests/pediluve/c/mon_super_programme)
==5307==    by 0x10923B: main (in /tmp/tests/pediluve/c/mon_super_programme)
==5307==
==5307== LEAK SUMMARY:
==5307==    definitely lost: 7 bytes in 1 blocks
==5307==    indirectly lost: 0 bytes in 0 blocks
==5307==      possibly lost: 0 bytes in 0 blocks
==5307==    still reachable: 0 bytes in 0 blocks
==5307==         suppressed: 0 bytes in 0 blocks
==5307==
==5307== For lists of detected and suppressed errors, rerun with: -s
==5307== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</code></pre>
<p>Le nouveau bloc de texte intéressant se trouve en plein milieu :</p>
<pre><code class="language-text">==5307== 7 bytes in 1 blocks are definitely lost in loss record 1 of 1
==5307==    at 0x48447A8: malloc (vg_replace_malloc.c:446)
==5307==    by 0x109194: arg_copy (in /tmp/tests/pediluve/c/mon_super_programme)
==5307==    by 0x10923B: main (in /tmp/tests/pediluve/c/mon_super_programme)
</code></pre>
<p>Ce bloc se lit de bas en haut.</p>
<p>On peut lire que depuis la fonction <strong>main</strong>, on fait appel à la fonction
<strong>arg_copy</strong> qui elle-meme fait appel à la fonction <strong>malloc</strong> et que 7 octets
sont définitivement perdus depuis cet enchainement d'exécution.</p>
<p>Mais les emplacements ne sont pas humainement lisibles, on a des adresses
mémoire en hexadécimal. Nous allons ajouter un argument à la compilation pour
avoir des <strong>symboles de débug</strong>.</p>
<pre><code class="language-text">$ gcc -g test.c -o mon_super_programme
</code></pre>
<p>L'option <strong>-g</strong> permet d'ajouter des symboles de débug à ton programme. Ca te
permet de déboguer plus efficacement tes programmes. Mais attention à ne pas
livrer en production ce que tu produis avec des informations. Des gens mal
intentionnés pourraient s'en servir.</p>
<pre><code class="language-text">$ valgrind --leak-check=full ./mon_super_programme coucou
...
==5550== 7 bytes in 1 blocks are definitely lost in loss record 1 of 1
==5550==    at 0x48447A8: malloc (vg_replace_malloc.c:446)
==5550==    by 0x109194: arg_copy (test.c:8)
==5550==    by 0x10923B: main (test.c:33)
...
$
</code></pre>
<p>On peut lire ici que le premier appel à <strong>arg_copy</strong> se fait dans la fonction
<strong>main</strong> à la ligne 33, et que <strong>arg_copy</strong> fait appel à <strong>malloc</strong> ligne 8.</p>
<p>On sait où se trouve notre memory leak !</p>
<h3 id="recoder-malloc-et-free"><a class="header" href="#recoder-malloc-et-free">Recoder malloc et free</a></h3>
<p>Nous n'allons pas faire ça ici, mais dans les écoles d'informatiques, il y a un
exercice assez répandu qui est de recoder et remplacer malloc et free. C'est un
exercice ma foi fort sympathique.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../c/advanced_pointers.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../c/linked_lists.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../c/advanced_pointers.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../c/linked_lists.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
