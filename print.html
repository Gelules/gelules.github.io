<!DOCTYPE HTML>
<html lang="fr" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pédiluve</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Pédiluve</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Cet e-bouquin a pour objectif de préparer les étudiants à l'épreuve
d'informatique communément appelée "Piscine", qu'importe l'école.</p>
<p>Il utilise des connaissances également présentes sur <a href="https://www.youtube.com/@gelules">cette chaine Youtube</a></p>
<p>Je pars du fait que je peux te tutoyer et que ton épreuve demande d'apprendre le
langage C sur un système UNIX (genre MacOS) ou UNIX-like (genre GNU/Linux).</p>
<p>Pour être sûr de n'oublier personne, je repars de zéro ici. J'assume que tu ne
sais rien. Ne t'étonne pas si j'ai l'air de raconter des banalités, tout le
monde n'a pas tes connaissances. J'ai l'habitude de prendre mes étudiants pour
des cons. Ca fonctionne plutôt bien quant à leur apprentissage.</p>
<p>Le but de l'e-bouquin n'est pas te de rendre bon sur le champs, mais de t'aider
à appréhender les notions difficiles qui t'attendent et d'avoir des outils pour
les travailler. Tu gagneras en compétences dans le temps. Cependant, je présente
un nombre de notions assez important.</p>
<p>Je ne peux pas présenter tous les exercices des piscines ; ce serait de la
triche. Mais je peux présenter les exercices communs à chaque école, des tous
petits exercices qui sont des classiques.</p>
<p>Je présente également des outils que j'utilise au quotidien (awesomewm, vim,
...), qui ne sont pas toujours présentés dans les piscines. Ca te servira à
avoir des références en plus pour travailler efficacement.</p>
<p>Tu sortiras de ce cours avec plus qu'il n'en faut pour attaquer la Piscine
d'EPITA, Epitech, 42, ou une autre école qui a également repris le concept.
<strong>Pour l'instant</strong>, seule l'école 2600 échappe à l'objectif de ce document, car
elle a de l'assembleur dans son bootcamp d'entrée que je ne présente pas encore.</p>
<p>J'essaie d'être le plus simple et pratique possible. Pour les professionnels du
métier, il y a des parties laissées de côté pour ne pas alourdir la
compréhension des notions aux nouveaux étudiants. Je préfère mettre en avant
l'exemple et la compréhension par la pratique avec des petits codes de test
plutôt que des longs chapitres magistraux. Il <em>manque</em> également des parties
pour compléter des notions, mais ce sont des notions que les étudiants
aborderont pendant leur Piscine, elles ne sont pas réellement manquantes pour un
Pédiluve.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vous-navez-pas-les-bases"><a class="header" href="#vous-navez-pas-les-bases">Vous n'avez pas les bases</a></h1>
<p>\[ chiffre * base ^{indice} \]</p>
<p>Avant d'attaquer la pratique, il faut revoir quelques préliminaires
mathématiques.</p>
<p>En informatique, plusieurs bases sont utilisées pour travailler avec des
données. Les bases 2, 16 et 8. Cette dernière est plus rarement utilisée et ne
sera pas abordée dans ce cours. Mais avec les connaissances que tu auras en
travaillant les bases 2 et 16, tu sauras travailler avec la base 8 simplement.</p>
<p>Avant de travailler les autres bases, tu vas revoir la base 10 que tu utilises
tous les jours.</p>
<p>La base 10 possède 10 chiffres : 0, 1, 2, 3, 4, 5, 6, 7, 8 et 9.</p>
<p>La base 10 utilise les puissances de 10. Prends ce tableau en référence :</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 10^4\]</td><td>\[ 10^3\]</td><td>\[ 10^2\]</td><td>\[ 10^1\]</td><td>\[ 10^0\]</td></tr>
<tr><td>Valeur</td><td>10000</td><td>1000</td><td>100</td><td>10</td><td>1</td></tr>
</tbody></table>
</div>
<p>Tu peux voir que \[ 10^3 = 1000\]</p>
<p>La base 10 ne fait que se multiplier par 10 pour passer à l'indice suivant.</p>
<p>Ce tableau est à utiliser pour décomposer n'importe quel nombre.</p>
<p>Prenons un nombre pris au hasard : 4269.</p>
<p>Pour décomposer ton nombre tu vas d'abord reporter le nombre sous le tableau en
partant de la droite, ce qui donne :</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 10^4\]</td><td>\[ 10^3\]</td><td>\[ 10^2\]</td><td>\[ 10^1\]</td><td>\[ 10^0\]</td></tr>
<tr><td>Valeur</td><td>10000</td><td>1000</td><td>100</td><td>10</td><td>1</td></tr>
<tr><td>Nombre</td><td></td><td>4</td><td>2</td><td>6</td><td>9</td></tr>
</tbody></table>
</div>
<p>Tu peux voir que <em>4</em> a comme indice <em>3</em>, que <em>2</em> a comme indice <em>2</em>, que <em>6</em> a
comme indice <em>1</em> et que <em>9</em> a comme indice <em>0</em>.</p>
<p>Décompose le nombre ainsi :
\[ 4 * 10^3 + 2 * 10^2 + 6 * 10^1 + 9 * 10^0 \]</p>
<p>Calcule les puissances :
\[ 4 * 1000 + 2 * 100 + 6 * 10 + 9 * 1 \]</p>
<p>Calcule les multiplications :
\[ 4000 + 200 + 60 + 9 \]</p>
<p>Tu as décomposé ton nombre en utilisant la base 10.</p>
<p>Pourquoi tous ces efforts ?</p>
<p>Pour te préparer aux bases 2 et 16.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="franklin-savait-compter-deux-par-deux"><a class="header" href="#franklin-savait-compter-deux-par-deux">Franklin savait compter deux par deux</a></h1>
<h2 id="de-la-base-10-à-la-base-2"><a class="header" href="#de-la-base-10-à-la-base-2">De la base 10 à la base 2</a></h2>
<p><a href="https://www.youtube.com/watch?v=bg8eyeYF7lw">Cours vidéo</a></p>
<p>Maintenant que tu as compris comment décomposer un nombre en base 10, tu vas
apprendre à transformer un nombre écrit en base 10 en base 2 et inversement.</p>
<p>Pour rappel, la base 2 a deux chiffres : 0 et 1.</p>
<p>Prends ce tableau en référence</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 2^{10} \]</td><td>\[ 2^9\]</td><td>\[ 2^8\]</td><td>\[ 2^7\]</td><td>\[ 2^6\]</td><td>\[ 2^5\]</td><td>\[ 2^4\]</td><td>\[ 2^3\]</td><td>\[ 2^2\]</td><td>\[ 2^1\]</td><td>\[ 2^0\]</td></tr>
<tr><td>Valeur</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr>
</tbody></table>
</div>
<p>La base 2 ne fait que se multiplier par 2 à chaque nouvel indice.</p>
<p>Le tableau va jusqu'à 1024 car c'est le strict minimum à connaître par coeur.</p>
<p>Prends un nombre, complètement au hasard : 651.</p>
<p>Tu vas le soustraire par la puissance de 2 inférieure ou égale la plus proche.</p>
<p>Reprends le tableau.
La puissance de 2 inférieure ou égale la plus proche de 651 est... 512.</p>
<p>\[ 651 - 512 = 139\]</p>
<p>Tu as <strong>1</strong> fois 512 dans ton nombre de départ, reporte le chiffre 1 sous 512.</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 2^{10} \]</td><td>\[ 2^9\]</td><td>\[ 2^8\]</td><td>\[ 2^7\]</td><td>\[ 2^6\]</td><td>\[ 2^5\]</td><td>\[ 2^4\]</td><td>\[ 2^3\]</td><td>\[ 2^2\]</td><td>\[ 2^1\]</td><td>\[ 2^0\]</td></tr>
<tr><td>Valeur</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr>
<tr><td>Nombre</td><td></td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Recommence avec le nouveau nombre qui est 139.
La puissance de 2 inférieure ou égale la plus proche de 139 est... 128.
Tu as <strong>1</strong> fois 128 dans ton nouveau nombre, reporte le chiffre 1 sous 128.</p>
<p>\[ 139 - 128 = 11 \]</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 2^{10} \]</td><td>\[ 2^9\]</td><td>\[ 2^8\]</td><td>\[ 2^7\]</td><td>\[ 2^6\]</td><td>\[ 2^5\]</td><td>\[ 2^4\]</td><td>\[ 2^3\]</td><td>\[ 2^2\]</td><td>\[ 2^1\]</td><td>\[ 2^0\]</td></tr>
<tr><td>Valeur</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr>
<tr><td>Nombre</td><td></td><td>1</td><td></td><td>1</td><td></td><td></td><td></td><td></td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Recommence avec le nouveau nombre qui est 11.
La puissance de 2 inférieure ou égale la plus proche de 11 est... 8.
Tu as <strong>1</strong> fois 8 dans ton nouveau nombre, reporte le chiffre 1 sous 8.</p>
<p>\[ 11 - 8 = 3 \]</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 2^{10} \]</td><td>\[ 2^9\]</td><td>\[ 2^8\]</td><td>\[ 2^7\]</td><td>\[ 2^6\]</td><td>\[ 2^5\]</td><td>\[ 2^4\]</td><td>\[ 2^3\]</td><td>\[ 2^2\]</td><td>\[ 2^1\]</td><td>\[ 2^0\]</td></tr>
<tr><td>Valeur</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr>
<tr><td>Nombre</td><td></td><td>1</td><td></td><td>1</td><td></td><td></td><td></td><td>1</td><td></td><td></td><td></td></tr>
</tbody></table>
</div>
<p>Recommence avec le nouveau nombre qui est 3.
La puissance de 2 inférieure ou égale la plus proche de 3 est... 2.
Tu as <strong>1</strong> fois 2 dans ton nouveau nombre, reporte le chiffre 1 sous 2.</p>
<p>\[ 3 - 2 = 1 \]</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 2^{10} \]</td><td>\[ 2^9\]</td><td>\[ 2^8\]</td><td>\[ 2^7\]</td><td>\[ 2^6\]</td><td>\[ 2^5\]</td><td>\[ 2^4\]</td><td>\[ 2^3\]</td><td>\[ 2^2\]</td><td>\[ 2^1\]</td><td>\[ 2^0\]</td></tr>
<tr><td>Valeur</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr>
<tr><td>Nombre</td><td></td><td>1</td><td></td><td>1</td><td></td><td></td><td></td><td>1</td><td></td><td>1</td><td></td></tr>
</tbody></table>
</div>
<p>Recommence avec le nouveau nombre qui est 1.
La puissance de 2 inférieure ou égale la plus proche de 1 est... 1.
Tu as <strong>1</strong> fois 1 dans ton nouveau nombre, reporte le chiffre 1 sous 1.</p>
<p>\[ 1 - 1 = 0 \]</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 2^{10} \]</td><td>\[ 2^9\]</td><td>\[ 2^8\]</td><td>\[ 2^7\]</td><td>\[ 2^6\]</td><td>\[ 2^5\]</td><td>\[ 2^4\]</td><td>\[ 2^3\]</td><td>\[ 2^2\]</td><td>\[ 2^1\]</td><td>\[ 2^0\]</td></tr>
<tr><td>Valeur</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr>
<tr><td>Nombre</td><td></td><td>1</td><td></td><td>1</td><td></td><td></td><td></td><td>1</td><td></td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>Il te reste 0, tu as terminé. Reprends le tableau et ajoute <strong>0</strong> aux cases où
tu n'as pas écrit <strong>1</strong>.</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 2^{10} \]</td><td>\[ 2^9\]</td><td>\[ 2^8\]</td><td>\[ 2^7\]</td><td>\[ 2^6\]</td><td>\[ 2^5\]</td><td>\[ 2^4\]</td><td>\[ 2^3\]</td><td>\[ 2^2\]</td><td>\[ 2^1\]</td><td>\[ 2^0\]</td></tr>
<tr><td>Valeur</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr>
<tr><td>Nombre</td><td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>Ce sont les puissances de 2 que tu n'as pu soustraire à chaque nombre que tu
avais.</p>
<p>Tu peux donc dire que 651 en base 10 s'écrit 1010001011 en base 2.</p>
<h2 id="de-la-base-2-à-la-base-10"><a class="header" href="#de-la-base-2-à-la-base-10">De la base 2 à la base 10</a></h2>
<p>Tu vas maintenant faire l'inverse, passer de la base 2 à la base 10. Toujours
avec le tableau. Tu vas voir ça va être encore plus rapide.</p>
<p>Prenons un nombre en base 2 complètement au hasard : 1010011010.</p>
<p>Tu vas inscrire ce nombre dans le tableau le plus à droite possible.</p>
<div class="table-wrapper"><table><thead><tr><th>Indice</th><th>10</th><th>9</th><th>8</th><th>7</th><th>6</th><th>5</th><th>4</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>Notation</td><td>\[ 2^{10} \]</td><td>\[ 2^9\]</td><td>\[ 2^8\]</td><td>\[ 2^7\]</td><td>\[ 2^6\]</td><td>\[ 2^5\]</td><td>\[ 2^4\]</td><td>\[ 2^3\]</td><td>\[ 2^2\]</td><td>\[ 2^1\]</td><td>\[ 2^0\]</td></tr>
<tr><td>Valeur</td><td>1024</td><td>512</td><td>256</td><td>128</td><td>64</td><td>32</td><td>16</td><td>8</td><td>4</td><td>2</td><td>1</td></tr>
<tr><td>Nombre</td><td></td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<p>Maintenant, tu n'as qu'à reprendre les puissances de 2 avec un <strong>1</strong> en dessous
et les sommer ensemble.</p>
<p>\[ 512 + 128 + 16 + 8 + 2 = 666 \]</p>
<h2 id="dans-le-cas-de-grands-nombres"><a class="header" href="#dans-le-cas-de-grands-nombres">Dans le cas de grands nombres</a></h2>
<p>Si tu dois passer de la base 10 à la base 2 mais avec un nombre plus grand que
le tableau, il existe une technique pour généraliser la transformation.</p>
<p>Prenons un nombre vraiment plus grand que 1024 : 6789.</p>
<p>Tu vas diviser par 2 ton nombre et garder à chaque fois le <strong>reste</strong> de côté.
Rappelle toi de tes cours de primaire, c'est une opération euclidienne.</p>
<p>L'opération mathématique pour avoir le reste est %.</p>
<p>Ainsi si j'écris
\[ x \% 2 = 0 \]
c'est qu'il reste 0 à la division <strong>x / 2</strong>. Tu peux aussi dire que <em>x</em> est pair.</p>
<p>Et si j'écris
\[ x \% 2 = 1 \]
c'est qu'il reste 1 à la division <strong>x / 2</strong>. Tu peux aussi dire que <em>x</em> est impair.</p>
<p>Tu vas faire apparaître le résultat petit à petit avec cet affichage :</p>
<p>Résultat =</p>
<p>Il se remplira à chaque itération de tes calculs en y inscrivant le reste que tu
viens de calculer sur la gauche.</p>
<p>\[ 6789 / 2 = 3394 \]
\[ 6789 \% 2 = 1 \]
Résultat = 1</p>
<p>\[ 3394 / 2 = 1697 \]
\[ 3394 \% 2 = 0 \]
Résultat = 01</p>
<p>\[ 1697 / 2 = 848 \]
\[ 1697 \% 2 = 1 \]
Résultat = 101</p>
<p>\[ 848 / 2 = 424 \]
\[ 848 \% 2 = 0 \]
Résultat = 0101</p>
<p>\[ 424 / 2 = 212 \]
\[ 424 \% 2 = 0 \]
Résultat = 00101</p>
<p>\[ 212 / 2 = 106 \]
\[ 212 \% 2 = 0 \]
Résultat = 000101</p>
<p>\[ 106 / 2 = 53 \]
\[ 106 \% 2 = 0 \]
Résultat = 0000101</p>
<p>\[ 53 / 2 = 26 \]
\[ 53 \% 2 = 1 \]
Résultat = 10000101</p>
<p>\[ 26 / 2 = 13 \]
\[ 26 \% 2 = 0 \]
Résultat = 010000101</p>
<p>\[ 13 / 2 = 6 \]
\[ 13 \% 2 = 1 \]
Résultat = 1010000101</p>
<p>\[ 6 / 2 = 3 \]
\[ 6 \% 2 = 0 \]
Résultat = 01010000101</p>
<p>\[ 3 / 2 = 1 \]
\[ 3 \% 2 = 1 \]
Résultat = 101010000101</p>
<p>\[ 1 / 2 = 0 \]
\[ 1 \% 2 = 1 \]
Résultat = 1101010000101</p>
<p>Ta dernière division donne 0. Tu as terminé.</p>
<p>Tu sais maintenant que 6789 s'écrit 1101010000101 en base 2.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cest-exact"><a class="header" href="#cest-exact">C'est exact</a></h1>
<p>La notation en base 16 est appellée <em>hexadécimale</em>.</p>
<p>Les plus avertis se demanderont comment écrire un nombre dans une base plus
grande que 10. La base 2 utilise 0 et 1, la base 10 va de 0 et 9... mais
qu'utiliser quand on va au delà de 9 ?</p>
<p>Les lettres de l'alphabet !</p>
<p>Ainsi la base 16 va de 0 à F. Voici les chiffres de la base 16 : 0, 1, 2, 3, 4,
5, 6, 7, 8, 9, A, B, C, D, E et F.</p>
<p>Voici un tableau de référence :</p>
<div class="table-wrapper"><table><thead><tr><th>Base 2</th><th>Base 10</th><th>Base 16</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
<tr><td>10</td><td>2</td><td>2</td></tr>
<tr><td>11</td><td>3</td><td>3</td></tr>
<tr><td>100</td><td>4</td><td>4</td></tr>
<tr><td>101</td><td>5</td><td>5</td></tr>
<tr><td>110</td><td>6</td><td>6</td></tr>
<tr><td>111</td><td>7</td><td>7</td></tr>
<tr><td>1000</td><td>8</td><td>8</td></tr>
<tr><td>1001</td><td>9</td><td>9</td></tr>
<tr><td>1010</td><td>10</td><td>A</td></tr>
<tr><td>1011</td><td>11</td><td>B</td></tr>
<tr><td>1100</td><td>12</td><td>C</td></tr>
<tr><td>1101</td><td>13</td><td>D</td></tr>
<tr><td>1110</td><td>14</td><td>E</td></tr>
<tr><td>1111</td><td>15</td><td>F</td></tr>
<tr><td>10000</td><td>16</td><td>10</td></tr>
<tr><td>10001</td><td>17</td><td>11</td></tr>
<tr><td>10010</td><td>18</td><td>12</td></tr>
<tr><td>10011</td><td>29</td><td>13</td></tr>
<tr><td>10100</td><td>20</td><td>14</td></tr>
<tr><td>10101</td><td>21</td><td>15</td></tr>
<tr><td>10110</td><td>22</td><td>16</td></tr>
<tr><td>10111</td><td>23</td><td>17</td></tr>
<tr><td>11000</td><td>24</td><td>18</td></tr>
<tr><td>11001</td><td>25</td><td>19</td></tr>
<tr><td>11010</td><td>26</td><td>1A</td></tr>
<tr><td>11011</td><td>27</td><td>1B</td></tr>
<tr><td>11100</td><td>28</td><td>1C</td></tr>
<tr><td>11101</td><td>29</td><td>1D</td></tr>
<tr><td>11110</td><td>30</td><td>1E</td></tr>
<tr><td>11111</td><td>31</td><td>1F</td></tr>
<tr><td>100000</td><td>32</td><td>20</td></tr>
</tbody></table>
</div>
<p>On dira ainsi qu'en base 16, A est un chiffre et le nombre 10 vaut 16 en base
10.</p>
<p>Tu peux réutiliser les notions vues en base 2 pour la base 16 pour passer de
l'un à l'autre. Pas besoin d'alourdir le cours avec des calculs supplémentaires.</p>
<p>Voici quelques valeurs à connaître par coeur.</p>
<div class="table-wrapper"><table><thead><tr><th>Base 2</th><th>Base 10</th><th>Base 16</th></tr></thead><tbody>
<tr><td>1010</td><td>10</td><td>A</td></tr>
<tr><td>1111</td><td>15</td><td>F</td></tr>
<tr><td>10000</td><td>16</td><td>10</td></tr>
<tr><td>11000</td><td>24</td><td>18</td></tr>
<tr><td>100000</td><td>32</td><td>20</td></tr>
<tr><td>110000</td><td>48</td><td>30</td></tr>
<tr><td>1000000</td><td>64</td><td>40</td></tr>
<tr><td>10000000</td><td>128</td><td>80</td></tr>
<tr><td>11111111</td><td>255</td><td>FF</td></tr>
<tr><td>100000000</td><td>256</td><td>100</td></tr>
<tr><td>10000000000</td><td>1024</td><td>400</td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><h1 id="bit-et-octet"><a class="header" href="#bit-et-octet">Bit et octet</a></h1>
<h2 id="bit"><a class="header" href="#bit">Bit</a></h2>
<p>Le bit est la quantité minimale d'information utilisable en informatique. Elle
n'a que deux valeurs : 0 et 1.</p>
<p>Si tu as mille bits, tu as un kilobit, que tu peux écrire avec un petit 'b' : 1
kb.</p>
<p>Si tu as un million de bits, tu écris un mégabit ou 1 Mb.</p>
<p>Si tu as un milliard de bits, tu écris un gigabit ou 1 Gb.</p>
<h2 id="octet"><a class="header" href="#octet">Octet</a></h2>
<p>L'octet est composé de 8 bits. Sa traduction en Anglais est le byte.</p>
<p>Tu peux utiliser la même notation qu'avec le bit mais en utilisant un 'o'
minuscule ou un 'B' majuscule en Anglais.</p>
<p>Si tu as mille octets, tu as un kilooctet ou un kilobyte, que tu peux écrire 1 ko ou 1 kB.</p>
<p>Si tu as un million d'octets, tu écris un mégaoctet ou 1 megabyte, que tu peux écrire 1 Mo ou 1 MB.</p>
<p>Si tu as un milliard d'octets, tu écris un gigaoctet ou 1 gigabyte, que tu peux écrire 1 Go ou 1 GB.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="portes-logiques"><a class="header" href="#portes-logiques">Portes logiques</a></h1>
<p>Enfant, tu as appris les opérations mathématiques élémentaires : l'addition, la
soustraction, la multiplication et la division.</p>
<p>En informatique, il existe d'autres opérations élémentaires qu'on appelle des
portes logiques.</p>
<p>Tu vas appliquer ces portes logiques sur des bits, c'est à dire 0 et 1. Tu peux
remplacer 0 par Faux et 1 par Vrai comme valeurs logiques.</p>
<h2 id="not"><a class="header" href="#not">NOT</a></h2>
<p>La porte NOT est un inverseur. Elle prend une entrée et une sortie. Son rôle est
d'inverser la valeur en entrée.</p>
<div class="table-wrapper"><table><thead><tr><th>Entrée</th><th>Sortie</th></tr></thead><tbody>
<tr><td>0</td><td>1</td></tr>
<tr><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<h2 id="and"><a class="header" href="#and">AND</a></h2>
<p>La porte AND a deux entrées. Pour que le signal de sortie soit Vrai, il faut que
les deux signaux aux entrées le soient également.</p>
<div class="table-wrapper"><table><thead><tr><th>Entrée 1</th><th>Entrée 2</th><th>Sortie</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>0</td></tr>
<tr><td>1</td><td>0</td><td>0</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>Si tu as besoin d'une phrase logique pour mieux comprendre, imagine que tu fais
des courses pour faire un gâteau (miam). Dans une ville, il existe deux
magasins, un spécialisé en lait et l'autre en farine.</p>
<p>Il faut que les deux magasins possèdent les bons produits pour que tu puisses
faire ton gâteau.</p>
<h2 id="or"><a class="header" href="#or">OR</a></h2>
<p>La porte OR a deux entrées. Pour que le signal de sortie soit Vrai, il faut
qu'au moins une des entrées soit à Vrai.</p>
<div class="table-wrapper"><table><thead><tr><th>Entrée 1</th><th>Entrée 2</th><th>Sortie</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>Si tu as besoin d'une phrase logique pour mieux comprendre, imagine que tu fais
des courses pour acheter un gâteau (c'est plus rapide que de le préparer). Dans
une ville, il existe deux magasins spécialisés en gâteaux.</p>
<p>Il faut qu'au moins un des deux magasins soit ouvert pour que tu puisses avoir
ton gâteau.</p>
<h2 id="xor"><a class="header" href="#xor">XOR</a></h2>
<p>La porte XOR est un <em>eXclusive OR</em>, ou un <em>OU eXclusif</em>. Elle agit comme la
porte OR à condition d'avoir une exclusivité en entrée.</p>
<div class="table-wrapper"><table><thead><tr><th>Entrée 1</th><th>Entrée 2</th><th>Sortie</th></tr></thead><tbody>
<tr><td>0</td><td>0</td><td>0</td></tr>
<tr><td>0</td><td>1</td><td>1</td></tr>
<tr><td>1</td><td>0</td><td>1</td></tr>
<tr><td>1</td><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<p>Si tu as besoin d'une phrase logique pour mieux comprendre, imagine que tu fais
des courses pour le dernier disque de musique de ton artiste préféré. Dans
une ville, il existe deux magasins spécialisés en musique.</p>
<p>Il faut qu'au moins un des deux magasins possède les droits exclusifs de vente
pour qu'il existe une exclusivité. Si les deux magasins possèdent les droits de
vente, alors il n'y a pas d'exclusivité.</p>
<h1 id="autres-portes"><a class="header" href="#autres-portes">Autres portes</a></h1>
<p>Il existe d'autres portes logiques qui ne sont pas présentées ici. Elles ne te
seront pas utilises pour valider la piscine, mais elles pourraient l'êtres plus
tard. Je te laisse voir la <a href="https://fr.wikipedia.org/wiki/Porte_logique">page Wikipédia à leur sujet</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="choix-du-système"><a class="header" href="#choix-du-système">Choix du système</a></h1>
<p>Le choix du système n'est pas déterminant pour une piscine. Je conseille Ubuntu
qui est la distribution Linux désignée pour les novices. Cependant, je présente
également d'autres distributions qui ont leurs avantages et inconvénients. Les
pages qui suivent ont un lien pour télécharger la distribution et une vidéo pour
l'installer et la configurer.</p>
<p>Si tu es débutant complet, préfère Ubuntu. Les paquets (programmes) ne seront
pas toujours à jour, mais c'est une distribution d'une stabilité sans précédent
quand on ne sait pas mettre à jour ses paquets.</p>
<p>Si tu veux une distribution Linux toujours à jour et simple d'installation,
préfère Manjaro ou Fedora.</p>
<p>Si tu veux une distribution Linux toujours à jour et à installer à la main,
préfère Arch Linux.</p>
<p>Si tu veux une distribution qui isole tes paquets, qui t'assure une stabilité,
mais qui est bien plus compliquée à prendre en main quand on n'a pas l'habitude,
préfère NixOS.</p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/4DGf1y_JLI8" title="0.0 - Choisir son système - Système" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h1>
<p>ISO : <a href="https://www.ubuntu-fr.org/download">https://www.ubuntu-fr.org/download</a></p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/G8LGhxVbl0s" title="0.7 - Installer Ubuntu - Système" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="arch-linux"><a class="header" href="#arch-linux">Arch Linux</a></h1>
<p>ISO : <a href="https://archlinux.org/download/">https://archlinux.org/download/</a></p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/BY3BW5zlkgE" title="0.1 - Installer Arch Linux et Awesome - Système" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="manjaro"><a class="header" href="#manjaro">Manjaro</a></h1>
<p>ISO : <a href="https://manjaro.org/products/download/x86">https://manjaro.org/products/download/x86</a></p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/WvpLJIcO-zI" title="0.2 - Installer Manjaro XFCE - Système" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fedora"><a class="header" href="#fedora">Fedora</a></h1>
<p>ISO : <a href="https://fedoraproject.org/fr/workstation/download">https://fedoraproject.org/fr/workstation/download</a></p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/NeT_MnJIp9I" title="0.4 - Installer Fedora - Système" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="nixos"><a class="header" href="#nixos">NixOS</a></h1>
<p>ISO : <a href="https://nixos.org/download">https://nixos.org/download</a></p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/jVqegtCbuGQ?list=PLb5GOuL68SxEdTQrpoMIp_8eUEqzHn7oI" title="0.8 - Installer NixOS Custom - Système" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shell"><a class="header" href="#shell">Shell</a></h1>
<p>Le Shell est un langage de programmation qui te permet de dialoguer avec ton
système d'exploitation. Tu donnes des commandes à effectuer, et le système
exécutera tes ordres.</p>
<p>Le terminal graphique est ce qu'on appelle un émulateur de terminal, celui-ci va
appeler un interpréteur shell (sh, bash, zsh, dash, ...) qui interprétera tes
commandes.</p>
<p>Tous les interpréteurs comprennent le Shell, mais certains ont des extensions
qui te permettent une meilleure interactivité, avec de l'autocomplétion plus
intelligente, une correction des fautes, une plus grande souplesse
d'utilisation, etc.</p>
<p>J'utilise zsh, mais tout ce que je vais présenter est valide avec d'autres
interpréteurs.</p>
<p>Les prochains chapitres t'apprendront à utiliser ton terminal.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilisation"><a class="header" href="#utilisation">Utilisation</a></h1>
<p>J'admets ici que c'est la première fois que tu ouvres un shell qui a sa
configuration par défaut.</p>
<p>Une fois sur ton shell, voici ce qui se présente à toi.</p>
<pre><code class="language-text">username@hostname:~$
</code></pre>
<p>Décortiquons tout ça.</p>
<p><strong>username</strong> est ton nom d'utiisateur.</p>
<p>Le arobase '@' veut dire que tu es connecté sur une machine.</p>
<p><strong>hostname</strong> est le nom de cette machine.</p>
<p>Le deux-points ':' est un simple séparateur pour la suite de la ligne.</p>
<p>Le tilde '~' signifie que tu te trouves dans ton <strong>HOME</strong>. C'est ton répertoire
personnel avec tes fichiers personnels.</p>
<p>Le dollar '$' signifie que toutes les commandes que tu rentres sont exécutées
comme simple utilisateur.</p>
<p>Si tu avais un signe dièse '#' à la place, ça signifierait que les commandes
seront exécutées en tant que <strong>root</strong> (admin).</p>
<p>Pour simplifier la lecture des codes que je vais présenter, mon shell sera
présenté ainsi :</p>
<pre><code class="language-text">$
</code></pre>
<p>Pour essayer, entre la commande <strong>pwd</strong>, et vois la différence de résultat avec
la mienne.</p>
<pre><code class="language-text">$ pwd
/home/gelules
$
</code></pre>
<p>La commande <strong>pwd</strong> te dit où te trouves. C'est ton <strong>P</strong>ath <strong>W</strong>orking <strong>D</strong>irectory.</p>
<h1 id="shutdown-et-reboot"><a class="header" href="#shutdown-et-reboot">Shutdown et reboot</a></h1>
<p>Si tu veux arrêter ta machine, exécute la commande</p>
<pre><code class="language-text">$ shutdown now
</code></pre>
<p>Si tu veux rebooter ta machine, exécute la commande</p>
<pre><code class="language-text">$ reboot
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="se-déplacer"><a class="header" href="#se-déplacer">Se déplacer</a></h1>
<h2 id="introduction-1"><a class="header" href="#introduction-1">Introduction</a></h2>
<p>Maintenant que tu sais lire ce que t'affiche ton shell par défaut, tu vas
apprendre quelques manoeuvres de base.</p>
<p>Pour comprendre ce qu'il se passe, je te conseille d'ouvrir ton explorateur
graphique (le programme qui te permet de voir tes documents graphiquement) d'un
côté et ton shell de l'autre côté. Ca te permettra de faire le lien entre ce
que tu tapes et ce qu'il se passe dans ton système à chaque commande.</p>
<p>Ton explorateur graphique ne ressemblera peut-être pas au mien qui est Thunar.
Et j'aurai probablement à certains endroits des fichiers que tu n'as pas.
Ce n'est pas grave.</p>
<p>Dans tous les cas tu verras des dossiers et des fichiers et tu devras
double-cliquer pour te déplacer. Qui a dit que Windows avait l'exclusivité du
clique ?</p>
<p>Je te conseille de faire les mêmes commandes que moi, pour que ça rentre ! Ne
fais pas que lire. L'apprentissage vient surtout par la pratique, même si c'est
jouer au miroir.</p>
<p><img src="shell/./deplacements/init.png" alt="Explorateur et shell" title="Explorateur et shell" /></p>
<p>Tu vois que dans mon exemple, mon shell se trouve dans mon <strong>HOME</strong> et Thunar
aussi. La différence c'est que Thunar me liste directement tous mes fichiers.</p>
<h2 id="lister-un-répertoire"><a class="header" href="#lister-un-répertoire">Lister un répertoire</a></h2>
<p>Pour lister ton répertoire courant, utilises la commande <strong>ls</strong>.</p>
<pre><code class="language-text">$ ls
Desktop  Development  Documents  Downloads  Formation  mount_vbox_share.sh  Music  Pictures  Public  School  Templates  Videos
$
</code></pre>
<p>Tu peux donner un ou plusieurs noms de fichiers et répertoires à <strong>ls</strong> pour
lister leurs contenus.</p>
<p>Depuis ton HOME, exécute</p>
<pre><code class="language-text">ls Desktop Documents Downloads
</code></pre>
<p>Si ces répertoires n'existent pas chez toi, attends de savoir en créer pour
tester <strong>ls</strong> avec des noms de fichiers et répertoires donnés en paramètres.</p>
<h2 id="créer-un-répertoire"><a class="header" href="#créer-un-répertoire">Créer un répertoire</a></h2>
<p>Pour créer un répertoire, utilise la commande <strong>mkdir</strong>.</p>
<pre><code class="language-text">mkdir Test
</code></pre>
<p><img src="shell/./deplacements/mkdir_test.png" alt="mkdir Test" title="mkdir Test" /></p>
<p>Comme tu peux le voir, mon explorateur de fichiers s'est actualisé pour afficher
le nouveau répertoire. Utilise la commande <strong>ls</strong> dans ton terminal pour valider
que ton terminal le voit également.</p>
<p>Sache que tu peux créer plusieurs répertoires d'un coup en les donnant à
<strong>mkdir</strong>.</p>
<pre><code class="language-text">$ mkdir Je suis un seul appel a mkdir
</code></pre>
<p>Les commandes shell ont pour habitude de ne rien afficher si tout se passe bien.
En cas d'erreur, un message s'affichera. Lis toujours tes messages, il ne faut
pas avoir peur. C'est justement une aide pour comprendre ce qu'il se passe.</p>
<p><img src="shell/./deplacements/remkdir_test.png" alt="mkdir Test deux fois" title="mkdir Test 2 fois" /></p>
<p>Ici, j'ai voulu créer le répertoire <strong>Test</strong> alors qu'il existe déjà.</p>
<h1 id="se-déplacer-dans-un-répertoire"><a class="header" href="#se-déplacer-dans-un-répertoire">Se déplacer dans un répertoire</a></h1>
<p>Pour te déplacer dans un répertoire graphiquement, c'est facile, tu
doubles-cliques dessus.</p>
<p>Pour te déplacer dans un répertoire en terminal, c'est facile, tu utilises la
commande <strong>cd</strong>.</p>
<pre><code class="language-text">$ cd Test
</code></pre>
<p>Déplace toi dans le répertoire <strong>Test</strong>.</p>
<p><img src="shell/./deplacements/cd_test.png" alt="cd Test" title="cd Test" /></p>
<p>Ton shell affiche maintenant <strong>~/Test</strong>. Ca veut dire qu'il se situe dans le
répertoire <strong>Test</strong> lui-même situé dans ton <strong>HOME</strong>.</p>
<p>Tu peux créer une arborescence complète en donnant le paramètre <strong>-p</strong> à mkdir.</p>
<pre><code class="language-text">$ mkdir -p je/suis/une/longue/arborescence
$
</code></pre>
<p><img src="shell/./deplacements/mkdir_path.png" alt="mkdir path" title="mkdir path" /></p>
<h2 id="créer-des-fichiers"><a class="header" href="#créer-des-fichiers">Créer des fichiers</a></h2>
<p>Tu ne vas pas encore voir comment éditer des fichiers. Tu vas commencer par
créer des fichiers vides.</p>
<p>Pour se faire, utilise la commande <strong>touch</strong>.</p>
<pre><code class="language-text">$ touch je_suis_un_fichier
$ ls
</code></pre>
<h1 id="listing-long-format"><a class="header" href="#listing-long-format">Listing long format</a></h1>
<p>Jusqu'ici tu as dû voir les différences entre fichier et répertoire aux couleurs
affichées sur le terminal avec <strong>ls</strong>. Cette coloration est dûe à une
configuration de <strong>ls</strong>.</p>
<p>Dans mon cas, si j'exécuter <strong>which ls</strong> pour en savoir plus sur la commande
<strong>ls</strong>, j'ai ceci :</p>
<pre><code class="language-text">$ which ls
ls: aliased to ls --color=auto
$
</code></pre>
<p>Ca veut dire que <strong>ls</strong> utilise par défaut le paramètre <strong>--color=auto</strong> qui
colore les noms des fichiers et répertoires dans ton terminal.</p>
<p>Exécute maintenant ceci, je fais exprès de cacher certains informations pour te
forcer à exécuter les commandes :</p>
<pre><code class="language-text">$ ls
$ mkdir repertoire
$ touch fichier
$ /bin/ls
repertoire fichier
$
</code></pre>
<p>Tu vois maintenant que tout s'affiche en blanc. Ce que tu as fait, c'est
exécuter le programme <strong>ls</strong> directement depuis là où il est installé, sans la
configuration de coloration automatique de ton shell.</p>
<p>Imagine tomber un jour sur une distribution Linux qui n'affiche pas les couleurs
par défaut, comment savoir si ce que tu listes et un fichier ou un répertoire ?</p>
<p>Tu vas utiliser le paramètre <strong>-l</strong> à <strong>ls</strong> pour afficher le <em>long listing
format</em>, pour afficher plein d'informations sur le répertoire où tu te trouves.</p>
<p>Exécute</p>
<pre><code class="language-text">$ ls -l
total 0
-rw-r--r-- 1 gelules wheel  0 Jul 20 18:56 fichier
drwxr-xr-x 2 gelules wheel 40 Jul 20 18:55 repertoire
$
</code></pre>
<p>La première ligne indique combien de place sur le disque prend ce que tu listes.
Pour l'instant c'est 0 car c'est vide.</p>
<p>Mainenant, pour chaque ligne, regarder le tout premier caractère. Si c'est un
tirer '-', c'est que tu listes un fichier, si c'est un 'd' minuscule, c'est que
c'est un répertoire.</p>
<p>Tu apprendras le reste des informations listées dans un prochain chapitre.</p>
<h2 id="lister-récursivement"><a class="header" href="#lister-récursivement">Lister récursivement</a></h2>
<p>Pour atteindre graphiquement la fin de l'arborescence, ça demande quelques
clics. Alors que pour le shell, il suffit de donner le paramètre <strong>-R</strong> à ls
pour lui demander de lister <strong>récursivement</strong> les répertoires.</p>
<p><img src="shell/./deplacements/ls_recursif.png" alt="ls récursif" title="ls récursif" /></p>
<p>Pour information, le '.' situé au début de chaque résultat représente ton
dossier courant (le <em>working directory</em>). Ca veut dire que si tu fais la
commande</p>
<pre><code class="language-text">$ cd .
</code></pre>
<p>Tu te déplaceras... où tu te trouves.</p>
<p>J'ai un exemple pratique qui sera présenté plus tard.</p>
<h2 id="supprimer-des-fichiers-et-répertoires"><a class="header" href="#supprimer-des-fichiers-et-répertoires">Supprimer des fichiers et répertoires</a></h2>
<p>Pour supprimer des répertoires, il existe deux commandes. *<em>rmdir</em> et <strong>rm</strong>.</p>
<p><strong>rmdir</strong> va supprimer un répertoire <strong>vide</strong> et <strong>rm</strong> avec les bons paramètres
va supprimer un répertoire et toute son arborescence récursivement.</p>
<p>Essaie le commandes suivantes, je n'affiche pas le résultat pour te forcer à
visualiser par toi-même ce qu'il se passe.</p>
<pre><code class="language-text">$ ls
je je_suis_un_fichier
$ rmdir je_suis_un_fichier
??? # Mais diantre, que se passe t-il ?
$ rm je_suis_un_fichier
$ ls
je
$ ls -R
.:
je

./je:
suis

./je/suis:
une

./je/suis/une:
longue

./je/suis/une/longue:
arborescence

./je/suis/une/longue/arborescence:
$ rmdir je
??? # Mais diantre, que se passe t-il ?
$ rmdir je/suis/une/longue/arborescence
$ ls -R
???
$ rm -r je
$ ls -R
$
</code></pre>
<p>Tu l'as compris, le paramètre <strong>-r</strong> de <strong>rm</strong> supprime toute une arborescence.</p>
<p><strong>rm</strong> peut aussi être utilisé pour supprimer des fichiers, mais nous n'avons
pas encore vu ce cas.</p>
<p>Tu peux également donner plusieurs répertoires à <strong>rmdir</strong> et <strong>rm</strong> pour en
supprimer plusieurs. Attention, <strong>rm</strong> doit toujours avoir son paramètre <strong>-r</strong>
si tu supprimes des répertoires. Dans le cas de fichiers, tu n'as pas besoin de
l'utiliser.</p>
<pre><code class="language-text">$ rmdir Je suis un seul appel a mkdir
</code></pre>
<p>ou</p>
<pre><code class="language-text">$ rm -r Je suis un seul appel a mkdir
</code></pre>
<h2 id="copier-des-fichiers-et-répertoires"><a class="header" href="#copier-des-fichiers-et-répertoires">Copier des fichiers et répertoires</a></h2>
<p>Pour copier des fichiers et des répertoires, tu peux utiliser la commande
<strong>cp</strong>.</p>
<pre><code class="language-text">$ ls
$ touch fichier_1
$ cp fichier_1 fichier_2
$ mkdir repertoire_1
$ cp fichier_1 fichier_2 repertoire_1
$ cp -r repertoire_1 repertoire_2
$ ls
fichier_1  fichier_2  repertoire_1  repertoire_2
$ ls repertoire_1 repertoire_2
repertoire_1:
fichier_1  fichier_2

repertoire_2:
fichier_1  fichier_2
$ mkdir repertoire_3
$ cp -r repertoire_1 repertoire_2 repertoire_3
$ ls repertoire_3
repertoire_1  repertoire_2
$
</code></pre>
<p>Comme tu peux le constater, si tu veux copier un répertoire, il faut le faire
récursivement avec l'option <strong>-r</strong>.</p>
<h2 id="renommer-des-fichiers-et-répertoires"><a class="header" href="#renommer-des-fichiers-et-répertoires">Renommer des fichiers et répertoires</a></h2>
<p>Pour renommer ou déplacer un répertoire ou un fichier, utilise la commande
<strong>mv</strong>, pour <em>M</em>o<em>V</em>e.</p>
<pre><code class="language-text">$ touch gato
$ ls
gato
$ mv gato gateau
$ ls
gateau
$ mkdir ventre
$ mv gateau ventre
$ ls
ventre
$ ls ventre
gateau
$
</code></pre>
<p>En réalité quand tu <em>renommes</em> un fichier, tu le déplaces dans le même
répertoire avec un nouveau nom.</p>
<h2 id="cd-en-arrière"><a class="header" href="#cd-en-arrière">cd en arrière</a></h2>
<p>Tu sais avancer dans des répertoires, mais comment revenir en arrière ?</p>
<p>Il faut donner <strong>..</strong> à cd pour revenir en arrière. Chaque <strong>..</strong> part en
arrière d'un niveau.</p>
<p>Un exemple sera plus parlant.</p>
<pre><code class="language-text">$ mkdir -p toto/titi/tutu
$ cd toto/titi/tutu
$ cd ..
$ ls
tutu
$ cd ../..
$ ls
toto
$
</code></pre>
<h2 id="retourner-au-dernier-répertoire-visité-avec-cd"><a class="header" href="#retourner-au-dernier-répertoire-visité-avec-cd">Retourner au dernier répertoire visité avec cd</a></h2>
<p>Si tu veux basculer vers le dernier répertoire visité, donne <strong>-</strong> en paramètre
à <strong>cd</strong>.</p>
<p>Je te laisse faire les commandes pour apprécier, j'ai caché exprès les parties
intéressantes.</p>
<pre><code class="language-text">$ mkdir -p je/suis/un/humain tu/es/un/gateau
$ cd je/suis/un/humain
$ cd ../../../../tu/es/un/gateau
$ pwd
???
$ cd -
$ pwd
???
$ cd -
$ pwd
???
$
</code></pre>
<h2 id="retourner-dans-le-home-avec-cd"><a class="header" href="#retourner-dans-le-home-avec-cd">Retourner dans le HOME avec cd</a></h2>
<p>Si tu veux retourner rapidement dans ton <strong>HOME</strong>, tu peux le faire en appellant
simplement <strong>cd</strong> sans paramètre.</p>
<p>Je te laisse faire les commandes pour apprécier, j'ai caché exprès les parties
intéressantes.</p>
<pre><code class="language-text">$ cd je/suis/un/humain
$ pwd
???
$ cd
$ pwd
???
$
</code></pre>
<h3 id="cas-particuliers"><a class="header" href="#cas-particuliers">Cas particuliers</a></h3>
<p>Crée le répertoire <strong>canare</strong> et <strong>cd</strong> y toi dedans.</p>
<pre><code class="language-text">~ $ mkdir canare
~ $ cd canare
~/canare $
</code></pre>
<p>Tu te rends compte que tu as fait une faute de frappe.</p>
<p>Renomme le répertoire dans lequel tu te trouves ainsi :</p>
<pre><code class="language-text">~/canare $ mv ../canare ../canard
~/canare $
</code></pre>
<p>Horreur et damnation, ton shell affiche encore <strong>canare</strong>. Il faut que tu
exécutes <strong>cd .</strong> pour que ton shell se mette à jour.</p>
<pre><code class="language-text">~/canare $ cd .
~/canard $
</code></pre>
<p>Maintenant plus drôle. Tu vas créer ce qu'on appelle un <strong>undefined behavior</strong>
ou <strong>comportement indéfini</strong>.</p>
<p>Voici quelques commandes :</p>
<pre><code class="language-text">$ mkdir toto
$ cd toto
$ rmdir ../toto
$ cd .
$ pwd
</code></pre>
<p>Que se passe t-il ? Tout dépend de ton shell, certains feront avec à leur
manière, d'autres afficheront une erreur. C'est un comportement indéfini, le
langage shell n'a pas défini quoi faire dans ce cas, chaque interpréteur a un
comportement différent.</p>
<h2 id="le-système-de-fichier"><a class="header" href="#le-système-de-fichier">Le système de fichier</a></h2>
<p>Tu l'as peut-être vu en exécutant la commande <strong>pwd</strong>, ton chemin commence
<strong>toujours</strong> par un slash '/'.</p>
<p>Ton <strong>HOME</strong> se trouve dans un autre répertoire appelé <strong>home</strong> qui se trouve
lui-même dans un répertoire nommé <strong>/</strong> (slash).</p>
<p>Exécute la commande <strong>ls /</strong> pour voir ce qui se trouve à la racine de ton
système de fichier (filesystem).</p>
<pre><code class="language-text">$ ls /
bin  boot  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
</code></pre>
<p>Tu n'as peut-être pas exactement le même résultat. Ce n'est pas grave. Tu
devrais quand même y voir des similarités.</p>
<p>Pour les utilisateurs Windows, le répertoire racine est <strong>un peu</strong> équivalent au
disque C qui contient tous les répertoires de configuration. C'est faux sur
beaucoup d'aspects techniques que tu n'as pas encore besoin de connaître. Je
veux juste que tu saches qu'il existe un répertoire racine depuis lequel tu peux
te déplacer et lister ce qu'il s'y trouve.</p>
<p>Si jamais tu dois faire des tests temporaires, je te renvoie au répertoire
<strong>/tmp</strong> qui est, dans beaucoup de distributions Linux, remis à zéro à chaque
démarrage. Il peut être configuré pour être remis à zéro tous les jours,
semaines, mois...</p>
<pre><code class="language-text">$ cd /tmp
$ touch je_vais_disparaitre
$ ls
je_vais_disparaitre
$ reboot
...
$ cd /tmp
$ ls
</code></pre>
<h1 id="cache-cache"><a class="header" href="#cache-cache">Cache-cache</a></h1>
<p>Il y a une dernière chose dont je ne t'ai pas parlé. Les fichiers cachés.</p>
<p>Je vais exprès de cacher certains informations pour te forcer à pratiquer.</p>
<p>Exécute ces commandes depuis ton <strong>HOME</strong> :</p>
<pre><code class="language-text">$ mkdir Test
$ cd Test
$ touch .cache affiche
$ ls
???
$
</code></pre>
<p>Où est le fichier <strong>.cache</strong> ? Il est <strong>caché</strong>. Les fichiers et répertoires
dont le nom commencent par un point '.' ne sont pas affichés, car il s'agit en
général de fichier de configuration personnelle pour tes programmes et c'est
plus élégant de ne pas toujours les afficher.</p>
<p>Si tu veux les afficher, exécute :</p>
<pre><code class="language-text">$ ls -a
. .. .cache affiche
</code></pre>
<p>Mais que sont '.' et '..' ? Rappelle toi, le '.' représente le répertoire dans
lequel tu te trouves et '..' représente le répertoire parent.</p>
<p>Si tu veux afficher tout ce qui est caché sauf '.' et '..', exécute :</p>
<pre><code class="language-text">$ ls -A
.cache affiche
</code></pre>
<p>Je te laisse maintenant exécuter cette dernière commande <strong>dans ton HOME</strong>. Tu
verras que même ton explorateur graphique ne t'affiche pas tout par défaut (mais
c'est configurable).</p>
<p><img src="shell/./deplacements/thunar_hidden_files.png" alt="Fichiers cachés dans Thunar" title="Fichiers cachés dans Thunar" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rtfm--read-the-fucking-manual"><a class="header" href="#rtfm--read-the-fucking-manual">RTFM : Read The Fucking Manual</a></h1>
<p>Pour en apprendre d'avantages quant aux commandes que tu ne maitrises pas, il
faut que tu fasses confiance à ton meilleur ami : <del>Google</del> le manuel.</p>
<p>Pour l'invoquer, utilise la commande <strong>man</strong>.</p>
<pre><code class="language-text">$ man ls
</code></pre>
<p>Le manuel s'affiche. Pour t'y déplacer, utilise les touches fléchées. Pour le
quitter, appuie sur <strong>q</strong>.</p>
<p>Chaque commande a son manuel, mais aussi certaines notions de Linux.</p>
<p>Par exemple, si tu veux en apprendre plus sur ton système de fichier, exécute la
commande</p>
<pre><code class="language-text">$ man hier
</code></pre>
<p>hier pour <em>hierarchy</em>.</p>
<p>Et si tu veux apprendre à utiliser le manuel, alors consulte le manuel du
manuel.</p>
<pre><code class="language-text">$ man man
</code></pre>
<p>Chose intéressante dedans, les sections.</p>
<pre><code class="language-text">The table below shows the section numbers of the manual followed by the types of pages they contain.

1   Executable programs or shell commands
2   System calls (functions provided by the kernel)
3   Library calls (functions within program libraries)
4   Special files (usually found in /dev)
5   File formats and conventions, e.g. /etc/passwd
6   Games
7   Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7), man-pages(7)
8   System administration commands (usually only for root)
9   Kernel routines [Non standard]
</code></pre>
<p>Pour ta picine, les 3 premières sections seront à consulter.</p>
<p>La 1ere contient celle des <strong>binaires</strong> (des programmes) que tu utilises depuis
ton shell.</p>
<p>La 2eme et la 3eme contiennet des fonctions que tu peux appeler quand tu fais
du langage C. La 2eme est celle des fonctions que ton Kernel te propose, la 3eme
sont les fonctions de la libc (bibliothèque C).</p>
<p>Un exemple. Si tu veux afficher le manuel de la fonction C printf (tu ne sais
peut-être pas encore ce que c'est, ce n'est pas grave), tu serais tenté
d'exécuter.</p>
<pre><code class="language-text">$ man printf
</code></pre>
<p>Si tu le fais, tu verras en haut à gauche <strong>printf(1)</strong>, le '1' entre
parenthèses signifie que tu es dans la <strong>1</strong>ère section du manuel. Ce que tu
veux c'est la <strong>3</strong>ème, pour les appels de la bibliothèque C (library calls).</p>
<p><img src="shell/./rtfm/printf_wrong.png" alt="mauvais printf" title="mauvais printf" /></p>
<p>Il faut alors utiliser une de ces deux notations :</p>
<pre><code class="language-text">$ man 3 printf
$ man printf.3
</code></pre>
<p><img src="shell/./rtfm/printf_good.png" alt="bon printf" title="bon printf" /></p>
<p>A partir de maintenant, pour toutes les commandes que tu as vues et verras, je
t'invite très fortement à lire le manuel à chaque fois.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lire-et-écrire-dans-des-fichiers"><a class="header" href="#lire-et-écrire-dans-des-fichiers">Lire et écrire dans des fichiers</a></h1>
<p>Tu as vu comment créer des fichiers vides, mais tu n'as pas encore vu comment
écrire dedans et les lire à la ligne de commande.</p>
<h2 id="ecrire-dans-un-fichier"><a class="header" href="#ecrire-dans-un-fichier">Ecrire dans un fichier</a></h2>
<p>Pour écrire dans un fichier, tu peux utiliser l'éditeur de texte <strong>nano</strong> qui se
veut extrêmement simple d'utilisation et surtout s'exécute dans le terminal.</p>
<p>Mettons que tu sois dans ton <strong>HOME</strong>, nous allons faire les tests d'écriture et
lecture dans le répertoire Test.</p>
<pre><code class="language-text">$ mkdir Test
$ cd Test
</code></pre>
<p>Tu peux appeler <strong>nano</strong> sans nom de fichier derrière, tu pourras donner un nom
après.</p>
<pre><code class="language-text">$ nano
  GNU nano 8.1                                                   New Buffer

































                                           [ Welcome to nano.  For basic help, type Ctrl+G. ]
^G Help          ^O Write Out     ^F Where Is      ^K Cut           ^T Execute       ^C Location      M-U Undo         M-A Set Mark
^X Exit          ^R Read File     ^\ Replace       ^U Paste         ^J Justify       ^/ Go To Line    M-E Redo         M-6 Copy
</code></pre>
<p>Tu peux directement écrire ton texte et te déplacer dans le fichier avec les
touches fléchées.</p>
<p>Tu peux voir en bas des commandes notées avec un circonflexe '^'. C'est un alias
pour la touche <strong>ctrl</strong>. Si tu veux sauvegarder ton fichier, appuie sur
<strong>ctrl+o</strong> pour <em>Write Out</em>.</p>
<p>Après cette combinaison, <strong>nano</strong> te demande le nom du fichier avec cette ligne
affichée en bas à gauche :</p>
<pre><code class="language-text">File Name to Write:
</code></pre>
<p>Donne un nom de fichier. Tu peux même mettre un chemin entier pour le
sauvegarder ailleurs. Appelle ton fichier fichier_test.</p>
<p>Si tu veux quitter <strong>nano</strong>, exécute <strong>ctrl+x</strong>. Si tu as modifié ton fichier
entretemps, il te demandera si tu veux sauvegarder avant de quitter.</p>
<p>De retour sur le shell, tu peux rouvrir ton fichier avec nano en lui donnant son
nom en paramètre.</p>
<pre><code class="language-text">$ nano fichier_test
</code></pre>
<h2 id="lire-un-fichier"><a class="header" href="#lire-un-fichier">Lire un fichier</a></h2>
<p>Pour lire un fichier, tu peux utiliser la redirection gauche '&lt;' en mettant le
nom de ton fichier.</p>
<pre><code class="language-text">$ &lt; fichier_test
# Contenu du fichier
$
</code></pre>
<p>Tu peux aussi utiliser la commande <strong>cat</strong></p>
<pre><code class="language-text">$ cat fichier_test
# Contenu du fichier
$
</code></pre>
<p><strong>cat</strong> te sera très utile pour vérifier que tes fichiers respectent une partie
de la norme. La norme en piscine est le style de code (la coding style) à suivre
pour que tes fichiers soient considérés comme valides.</p>
<p>Rouvre ton fichier avec nano et ajoute des espaces à la fin d'une ou plusieurs
lignes de texte. Exécute maintenant</p>
<pre><code class="language-text">$ cat -e fichier_test
# Contenu du fichier avec des '$' en fin de ligne
$
</code></pre>
<p>Comme tu peux le voir, il y a des dollars en fin de ligne. Mais avant certains
dollars, il y a tes espaces. Ce n'est pas bien ! Un fichier de code ne doit pas
avoir d'espace qui donne ensuite sur une fin de ligne. Ce sont des caractères
inutiles présents dans tes fichiers. Ca prend de la place pour rien et c'est
moche, bouh !</p>
<p>Rouvre ton fichier avec nano et supprime ces espaces en trop.</p>
<pre><code class="language-text">$ cat -e fichier_test
Je suis un fichier$
avec     $
des $
espaces              $
en trop$
BERK                           $
$ # Bouh c'est moche
$ nano fichier_test
...
</code></pre>
<pre><code class="language-text">$ cat -e fichier_test
Je suis un fichier$
avec$
des$
espaces$
en trop$
BERK$
$ # Que c'est beau, je suis amoureux 
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="permissions"><a class="header" href="#permissions">Permissions</a></h1>
<h2 id="comprendre-les-permissions"><a class="header" href="#comprendre-les-permissions">Comprendre les permissions</a></h2>
<p>Tu te rappelles du <em>long listing format</em> de <strong>ls</strong> avec toutes ces informations
imbitables ? C'est le moment de les biter.</p>
<p>Reprenons dans répertoire Test vide.</p>
<pre><code class="language-text">$ touch fichier
$ mkdir repertoire
$ cp /bin/ls . # Si tu as une erreur, essaie avec /usr/bin/ls
$ ls -l
total 136
-rw-r--r-- 1 gelules wheel      0 Jul 20 21:29 fichier
-rwxr-xr-x 1 gelules wheel 129728 Jul 20 21:29 ls
drwxr-xr-x 2 gelules wheel   4096 Jul 20 21:29 repertoire
$
</code></pre>
<p>La commande <strong>cp</strong> copie le binaire /bin/ls dans '.', c'est à dire le répertoire
où tu te trouves.</p>
<p>Il est très probable que tu n'aies pas la même sortie. Déjà au niveau des dates
et des heures, mais aussi sur la colonne avec "wheel". Ne t'inquiète pas, tout
va bien.</p>
<p>Décortiquons tout ça.</p>
<p>La première colonne contient les informations sur le type de fichier et les
permissions du fichier. Rappelle toi, '-' signifie que c'est un simple fichier,
et 'd' signifie que c'est un répertoire (<strong>d</strong>irectory).</p>
<p>Ensuite, le reste de la colonne, prenons le fichier <strong>ls</strong> :</p>
<pre><code class="language-text">rwxr-xr-x
</code></pre>
<p>Il faut diviser ces 9 caractères en 3 groupes de 3 caractères.</p>
<div class="table-wrapper"><table><thead><tr><th>User</th><th>Group</th><th>Other</th></tr></thead><tbody>
<tr><td>rwx</td><td>r-x</td><td>r-x</td></tr>
</tbody></table>
</div>
<p>Avant d'expliquer les lettres, je dois expliquer les colonnes du tableau.</p>
<p><strong>User</strong> donne des informations sur l'utilisateur qui possède le fichier. Si on
relit la sortie de <strong>ls -l</strong> plus haut, on peut voir que l'utilisateur qui
possède le fichier est <strong>gelules</strong>.</p>
<p><strong>Group</strong> donne des informations sur le groupe qui possède le fichier. Si on
relit la sortie de <strong>ls -l</strong> plus haut, on peut voir que le groupe qui
possède le fichier est <strong>wheel</strong>.</p>
<p><strong>Other</strong> est le reste du monde qui n'est ni l'utilisateur gelules ni les
utilisateurs dans le groupe wheel.</p>
<p>Tu peux voir dans quel groupe tu es avec la commande <strong>group</strong>.</p>
<pre><code class="language-text">$ group
</code></pre>
<p>Revenons aux lettres.</p>
<p><strong>r</strong> signifie <strong>r</strong>ead, pour lecture.</p>
<p><strong>w</strong> signifie <strong>w</strong>rite, pour écriture.</p>
<p><strong>x</strong> signifie e<strong>x</strong>ecute, pour exécution.</p>
<p>L'utilisateur a le droit de lire, modifier et exécuter le binaire.</p>
<p>Le groupe a le droit de lire et exécuter le binaire.</p>
<p>Tous les autres ont le droit de lire et exécuter le binaire.</p>
<h2 id="changer-les-permissions"><a class="header" href="#changer-les-permissions">Changer les permissions</a></h2>
<p>Pour modifier les permissions, tu peux utiliser la commande <strong>chmod</strong>.</p>
<p>Mais avant ça, il va falloir revoir un peu la base 2.</p>
<div class="table-wrapper"><table><thead><tr><th>r</th><th>w</th><th>x</th></tr></thead><tbody>
<tr><td>1</td><td>0</td><td>1</td></tr>
</tbody></table>
</div>
<p>Tu peux voir ici, je demande à ce que les permissions du fichier donnent le
droit de lecture et d'exécution et interdisent le droit de modification. La
valeur de 101 en base 10 est... 5.</p>
<p>Il faut faire 3 fois cette gymnastique pour avoir 3 chiffres. Le 1er sera le
droit pour l'utilisateur, le 2eme les droits pour le groupe et le 3eme les
droits pour les autres.</p>
<p>Par exemple, je souhaite donner les permissions suivantes au fichier :
l'utilisateur peut lire, modifier et exécuter le fichier, le groupe peut lire et
modifier le fichier et les autres ne peuvent qu'exécuter le fichier.</p>
<div class="table-wrapper"><table><thead><tr><th>r</th><th>w</th><th>x</th><th>r</th><th>w</th><th>x</th><th>r</th><th>w</th><th>x</th></tr></thead><tbody>
<tr><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td></tr>
</tbody></table>
</div>
<p>Il faut traduire par paquet de 3.</p>
<p>On a donc :</p>
<p>111 = 7</p>
<p>110 = 6</p>
<p>001 = 1</p>
<p>Le droit à appliquer sera 761.</p>
<pre><code class="language-text">$ chmod 761 ls
$ ls -l ls
-rwxrw---x 1 gelules wheel 129728 Jul 20 21:29 ls
$
</code></pre>
<p>Comme tu peux le voir, le fichier <strong>ls</strong> a vu ses permissions être modifiées.</p>
<p>Sache qu'un répertoire a des droits d'exécution. Le droit d'exécution d'un
répertoire permet de s'y <strong>cd</strong>.</p>
<p>Faisons un autre exemple.</p>
<pre><code class="language-text">$ chmod 300 repertoire
</code></pre>
<p>Maintenant je n'ai que les droits de mofidication et d'exécution sur le
répertoire <strong>repertoire</strong>.</p>
<pre><code class="language-text">$ nano repertoire/test
...
$ ls repertoire
ls: cannot open directory 'repertoire': Permission denied
$ cat repertoire/test
...
$
</code></pre>
<p>Tu ne peux pas afficher le contenu, mais tu peux quand même t'y déplacer et
modifier son contenu.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tips-and-tricks"><a class="header" href="#tips-and-tricks">Tips and tricks</a></h1>
<p>Tout au long des derniers chapitres, tu t'es écorché les doigts à taper des
commandes et sûrement mal taper le nom d'une commande, ce qui t'a valu de
recommencer.</p>
<p>Qu'à cela ne tienne, tu vas découvrir ici quelques raccourcis claviers.</p>
<h1 id="touches-fléchées"><a class="header" href="#touches-fléchées">Touches fléchées</a></h1>
<p>Déjà, les touches fléchées te permettent de déplacer ton cursus à gauche et à
droite si tu dois modifier ta commande avant de l'exécuter.</p>
<p>Ensuite, les touches fléchées haut et bas te permettent de te déplacer dans ton
historique de commandes et en rappeller plus rapidement qu'en réécrivant une
commande.</p>
<h1 id="autocomplétion"><a class="header" href="#autocomplétion">Autocomplétion</a></h1>
<p>Ton shell est capable d'autocompléter tes commandes. Appuie sur sur la touche de
tabulation pour lui demander d'autocompléter.</p>
<pre><code class="language-text">$ touch travail ventre ventricule
$ ls t&lt;TAB&gt;
</code></pre>
<p>Tu verras que le fichier <strong>travail</strong> va s'autocompléter tout seul.</p>
<pre><code class="language-text">$ ls v&lt;TAB&gt;
     ventr
</code></pre>
<p>Là il va faire face à un problème. Le shell ne peut pas deviner à ta place si tu
veux ventre ou ventricule. En appuyant une deuxième fois sur TAB, il t'affichera
quels fichiers correspondent.</p>
<pre><code class="language-text">$ ls v&lt;TAB&gt;&lt;TAB&gt;
     ventre ventricule
</code></pre>
<p>A toi de régler l'ambiguïté en ajoute <strong>e</strong> ou <strong>i</strong>.</p>
<h1 id="arrêt-dun-programme"><a class="header" href="#arrêt-dun-programme">Arrêt d'un programme</a></h1>
<p>Si jamais tu as lancé un programme ou un script depuis ton terminal et que tu
veux arrêter son exécution, exécute la combinaison de touches <strong>ctrl+c</strong> pour
envoyer un signal d'arrêt et reprendre la main sur ton terminal.</p>
<h1 id="nettoyer-le-terminal"><a class="header" href="#nettoyer-le-terminal">Nettoyer le terminal</a></h1>
<p>Si tu veux nettoyer tout ce qui est affiché sur ton terminal pour repartir sur
une vue propre, exécute la combinaison de touches <strong>ctrl+l</strong>.</p>
<h1 id="recherche-arrière"><a class="header" href="#recherche-arrière">Recherche arrière</a></h1>
<p>Avec <strong>ctrl+r</strong>, tu peux recherche une commande. Par exemple <strong>ctrl+r</strong> <em>cp -</em>
te montrera la dernière commande qui contient <em>cp -r</em>, si tu rappuies sur
<strong>ctrl+r</strong>, la commande précédent s'affichera, jusqu'à afficher la toute
première commande dans ton historique qui contient <em>cp -r</em>.</p>
<h1 id="déplacement-rapide-du-curseur"><a class="header" href="#déplacement-rapide-du-curseur">Déplacement rapide du curseur</a></h1>
<p>Si tu utilises <strong>ctrl+fleche</strong> gauche ou droite, tu peux déplacer le curseur de
mot en mot.</p>
<p>Tu peux aussi faire <strong>alt+f</strong> pour <em>forward</em> (avant) et <strong>alt+b</strong> pour
<em>backward</em> (arrière) pour faire pareil.</p>
<p>Tu peux aussi faire la combinaison <strong>ctrl+a</strong> pour envoyer le cursus au tout
début de la ligne, et <strong>ctrl+e</strong> pour l'envoyer à la fin de la ligne.</p>
<h1 id="suppression-avant--après-le-curseur"><a class="header" href="#suppression-avant--après-le-curseur">Suppression avant / après le curseur</a></h1>
<p>Si ton curseur est au milieu de la commande, et que tu veux supprimer tout ce
qu'il y a à droite, tu peux faire la combinaison <strong>ctrl+k</strong>. Si tu veux
supprimer tout ce qu'il y a à gauche, effectuer la combinaison <strong>ctrl+u</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="editeurs-de-texte"><a class="header" href="#editeurs-de-texte">Editeurs de texte</a></h1>
<p>Tu as utilisé nano pour modifier des fichiers. Maintenant je vais te <em>présenter</em>
2 éditeurs qui te permettront de coder très efficacement.</p>
<p>Il en existe d'autres tout aussi bien, mais je ne les maitrise pas, donc je
préfère te laisser avec ce que je connais.</p>
<p>Si tu en as marre de la console, et que tu veux éditer ton code dans un éditeur
grapghique, tu trouveras ton bonheur dans la prochaine section, vscode.</p>
<p>Si tu veux apprendre à modifier des fichiers toujours dans le terminal, vim sera
ton fidèle allié.</p>
<p>Aux utilisateurs d'Emacs : désolé ! Je ne connais pas bien votre éditeur et
surtout je n'ai pas 6 doigts à chaque main pour ça. Mais je sais que votre
éditeur est super cool.</p>
<p>Aux utilisateurs de Neovim : Oui oui ton éditeur est super moderne. En attendant
ça fait des années que je suis sur Vim et que je suis bien heureux avec, rien ne
me donne envie pour le moment de changer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vscode"><a class="header" href="#vscode">VSCode</a></h1>
<p>Pour installer vscode, installer le paquet code</p>
<pre><code class="language-text">$ sudo apt install code # Ubuntu
$ sudo pacman -S code # Arch et Manjaro
$ sudo dnf install code # Fedora
$ nix-env -i nixos.vscode # NixOS
</code></pre>
<p>Tu peux l'exécuter avec la commande <strong>code</strong>.</p>
<p>La première fenêtre te demander de configurer le thème graphique.</p>
<p>Ensuite quelles extensions tu veux. Je ne vais pas en conseiller.</p>
<p>Maintenant sur la page d'accueil, tu peux ouvrir un fichier ou un répertoire qui
contient des fichiers.</p>
<p>Tu peux également appeler vscode avec des fichiers en paramètres.</p>
<pre><code class="language-text">code fichier_1 fichier_2
</code></pre>
<p>Il se peut qu'il te dise que les fichiers ne sont pas "trustés". C'est parce que
tu n'as pas crée de projet vscode. Tu peux dire "Oui" sans problème.</p>
<p>C'est tout ce que je vais présenter de vscode, je ne l'utilise pas plus que ça.
Mais je voulais quand même ajouter un éditeur graphique si tu es vraiment
allergique à la ligne de commande.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vim"><a class="header" href="#vim">Vim</a></h1>
<p>Alors là trop facile, j'ai fais plusieurs vidéos pour apprendre à l'utiliser.</p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/7kntHy8V7d0" title="Les bases de Vim (pour les nouveaux)" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/CmGx8IrDdiw" title="Maîtriser Vim en 2024" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<p>Tu trouveras <a href="https://www.youtube.com/playlist?list=PLb5GOuL68SxEt5GQcA_3uuQIzG26n8l_i">la playlist complète ici</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="run-command"><a class="header" href="#run-command">Run Command</a></h1>
<p>Tu ne le sais peut-être pas, ton shell est configuré par un fichier <strong>Run
Command</strong>. C'est un fichier caché dans ton <strong>HOME</strong>.</p>
<p>Si tu es sur bash, ton fichier de configuration est</p>
<pre><code class="language-text">$ ~/.bashrc
</code></pre>
<p>Si tu es sur zsh, ton fichier de configuration est</p>
<pre><code class="language-text">$ ~/.zshrc
</code></pre>
<p>Si tu es sur un autre shell... regarde le man de ton shell pour savoir où se
trouve ton fichier de configuration.</p>
<h2 id="mkcd"><a class="header" href="#mkcd">mkcd</a></h2>
<p>On va agrémenter ton fichier de configuration avec une petite fonction bien
sympathique que j'aime bien.</p>
<p>Ouvre ton fichier de configuration et ajoute à la fin ces lignes :</p>
<pre><code class="language-sh">mkcd ()
{
    [ ! -d "$1" ] &amp;&amp; mkdir -p $1
    cd $1
}
</code></pre>
<p>Pour mettre à jour la configuration du shell où tu te trouves, exécute</p>
<pre><code class="language-text">$ . ~/.zshrc
</code></pre>
<p>Accorde la commande avec ton fichier de configuration.</p>
<p>La commande '.' exécute le fichier que tu donnes. Ton shell va donc exécuter son
fichier de Run Command pour se mettre à jour.</p>
<p>Tu peux aussi utiliser la commande <strong>source</strong>, c'est la même chose.</p>
<p>Pour les prochains shells, tu n'auras pas à faire cette commande. Ca sera
appliqué automatiquement.</p>
<p>Mais que fais cette commande ?</p>
<p>Décortiquons tout ça.</p>
<pre><code class="language-sh">mkcd ()
{

}
</code></pre>
<p>Ca, c'est une <strong>fonction</strong> en shell. Une fonction c'est du code que tu pourras
appeler depuis ton shell.</p>
<pre><code class="language-sh">[ ! -d "$1" ] &amp;&amp; mkdir -p $1
</code></pre>
<p>Cette ligne est compliquée à lire. Mais tu dois reconnaître la commande <strong>mkdir
-p</strong>.</p>
<pre><code class="language-sh">[ ! -d "$1" ]
</code></pre>
<p>Ce morceau de code va vérifier si le <strong>1</strong>er argument n'existe pas comme
répertoire.</p>
<pre><code class="language-sh">&amp;&amp; mkdir -p $1
</code></pre>
<p><strong>&amp;&amp;</strong> est une porte logique. Dans le contexte du shell, il s'agit de la porte
<strong>AND</strong> et exécutera la partie à droite seulement si la partie de gauche renvoie
Vrai.</p>
<p>La partie de droite créee une arborescence de répertoires.</p>
<pre><code class="language-sh">cd $1
</code></pre>
<p>cd va te déplacer dans le répertoire envoyé en <strong>1</strong>er argument.</p>
<p>La fonction mkcd va donc créer un répertoire ou même toute une arborescence de
répertoire et t'y <strong>cd</strong> automatiquement.</p>
<pre><code class="language-text">$ pwd
/home/gelules
$ ls /tmp/tests
ls: cannot access '/tmp/tests': No such file or directory
$ mkcd /tmp/tests/pediluve/shell
$ pwd
/tmp/tests/pediluve/shell
$
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="window-manager"><a class="header" href="#window-manager">Window Manager</a></h1>
<p>Un Window Manager est l'environnement graphique de ta session. Selon ta
distribution, tu vas probablement utiliser Gnome, Plasma, XFCE, etc..</p>
<p>J'utilise Awesome comme window manager, la prochaine section te montrera comment
je l'utilise.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="awesome"><a class="header" href="#awesome">Awesome</a></h1>
<p>Hop là c'est facile, il y a une vidéo !</p>
<iframe width="1280" height="720" src="https://www.youtube.com/embed/L0m97UcA16A" title="2.7 - Comment être AWESOME - Shell" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
<div style="break-before: page; page-break-before: always;"></div><h1 id="programmation-shell"><a class="header" href="#programmation-shell">Programmation Shell</a></h1>
<p>Tu y es ! Le début de ta grande aventure dans la programmation !</p>
<p>Ne t'inquiète pas, je reste dans les prochains chapitres le plus clair et simple
possible, avec des exemples pour appréhender simplement chaque notion.</p>
<p>Tu verras pendant ta piscine et le reste de ton cursus que ce que je présente va
beaucoup plus loin en terme de complexité, mais le but du Pédiluve reste de
t'aider à appréhender une piscine, pas de devenir une brute en informatique.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flux-systèmes"><a class="header" href="#flux-systèmes">Flux systèmes</a></h1>
<h2 id="sortie-standard"><a class="header" href="#sortie-standard">Sortie standard</a></h2>
<p>La sortie standard (ou <strong>stdout</strong>) est le flux de texte affiché sur ton terminal
quand tout se passe bien.</p>
<p>Par exemple, quand tu exécutes</p>
<pre><code class="language-text">$ ls -l fichier_existant # assure toi que le fichier existe
</code></pre>
<p>Tout ce qui est affiché passe par <strong>stdout</strong>.</p>
<p>Tu peux rediriger le flux dans un fichier en utilisant un chevron.</p>
<pre><code class="language-text">$ ls -l &gt; fichier_stdout
$ cat fichier_stdout
</code></pre>
<p>Comme tu peux le voir, <strong>ls -l</strong> n'a pas affiché de résultat, tout a été
redirigé dans un fichier qui n'existait pas.</p>
<p>Recommence l'opération.</p>
<pre><code class="language-text">$ ls -l &gt; fichier_stdout
$ cat fichier_stdout
</code></pre>
<p>Le fichier n'a pas gardé l'information précédente. Il a été <em>tronqué</em>.</p>
<p>Si tu veux garder le contenu du fichier à chaque redirection, tu peux utiliser
la <strong>double redirection</strong>.</p>
<pre><code class="language-text">$ ls -l &gt;&gt; fichier_stdout
$ cat fichier_stdout
</code></pre>
<p>Et là, le contenu déjà présent reste dans le fichier.</p>
<p>Si tu veux rediriger stdout dans le <strong>vide</strong>, c'est à dire ne pas l'afficher et
ne pas le rediriger dans un fichier, tu peux utiliser le fichier <strong>/dev/null</strong>
comme fichier de redirection.</p>
<pre><code class="language-text">$ ls -l &gt; /dev/null
</code></pre>
<p>C'est un fichier spécial utilisé uniquement pour rediriger des flux dans le
vide.</p>
<h2 id="erreur-standard"><a class="header" href="#erreur-standard">Erreur standard</a></h2>
<p>Le flux standard des erreurs (ou <strong>stderr</strong>) s'affiche aussi sur ton terminal
mais en empruntant un autre flux. Il ne s'affiche qu'en cas d'erreur.</p>
<p>Prenons la situtation suivante :</p>
<pre><code class="language-text">$ ls
fichier_existant
$ ls -l fichier_existant fichier_inexistant
ls: cannot access 'fichier_inexistant': No such file or directory
-rw-r--r-- 1 gelules wheel 0 Jul 20 21:29 fichier_existant
$
</code></pre>
<p>La première ligne avec le message d'erreur emprunte le flux d'erreur, et la
seconde emprunte stdout.</p>
<p>Tu peux les séparer dans des fichiers différents ainsi :</p>
<pre><code class="language-text">$ ls -l fichier_existant fichier_inexistant &gt;stdout.txt 2&gt;stderr.txt
$ cat stdout.txt stderr.txt
...
</code></pre>
<p>Le <strong>2</strong> est le chiffre de référence pour <strong>stderr</strong>. <strong>stdout</strong> utilise <strong>1</strong>
mais tu n'es pas obligé de l'écrire, sauf à une condition.</p>
<p>Si tu veux rediriger <strong>stderr</strong> vers <strong>stdout</strong>, tu dois le faire de cette
façon.</p>
<pre><code class="language-text">$ ls -l fichier_existant fichier_inexistant 1&gt;stdout.txt 2&gt;&amp;1
</code></pre>
<p>Le caractère <strong>esperluette</strong> '&amp;' indique au shell que <strong>1</strong> n'est pas un nom de
fichier mais le flux numéro 1.</p>
<p>Le premier <strong>1</strong> devant <strong>stdout.txt</strong> n'est pas obligatoire, mais je voulais te
montrer que tu peux l'écrire quand même.</p>
<h2 id="pipe"><a class="header" href="#pipe">Pipe</a></h2>
<p>Les pipes servent à rediriger le <strong>stdout</strong> d'un programme dans le <strong>stdin</strong>
d'un autre programme.</p>
<p><strong>stdin</strong> est <strong>l'entrée standard</strong>. C'est un flux où tu fais en temps normal de
l'entrée clavier. Ce que fais ton shell à chaque fois que tu appuies sur Entrée,
il lit son entrée standard pour recevoir ta commande.</p>
<p>Faisons quelques exemples plus parlant :</p>
<pre><code class="language-text">$ ls
$ ls -l / &gt; racine.txt
$ wc -l racine.txt
</code></pre>
<p><strong>wc -l</strong> te permet de compter le nombre de lignes dans un fichier. Mais tu
aurais pu faire ça en une seule commande grâce au <strong>pipe</strong> (tuyau).</p>
<pre><code class="language-text">$ ls -l / | wc -l
</code></pre>
<p>Le pipe '|' te permet de passer la sortie de <strong>ls</strong> dans l'entrée de <strong>wc</strong>.</p>
<p>Beaucoup d'outils sur Linux fonctionne ainsi.</p>
<p>Prenons un enchaînement de commandes plus drôle :</p>
<pre><code class="language-text">$ ls -l / | cut -d ' ' -f 1 | tee permissions | wc -l
</code></pre>
<p>Voici deux nouvelles commandes.</p>
<p><strong>cut</strong> va couper des colonnes selon un délimiteur.</p>
<p>Prenons la sortie de <strong>ls -l /</strong>.</p>
<pre><code class="language-text">$ ls -l /
total 56
lrwxrwxrwx   1 root root       7 Apr  7 20:02 bin -&gt; usr/bin
drwxr-xr-x   4 root root    4096 Jul 19 01:59 boot
drwxr-xr-x  19 root root    3880 Jul 20 16:52 dev
drwxr-xr-x  95 root root    4096 Jul 20 22:14 etc
drwxr-xr-x   3 root root    4096 Sep 13  2022 home
lrwxrwxrwx   1 root root       7 Apr  7 20:02 lib -&gt; usr/lib
lrwxrwxrwx   1 root root       7 Apr  7 20:02 lib64 -&gt; usr/lib
drwx------   2 root root   16384 Sep 13  2022 lost+found
drwxrwx---   1 root vboxsf  4096 Jul  1 02:05 media
drwxr-xr-x   2 root root    4096 Dec  7  2021 mnt
drwxr-xr-x   2 root root    4096 Dec  7  2021 opt
dr-xr-xr-x 227 root root       0 Jul 20 16:52 proc
drwxr-x---  14 root root    4096 Sep 23  2023 root
drwxr-xr-x  29 root root     680 Jul 20 16:55 run
lrwxrwxrwx   1 root root       7 Apr  7 20:02 sbin -&gt; usr/bin
drwxr-xr-x   4 root root    4096 Sep 13  2022 srv
dr-xr-xr-x  13 root root       0 Jul 20 21:28 sys
drwxrwxrwt  15 root root     360 Jul 21 00:00 tmp
drwxr-xr-x  10 root root    4096 Jul 20 22:14 usr
drwxr-xr-x  12 root root    4096 Jul 20 16:52 var
</code></pre>
<p>La commande <strong>cut</strong> que j'utilise délimite chaque <strong>field</strong> (champ) en utilisant
le délimiteur ESPACE ' '.</p>
<p>On n'aura donc que la première colonne avec <strong>cut</strong>.
On n'aura donc que la première colonne avec <strong>cut -d ' ' -f 1</strong></p>
<pre><code class="language-text">$ ls -l / | cut -d ' ' -f1
total
lrwxrwxrwx
drwxr-xr-x
drwxr-xr-x
drwxr-xr-x
drwxr-xr-x
lrwxrwxrwx
lrwxrwxrwx
drwx------
drwxrwx---
drwxr-xr-x
drwxr-xr-x
dr-xr-xr-x
drwxr-x---
drwxr-xr-x
lrwxrwxrwx
drwxr-xr-x
dr-xr-xr-x
drwxrwxrwt
drwxr-xr-x
drwxr-xr-x
</code></pre>
<p>Ensuite la commande <strong>tee</strong> va rediriger sa sortie dans deux flux, un fichier et
<strong>stdout</strong>.
Imagine la lettre 'T' (tee en pronociation Anglaise), la barre de gauche est son
entrée standard, la barre qui descend est le fichier, la barre de droite est
<strong>stdout</strong>.</p>
<pre><code class="language-text">$ ls -l / | cut -d ' ' -f1 | tee permissions
total
lrwxrwxrwx
drwxr-xr-x
drwxr-xr-x
drwxr-xr-x
drwxr-xr-x
lrwxrwxrwx
lrwxrwxrwx
drwx------
drwxrwx---
drwxr-xr-x
drwxr-xr-x
dr-xr-xr-x
drwxr-x---
drwxr-xr-x
lrwxrwxrwx
drwxr-xr-x
dr-xr-xr-x
drwxrwxrwt
drwxr-xr-x
drwxr-xr-x
$ cat permissions
...
</code></pre>
<p>tee a bel et bien redirigé ce que tu vois sur <strong>stdout</strong> dans un fichier nommé
<strong>permissions</strong>.</p>
<p>Et enfin, <strong>wc -l</strong> affiche le nombre de ligne reçu depuis <strong>stdout</strong>.</p>
<p>Voilà la puissance de Linux. Utiliser la sortie d'un programme comme donnée pour
l'entrée d'un autre programme.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="job-control"><a class="header" href="#job-control">Job control</a></h1>
<p>Le job control te permet de mettre en pause et remettre en route les programmes
que tu lances depuis ton shell.</p>
<p>Dans cet exemple, il faut que je seul programme lancé soit ton shell, rien
d'autre.</p>
<pre><code class="language-text">firefox
...
</code></pre>
<p>Maintenant que firefox est lancé, tu n'as plus la main sur ton shell. Firefox
l'utilise pour afficher son stdout et stderr.</p>
<p>Exécute la combinaison <strong>ctrl+z</strong> pour mettre Firefox en pause et regagner la
main sur ton shell.</p>
<pre><code class="language-text">...
ctrl+z
zsh: suspended  firefox
$
</code></pre>
<p>Selon le shell que tu utilises, tu peux avoir un message sensiblement différent.</p>
<p>Tu vas maintenant démarrer vlc  et gimp et pareil, exécuter <strong>ctrl+z</strong> pour
reprendre la main à chaque fois.</p>
<pre><code class="language-text">$ vlc
...
ctrl+z
zsh: suspended  vlc
$ gimp
...
ctrl+z
zsh: suspended gimp
$
</code></pre>
<p>Exécute la commande <strong>jobs</strong> pour voir l'état des jobs (processus) démarrés par
ton shell.</p>
<pre><code class="language-text">$ jobs
[1]    suspended  firefox
[2]  - suspended  vlc
[3]  + suspended  gimp
$
</code></pre>
<p>Tu as ta liste de jobs avec des identifiants. Le signe '-' est l'avant-dernier
jobs que tu as suspendu, et le signe '+' et le dernier jobs que tu as suspendu.</p>
<p>Si tu veux remettre un job en <strong>foreground</strong>, c'est à dire que tu relances son
exécution en lui laisant la main sur ton shell, utilise <strong>fg %IDENTIFIANT</strong> en
remplaçant <strong>IDENTIFIANT</strong> par le numéro du job.</p>
<pre><code class="language-text">$ fg %1 # firefox est réexécuté et on perd la main sur le shell
...
ctrl+z
</code></pre>
<p>Si tu veux mettre un job en <strong>background</strong>, c'est à dire que tu relances son
exécution tout en gardant la main sur ton shell, utilise <strong>bg %IDENTIFIANT</strong> en
remplaçant <strong>IDENTIFIANT</strong> par le numéro du job.</p>
<pre><code class="language-text">$ fg %1
$ # firefox reprend son exécution et on garde la main sur le shell
</code></pre>
<p>Pour arrêter un job, utilise la commande <strong>kill %IDENTIFIANT</strong> en remplaçant
<strong>IDENTIFIANT</strong> par le numéro du job.</p>
<pre><code class="language-text">kill %1
[1]  + terminated  firefox
$
</code></pre>
<p>Enfin, si tu veux lancer un processus en arrière-plan directement depuis ton
shell, ajoute le caractère <strong>esperluette</strong> '&amp;' à la fin de ta commande.</p>
<pre><code class="language-text">$ vlc  &amp;
[1] 22258
$
</code></pre>
<p>Le nombre affiché est le numéro du processus dans le système, il est plus que
probable que tu n'aies pas le même. Tu peux retrouver le nom d'un processus avec
son identidiant et la commande <strong>ps</strong>.</p>
<pre><code class="language-text">$ ps -p 22258
    PID TTY          TIME CMD
  22258 pts/0    00:00:00 vlc
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="scripts"><a class="header" href="#scripts">Scripts</a></h1>
<p>Voici un gros chapitre, l'introduction aux scripts shell !</p>
<p>On va voir ici comment créer un fichier script, comment l'exécuter et afficher
les paramètres qu'on lui donne. Les prochaines chapitres étofferont petit à
petit ce que tu peux faire par le script.</p>
<p>En définition, un script shell, c'est juste un fichier avec des commandes
shells. En exécutant le fichier, tu exécuteras les commandes dedans.</p>
<p>En réalité, quand tu exécutes ton shell au clavier, il ne fait pas de différence
avec un fichier script. Il est juste en attente de la prochaine ligne à lire et
attend la fin de fichier (que tu peux envoyer avec la combinaison <strong>ctrl+d</strong>, ce
qui fermera ton shell).</p>
<p>Ce qui fait que tout ce que tu vas voir à partir d'ici est possible à exécuter
dans ton terminal.</p>
<p>Voici le minimum d'un script shell :</p>
<pre><code class="language-sh">#!/bin/sh
</code></pre>
<p>C'est un commentaire particulier qui indique quel interpréteur utiliser. Par
habtiude on utilise <strong>/bin/sh</strong> car c'est un interpréteur présent sur tous les
systèmes Linux. Plus rarement tu verras <strong>/bin/bash</strong> car ce dernier a des
extensions que n'a pas <strong>sh</strong>. Evite de mettre <strong>zsh</strong> à moins de réellement
utiliser une fonctionnalité qui n'est pas présente sur <strong>sh</strong>, car tous les
systèmes n'ont pas <strong>zsh</strong> installés.</p>
<p>Pour rendre exécutable ton script, tu peux calculer les valeurs qui vont bien
avec <strong>chmod</strong>, ou aller plus vite en exécutant cette commande :</p>
<pre><code class="language-text">$ chmod +x script.sh
</code></pre>
<p>Et maintenant pour l'exécuter :</p>
<pre><code class="language-text">$ ./script.sh
</code></pre>
<p>Voilà. Ton script ne fait pas encore grand chose.</p>
<p>Pour information, je vais écrire un énorme script, mais ne t'inquiète pas, il
est <strong>commenté</strong> pour que tu comprennes ce que fait le script. Je donnerai
ensuite des exemples d'exécution pour que tu voies les différences.</p>
<p>Avant de montrer le script, je dois te présenter une nouvelle commande :
<strong>echo</strong>. Elle affiche ce que tu lui donnes en paramètre sur <strong>stdout</strong>.</p>
<pre><code class="language-text">$ echo Coucou les amis !
Coucou les amis !
$
</code></pre>
<p>Ce ne te semble pas utile pour le moment, mais ça va vite changer.</p>
<pre><code class="language-sh">#!/bin/sh

# Afficher la façon dont on exécute le script
echo $0

# Afficher le nombre d'argument
echo $#

# Afficher le 1er argument
echo $1

# Afficher le 2eme argument
echo $2

# Afficher le 9eme argument
echo $9

# Afficher le 10ème argument
echo ${10}

# Afficher la liste des arguments avec *
echo $*

# Afficher la liste des arguments avec @
echo $@
</code></pre>
<p>Ce que tu vois ici sont des variables spéciales. Elles sont en lien avec le
script et auront des valeurs différentes selon comment tu exécutes le script.</p>
<p>Exécute le script avec ces paramètres et regarde ce qu'il se passe.</p>
<pre><code class="language-text">$ ./script.sh
...
$ ./script.sh toto
...
$ ./script.sh toto tata titi tutu
...
$ ./script.sh toto 'tata titi' tutu
...
$ ./script.sh toto "tata titi" tutu
...
$ ./script.sh je vais toucher le 10eme argument juste pour voir qu il s affiche bien
...
$
</code></pre>
<p>Tu comprendras la différence entre les deux dernières variables plus tard.</p>
<h2 id="exit-status"><a class="header" href="#exit-status">Exit status</a></h2>
<p>Tu peux appeler n'importe quel programme dans ton script, comme dans ton
terminal.</p>
<pre><code class="language-sh">#!/bin/sh

ls $1
mkdir ventre
touch ventre/gateau
ls -l ventre
</code></pre>
<p>Tu te rappelles des flux standards de sortie et d'erreur ? En plus de ça, il y a
un autre moyen de voir si un script s'est bien exécuté ou non. En utilisant la
variable <strong>exit status</strong>. C'est une variable spéciale qui recevra le code de
sortie d'un programme.</p>
<p>Habituellement, on dit en informatique que 0 est Faux et que 1 est Vrai. En
shell c'est l'inverse. 0 est Vrai et ce qui n'est pas 0 est Faux. Un programme
peut renvoyer 256 codes d'erreurs différents, allant de 0 à 255.</p>
<p>Donc, on peut dire que Vrai est compris dans l'intervalle [0] et que Faux est
compris dans l'intervalle [1;255].</p>
<p>Pour voir le code de retour d'un programme, utilise la variable <strong>$?</strong>. Elle
aussi le code de retour de la dernière commande exécutée.</p>
<pre><code class="language-sh">#!/bin/sh

touch fichier_existant
ls fichier_existant
echo exit_status: $?

ls fichier_nonexistant
echo exit_status: $?
</code></pre>
<pre><code class="language-text">$ ./script.sh
fichier_existant
exit_status: 0
ls: cannot access 'fichier_nonexistant': No such file or directory
exit_status: 2
</code></pre>
<p>Tu peux voir que <strong>ls</strong> retourne <strong>2</strong> quand il ne trouve pas un fichier.</p>
<p>Je t'invite à lire le <strong>man 1 ls</strong> dans la section <strong>Exit status</strong>, tout est
documenté dedans.</p>
<p>Je t'invite à faire ça pour chaque programme que tu connais.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Les variables sont des <em>mots</em> qui vont avoir une <em>valeur</em>.</p>
<p>Tu peux définir une variable ainsi :</p>
<pre><code class="language-sh">#!/bin/sh

variable=valeur
</code></pre>
<p>Attention, il faut <strong>absolument</strong> que le signe égal '=' n'ait pas d'espace
autour de lui. Tout doit être collé.</p>
<p>Pour utiliser sa valeur, tu vas coller le signe dollar '$' devant le nom de
cette variable.</p>
<p>Pour afficher une variable, tu peux utiliser <strong>echo</strong>.</p>
<pre><code class="language-sh">#!/bin/sh

variable=valeur
nombre=42
echo Ma variable variable a comme valeur $variable
echo Mon nombre est $nombre
</code></pre>
<p>Si tu veux concaténer deux variables ensembles, tu peux utiliser les accolades
pour bien les séparer. Tu peux même en construire de nouvelles comme ça.</p>
<pre><code class="language-sh">#!/bin/sh

prenom=gel
nom_famille=ules
login=${prenom}${nom_famille}
domain=pediluve.info
mail=${login}@${domain}

echo Mon mail est $mail # L'adresse n'existe pas, pas la peine d'essayer
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathématiques"><a class="header" href="#mathématiques">Mathématiques</a></h1>
<p>C'est parti pour faire un peu de mathématique.</p>
<p>Maintenant que tu sais utiliser des variables, tu vas pouvoir effectuer des
opérations mathématiques avec.</p>
<p>Tu peux faire toute opération mathématique dans des doubles parenthèses
précédées d'un signe dollar '$'.</p>
<pre><code class="language-sh">#!/bin/sh

echo $((11 + 21))

a=42
b=666

echo $((a * b))

c=$((a + b * 11))
echo $c
</code></pre>
<p>Si tu mets une variale qui n'est pas un nombre, elle sera remplacée par 0.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables-denvironnement"><a class="header" href="#variables-denvironnement">Variables d'environnement</a></h1>
<p>Les variables d'environnement sont des variables initialisées au lancement de
ton shell.</p>
<p>Tu peux les avoir avec cette commande :</p>
<pre><code class="language-text">$ env
</code></pre>
<p>Voici les variables que tu utiliseras le plus :</p>
<p>Tu peux connaitre le shell exécuté avec la variable <strong>$SHELL</strong></p>
<pre><code class="language-sh">$ echo $SHELL
</code></pre>
<p>Tu peux connaitre le nom d'utilisateur avec la variable $USER</p>
<pre><code class="language-sh">$ echo $USER
</code></pre>
<p>Tu peux connaitre le chemin vers le <strong>HOME</strong> de l'utilisateur avec la variable
<strong>HOME</strong></p>
<pre><code class="language-sh">$ echo $HOME
</code></pre>
<p>Tu peux connaitre le répertoire courant avec la variable <strong>$PWD</strong> et le
répertoire courant précédent avec la variable <strong>$OLDPWD</strong></p>
<pre><code class="language-sh">echo $PWD
...
echo $OLDPWD
...
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="path"><a class="header" href="#path">PATH</a></h1>
<p>La variable d'environnement <strong>PATH</strong> est une variable particulière. C'est la
variable qui permet à ton shell de trouver les programmes à exécuter.</p>
<p>Si je prends en exemple mon <strong>PATH</strong></p>
<pre><code class="language-sh">$ echo $PATH
/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/home/gelules/.local/bin/:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl:/home/gelules/.local/bin
</code></pre>
<p>Je peux voir que le 1er répertoire vérifié est <strong>/usr/local/bin</strong>, puis
<strong>/usr/bin</strong>, et ainsi de suite.</p>
<p>On va faire un petit jeu.</p>
<p>Crée le répertoire <strong>/tmp/test/</strong> et <strong>cd</strong> dedans.</p>
<pre><code class="language-text">$ mkdir /tmp/test
$ cd /tmp/test
</code></pre>
<p>Crée le fichier avec ton éditeur et ajoute la ligne suivante dedans :</p>
<pre><code class="language-text">$ cat firefox
#!/bin/sh

echo Et non, je ne suis pas Firefox
$
</code></pre>
<p>Rends le exécutable.</p>
<pre><code class="language-text">$ chmod +x firefox
</code></pre>
<p>On va mettre la variable d'environnement PATH à jour. Elle ne le sera que pour
ton shell actuel, les futurs shells ne seront pas impactés.</p>
<pre><code class="language-sh">$ PATH=/tmp/test:$PATH
$ firefox
Et non, je ne suis pas Firefox
$
</code></pre>
<p>Tu peux voir que ton shell trouve d'abord le fichier <strong>firefox</strong> que tu viens de
créer.</p>
<p>Tu peux voir quel programme ton shell trouvera avec la commande <strong>which</strong>.</p>
<pre><code class="language-text">$ which firefox
/tmp/test/firefox
$
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quotting"><a class="header" href="#quotting">Quotting</a></h1>
<p>Le quotting est la façon de formater du texte. Tu te rappelles de la commande
<strong>echo</strong> qui affiche du texte sur <strong>stdout</strong> mais qui peut aussi afficher des
variables.</p>
<h2 id="simple-quote"><a class="header" href="#simple-quote">Simple quote</a></h2>
<p>La simple quote te permet d'afficher du texte sans qu'il ne soit évalué. Ca
veut dire que tu peux afficher le nom d'une variable sans qu'elle soit remplacée
par sa valeur.</p>
<pre><code class="language-sh">$ cat script.sh
#!/bin/sh

nom=gelules
echo 'Mon nom est $nom'
$ ./script.sh
Mon nom est $nom
$
</code></pre>
<p>Comme tu peux le voir, mettre du texte entre simple quote affiche le texte tel
qu'écrit dans le script, sans être évalué par le shell.</p>
<h2 id="double-quote"><a class="header" href="#double-quote">Double quote</a></h2>
<p>Le double quote te permet de visuellement savoir où commence et où termine ton
texte, le shell qui sera dedans sera évalué. Avec <strong>echo</strong>, c'est comme ne pas
mettre de quotes, mais tu te repères plus facilement à la lecture de ton script.</p>
<pre><code class="language-sh">$ cat script.sh
#!/bin/sh

nom=gelules
echo "Mon nom est $nom"
$ ./script.sh
Mon nom est gelules
$
</code></pre>
<h2 id="escape"><a class="header" href="#escape">Escape</a></h2>
<p>Une question t'a peut-être traversé l'esprit : Comment afficher une simple quote
ou une double quote sans qu'elle ne soit comprise comme un début ou fin de texte
? Ou même afficher le signe dollar '$' sans utiliser de simple quote ?</p>
<p>Tu peux <strong>échapper</strong> un caractère spécial avec l'antislash.</p>
<pre><code class="language-sh">$ cat script.sh
#!/bin/sh

echo Voici un dollar : \$
echo Voici un simple quote : \'
echo Voici un double quote : \"
echo Voici un antislash: \\
$ ./script.sh
Voici un dollar : $
Voici un simple quote : '
Voici un double quote : "
Voici un antislash: \
$
</code></pre>
<p>Entre simple quote, tu peux afficher sans problème un double quote. Pareil
inversement, tu peux entre double quote afficher un simple quote.</p>
<pre><code class="language-sh">$ cat script.sh
#!/bin/sh

echo "Voici un double quote entre double quote =&gt; \" &lt;= pas mal hein ?"
echo 'Voici un double quote entre simple quote =&gt; " &lt;= pas mal hein ?'
echo "Voici un simple quote entre double quote =&gt; ' &lt;= pas mal hein ?"
</code></pre>
<pre><code class="language-text">$ ./script.sh
Voici un double quote entre double quote =&gt; " &lt;= pas mal hein ?
Voici un double quote entre simple quote =&gt; " &lt;= pas mal hein ?
Voici un simple quote entre double quote =&gt; ' &lt;= pas mal hein ?
$
</code></pre>
<p>Tu ne peux en revanche rien échapper entre simple quote. Donc pas de simple
quote entre simple quote. Mais tu peux arrêter ton simple quote en plein milieu
de ton appel à <strong>echo</strong>, échapper la simple quote et reprendre en simple quote
juste après.</p>
<pre><code class="language-sh">$ cat script.sh
#!/bin/sh

echo 'Je fais presque tout en simple quote, en voici une =&gt;' \' '&lt;= pas mal hein ?'
</code></pre>
<pre><code class="language-text">$ ./script.sh
Je fais presque tout en simple quote, en voici une =&gt; ' &lt;= pas mal hein ?
$
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests-et-conditions"><a class="header" href="#tests-et-conditions">Tests et conditions</a></h1>
<p>Tu sais récupérer les variables envoyées en paramètres à ton script, tu sais en
créer, tu sais faire un peu de maths et afficher toutes ces variables. C'est
bien. Mais que dirais-tu de rendre tes scripts un peu plus vivants ? D'avoir des
exécutions différentes selon ce que tu envoies en paramètres ? C'est déjà plus
intéressant.</p>
<h2 id="conditions"><a class="header" href="#conditions">Conditions</a></h2>
<p>Une condition en shell est un test qui va renvoyer Vrai ou Faux. Si c'est Vrai,
alors le script va emprunter un chemin d'exécution, si c'est Faux, alors le
script va emprunter un autre chemin d'exécution.</p>
<h1 id="test"><a class="header" href="#test">Test</a></h1>
<p>Tu peux tester plusieurs choses en shell : les nombres, les chaînes de
caractères, l'existence de fichier, les exécutions d'autres programmes.</p>
<p>Je t'invite à lire le <strong>man 1 test</strong> qui liste tous les tests possibles.</p>
<p>Comme tu peux le vois, on peut combiner les tests avec les portes logiques
<strong>AND</strong> et <strong>OR</strong>.</p>
<p>Par exemple pour tester une chaîne de caractères, tu utilises le test</p>
<pre><code class="language-sh">[ chaine1 = chaine2 ]
</code></pre>
<p>Ce test renverra Faux.</p>
<p>Attention à bien laisser des ESPACES ' ' entre le signe '$' et à côté des
crochets '[' et ']'. Si tu ne laisses pas d'espaces, le shell ne comprendra pas
que c'est un test et boguera.</p>
<h3 id="protection"><a class="header" href="#protection">Protection</a></h3>
<p>Avant de montrer des exemples, je dois te montrer une technique de protection
des scripts pour éviter des crashs embêtants.</p>
<pre><code class="language-sh">#!/bin/sh

mot_de_passe=$1

if [ $mot_de_passe = "pediluve" ]
then
    echo "Ouverture de la porte secrète"
else
    echo "Mauvais mot de passe"
fi
</code></pre>
<p>Exécute ce script sans lui envoyer de paramètre.</p>
<pre><code class="language-text">$ ./script.sh
./script.sh: line 5: [: =: unary operator expected
Mauvais mot de passe
$
</code></pre>
<p>Que s'est-il passé ?</p>
<p>La variable n'a pas de valeur, le shell a donc lu la ligne avec le test
littéralement de cette manière :</p>
<pre><code class="language-sh">if [ = "pediluve" ]
</code></pre>
<p>Ceci n'est pas du shell valide. Il faut une valeur avant le signe '='.</p>
<p>Tu peux protéger ta variable en lui mettant des double quotes.</p>
<pre><code class="language-sh">#!/bin/sh

mot_de_passe=$1

if [ "$mot_de_passe" = "pediluve" ]
then
    echo "Ouverture de la porte secrète"
else
    echo "Mauvais mot de passe"
fi
</code></pre>
<p>Si tu exécutes le script sans paramètre, voici ce que le shell lit.</p>
<pre><code class="language-sh">if [ "" = "pediluve" ]
</code></pre>
<p>Le shell comprend alors qu'il teste une chaîne de caractères vide avec
"pediluve".</p>
<h2 id="exemples"><a class="header" href="#exemples">Exemples</a></h2>
<h3 id="if-elif-else"><a class="header" href="#if-elif-else">if elif else</a></h3>
<p>Avant de te montrer de réels exemples, tu vas apprendre à enchainer les tests.</p>
<p><strong>if</strong> sert à tester une ou plusieurs conditions. Si tout est <strong>Vrai</strong>, alors le
code qui suit sera exécuté.</p>
<p><strong>elif</strong> est la concaténation de <strong>else if</strong>. Il faut aussi mettre une
condition, et si la condition est <strong>Vraie</strong>, alors le code qui suit sera
exécuté. Tu peux enchainer autant de <strong>elif</strong> que tu veux. Tu n'es pas obligé
d'utiliser <strong>elif</strong> quand tu fais des tests.</p>
<p><strong>else</strong> contient du code qui sera exécuté si tous les tests précédents étaient
<strong>Faux</strong>. Il ne faut pas lui mettre de test.</p>
<pre><code class="language-sh">#!/bin/sh

# Si le code secret n'est pas bon
# on écrit sur stderr que le code est faux
# et on quitte le script avec l'exit status 1
if [ "$1" != "super_mot_de_passe" ]
then
    echo "Mauvais mot de passe" &gt;&amp;2
    exit 1
fi

if [ "$2" = "gelules" ]
then
    echo "Bonjour maitre"
elif [ "$2" = "pediluvien" ]
then
    echo "Bonjour jeune apprenti"
elif [ "$2" = "piscinien" ]
then
    echo "Bonjour, tu viens te rafraichir la mémoire ?"
else
    echo "Tu m'es inconnu"
fi
</code></pre>
<h3 id="petit-jeu-vidéo"><a class="header" href="#petit-jeu-vidéo">Petit jeu vidéo</a></h3>
<p>Pour apprendre à faire des tests, au lieu de t'énumérer tous les tests
possibles, je préfère te montrer plein d'exemples différents. A toi ensuite de
lire le <strong>man 1 test</strong> pour compléter tes connaissances.</p>
<p>Imaginons que tu codes un petit jeu vidéo en shell.</p>
<pre><code class="language-sh">#!/bin/sh

# Si le nombre d'arguments n'est pas 2
if [ $# -ne 2 ]
then
    echo "Usage: $0 LOGIN SALLE_DE_TP" &gt;&amp;2
    exit 1
fi

login=$1
tp=$2
save_file=sauvegarde.txt

# Si le fichier de sauvegarde n'existe pas et que c'est bien un pédiluvien qui
# joue au jeu, on crée le fichier de sauvegarde
if [ ! -f "$save_file" ] -a [ "$login" != "gelules" ]
then
    touch "$save_file"
fi

# Exception pour le maitre de jeu
if [ "$login" = "gelules" ]
then
    echo "TP gelules dans 'salle secrète'" &gt;&gt; "gelules_sauvegarde.txt"
    exit
fi

if [ "$tp" = "donjon" ]
then
    echo "TP $login dans 'donjon'" &gt;&gt; "$save_file"
    exit
elif [ "$tp" = "tour" ]
then
    echo "TP $login dans 'tour'" &gt;&gt; "$save_file"
    exit
elif [ "$tp" = "chambre" ]
then
    echo "TP $login dans 'chambre'" &gt;&gt; "$save_file"
    exit
else
    echo "Mauvaise TP" &gt;&amp;2
    exit 1
fi
</code></pre>
<p>Je te laisse essayer le script.</p>
<p>Il n'est pas optimisé du tout. Comme tu peux le voir, il y a du code qui se
répète. On retrouve beaucoup de fois</p>
<pre><code class="language-sh">echo "TP $login dans 'LIEU'" &gt;&gt; "$save_file"
</code></pre>
<p>mais c'est un problème pour plus tard. Pour l'instant il faut que tu apprennes à
jouer avec les tests.</p>
<p>Je t'invite à regarder plus en détail comment tester les nombres. Dans mon
exemple je teste si le nombre d'argument est <strong>N</strong>ot <strong>E</strong>qual à 2. Mais tu peux
tester une égalité, si le nombre est strictement inférieur ou inférieur ou égal,
et pareil avec la supériorité.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boucles"><a class="header" href="#boucles">Boucles</a></h1>
<p>Les boucles sont un moyen de répéter une séquence de code autant de fois que
nécessaire.</p>
<p>Imagine que tu veuilles créer les fichiers day_0.txt day_1.txt day_2.txt etc.
jusqu'à day_10.txt. Tu ne vas quand même pas écrire les noms de ces 11 fichiers
dans ton script ?</p>
<h2 id="while"><a class="header" href="#while">while</a></h2>
<p><strong>while</strong> a une iou plusieurs conditions, et le code de la condition sera
répété tant que la condition est <strong>Vraie</strong>.</p>
<pre><code class="language-sh">#!/bin/sh

i=0
while [ i -le 10 ]
do
    touch day_${i}.txt
    i=$((i + 1))
done
</code></pre>
<p>Ce code va créer la liste des fichiers day_0.txt jusqu'à day_10.txt.</p>
<p>Essaie maintenant de modifier le script pour le rendre plus modulable. Tu dois
utiliser des arguments pour :</p>
<ul>
<li>Avoir un nom de fichier différent que day</li>
<li>Partir d'un nombre de départ différent que 0</li>
<li>Finir à un nombre différent que 10. Attention, le nombre de fin doit être
strictement supérieur que le nombre de départ</li>
<li>Avoir une extension différent que txt</li>
</ul>
<p>Voici un exemple de corrigé :</p>
<pre><code class="language-sh">#!/bin/sh

if [ $# -ne 4 ]
then
    echo "Usage: $0 FILENAME START STOP EXTENSION" &gt;&amp;2
    exit 1
fi

if [ "$3" -le "$2" ]
then
    echo "Le nombre de départ doit être strictement supérieur que le nombre de fin" &gt;&amp;2
    exit 1
fi

filename=$1
start=$2
stop=$3
extension=$4

while [ "$start" -le "$stop" ]
do
    touch "${filename}_${start}.${extension}"
    start=$((start + 1))
done
</code></pre>
<p>On peut tester l'environnement du système. Par exemple, tant qu'un répertoire
n'existe pas, on boucle sur un message d'erreur.</p>
<pre><code class="language-sh">#!/bin/sh

while [ ! -d ventre ]
do
    echo "Le répertoire 'ventre' n'existe pas"
done

touch ventre/gateau_chocolat
touch ventre/gateau_caramel
touch ventre/gateau_vanille
touch ventre/gateau_pistache

echo "Burp"
</code></pre>
<p>Il faut utiliser un deuxième shell pour créer le répertoire.</p>
<h3 id="lire-un-fichier-ligne-par-ligne"><a class="header" href="#lire-un-fichier-ligne-par-ligne">Lire un fichier ligne par ligne</a></h3>
<p>Il est possible de lire un fichier ligne par ligne avec une boucle while.</p>
<pre><code class="language-sh">#!/bin/sh

if [ ! -f input_file ]
then
    echo "input_file n'existe pas" &gt;&amp;2
    exit 1
fi

while read line
do
    echo "La ligne est: $line"
done &lt; input_file
</code></pre>
<p>Evidemment, tu peux remplacer <strong>input_file</strong> par un paramètre.</p>
<h2 id="until"><a class="header" href="#until">until</a></h2>
<p><strong>until</strong> est exactement la même chose que <strong>while</strong>, à la différence que le
code exécuté est répété tant que la condition est <strong>Fausse</strong>. Plus exactement,
<strong>jusqu'à</strong> ce qu'elle soit <strong>Vraie</strong>.</p>
<pre><code class="language-sh">#!/bin/sh

i=0

# Tant que i n'égale pas 10, on exécute le code de la boucle
until [ $i -eq 10 ]
do
    echo $i
    i=$((i + 1))
done
</code></pre>
<h2 id="for"><a class="header" href="#for">for</a></h2>
<p><strong>for</strong> sert à boucler sur une séquence. Avec un point de départ, un point de
fin.</p>
<p>Tu peux boucler sur un ensemble d'éléments, ou une séquence de nombres.</p>
<pre><code class="language-sh">#!/bin/sh

for element in je suis un sequence
do
    echo $element
done
</code></pre>
<p>Tu peux boucler sur des séquences générées en pure shell.</p>
<pre><code class="language-sh">#!/bin/sh

for element in {a..z}
do
    echo $element
done
</code></pre>
<p>Pour les nombres il y a une différence. Je te laisse tester toutes ces
différences :</p>
<pre><code class="language-sh">#!/bin/sh

# De 1 à 20 par pas de 1
for nombre in {1..20}
do
    echo $nombre
done

# De 1 à 20 par pas de 4
for nombre in {1..20..4}
do
    echo $nombre
done

# De 20 à 1 par pas de 1
for nombre in {20..1}
do
    echo $nombre
done

# De 20 à 1 par pas de 6
for nombre in {20..1..6}
do
    echo $nombre
done
</code></pre>
<p>Tu peux aussi boucler sur les paramètres. Tu vas ici comprendre la différence
entre <strong>$@</strong> et <strong>$</strong>*</p>
<p>Teste les scripts avec au moins deux paramètres.</p>
<pre><code class="language-sh">#!/bin/sh

for arg in $@
do
    echo $arg
done
</code></pre>
<pre><code class="language-sh">#!/bin/sh

for arg in $*
do
    echo $arg
done
</code></pre>
<p>Jusqu'ici, aucune différence. Ajoute maintenant les variables entre double
quotes.</p>
<pre><code class="language-sh">#!/bin/sh

for arg in "$@"
do
    echo $arg
done
</code></pre>
<pre><code class="language-sh">#!/bin/sh

for arg in "$*"
do
    echo $arg
done
</code></pre>
<p>Tu peux maintenant voir la différence. <strong>$@</strong> reste une liste alors que <strong>$*</strong>
devient un seul argument.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="git"><a class="header" href="#git">Git</a></h1>
<p>Git est un outil de versionnage. Il te permet de sauvegarder un état d'un projet
à n'importe quel moment, et de revenir à cet état quand tu le souhaites.</p>
<p>Voici un petit glossaire au vocabulaire de git.</p>
<ul>
<li>repository (repo) : un dépôt local de travail dirigé par git</li>
<li>remote : un dépôt distant de travail dirigé par git</li>
<li>commit : acte de sauvegarder l'état du projet</li>
<li>revision : un point de sauvegarde (qui a été commit)</li>
<li>push : pousser le projet du repo local à la remote</li>
<li>pull : tirer le projet de la remote au repo local</li>
<li>HEAD : nom donné à la dernière révision du projet</li>
<li>changeset (ou SHA-1) : idenfiant unique d'une révision</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="commandes-de-bases"><a class="header" href="#commandes-de-bases">Commandes de bases</a></h1>
<p>Tu vas effectuer quelques commandes de bases pour mieux appréhender Git. Rien de
spectaculaire mais tu sauras faire le minimum.</p>
<h2 id="init"><a class="header" href="#init">init</a></h2>
<p>Avant de jouer avec git, il faut initier le dépôt local.</p>
<h3 id="gitconfig"><a class="header" href="#gitconfig">gitconfig</a></h3>
<p>Avant d'initier un dépôt local, il faut configurer git avec au moins deux
informations : ton nom et ton mail.</p>
<p>Pour ça, tu vas créer un fichier <strong>.gitconfig</strong> dans ton <strong>HOME</strong> et le remplir
ainsi :</p>
<pre><code class="language-text">$ cat ~/.gitconfig
[user]
    name = Gélules
    email = gelules@gelules.gelules
$
</code></pre>
<p>Evidemment, change les informations avec les tiennes.</p>
<p>Ces informations seront utiles pour savoir qui a créé quel commit.</p>
<pre><code class="language-text">$ mkdir projet
$ cd projet
$ git init
</code></pre>
<p>Voilà, le répertoire <strong>projet</strong> est prêt à utiliser git.</p>
<p>Comment ça fonctionne ? Git crée en secret un répertoire caché qu'il utilise
pour suivre l'état du projet.</p>
<pre><code class="language-text">$ ls -l .git
...
$
</code></pre>
<h2 id="status"><a class="header" href="#status">status</a></h2>
<p><strong>git status</strong> est une commande fondamentale. Elle te permet de savoir où tu en
es dans ton travail.</p>
<p>Si tu le fais dans un répertoire vide, la commande te répondera qu'il n'y a rien
à commit, et qu'il faut utiliser <strong>git add</strong> pour commencer à suivre les
fichiers.</p>
<h2 id="add"><a class="header" href="#add">add</a></h2>
<p>Tu vas créer deux fichiers, <strong>README</strong> et <strong>file_creator.sh</strong>. Pour l'instant
ils seront vides.</p>
<pre><code class="language-text">$ touch README file_creator.sh
$ git status
Untracked files:
  (use "git add &lt;file&gt;..." to include in what will be committed)
	README
	file_creator.sh
$ git add README file_creator.sh
$ git status
Changes to be committed:
  (use "git rm --cached &lt;file&gt;..." to unstage)
	new file:   README
	new file:   file_creator.sh
$
</code></pre>
<p>Tes fichiers sont prêts à être commités.</p>
<h2 id="commit"><a class="header" href="#commit">commit</a></h2>
<p>Pour créer un commit, il faut penser d'abord réfléchir à un message de commit
<strong>intelligent</strong>. Le tout premier est en <em>général</em> un simple <strong>initial commit</strong>.
Les prochains seront plus réfléchis selon le projet que tu effectues.</p>
<pre><code class="language-text">$ git commit -m "initial commit"
[master (root-commit) 8a87f72] initial commit
 2 files changed, 0 insertions(+), 0 deletions(-)
 create mode 100644 README
 create mode 100644 file_creator.sh
$
</code></pre>
<p>Tu as crées ton premier commit. Bravo !</p>
<p>Tu peux lire ici que c'est le <em>root-commit</em>, le tout premier du projet, et que
son changeset est <em>8a87f72</em>, et que 2 fichiers ont été créés avec les
permissions <em>644</em>.</p>
<p>Il est plus que probable que tu n'aies pas le même SHA-1. C'est normal.</p>
<p>A savoir : Git ne traque que la permission d'exécution. Si un fichier est
exécutable en local, il le sera aussi sur la remote.</p>
<h2 id="log"><a class="header" href="#log">log</a></h2>
<p>Maintenant que tu as crée ton premier commit, tu peux voir les logs du projet
évoluer avec la commande <strong>git log</strong>.</p>
<pre><code class="language-text">$ git log
commit 8a87f728e30904f1cd837fd3ca2d4f17d11c0e58 (HEAD -&gt; master)
Author: Gélules &lt;gelules@gelules.gelules&gt;
Date:   Sun Jul 21 22:15:07 2024 +0200

    initial commit
$
</code></pre>
<h2 id="on-continue-le-projet-sur-github"><a class="header" href="#on-continue-le-projet-sur-github">On continue le projet sur Github</a></h2>
<p>Dans la prochaine section, tu vas apprendre à créer un dépôt sur Github, à créer
des clés SSH pour garantir la sécurité de push et pull entre ton dépôt local et
la remote de GitHub et tu vas travailler ton projet que tu <strong>pusheras</strong> sur
GitHub pour voir l'évolution.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cas-pratique-avec-github"><a class="header" href="#cas-pratique-avec-github">Cas pratique avec GitHub</a></h1>
<p>Le but de git, c'est de sauvegarder chaque nouvelle fonctionnalité de ton projet
dans un commit. Des que tu ajoutes quelque chose, que tu l'as testé et qu'il
fonctionne, alors tu fais un commit.</p>
<p>Et si tu utilises une remote, alors tu veux en plus <strong>pousser</strong> tes sauvegardes
dessus.</p>
<p>Tu vas ici apprendre à utiliser git avec GitHub.</p>
<h2 id="création-du-compte"><a class="header" href="#création-du-compte">Création du compte</a></h2>
<p>Tout d'abord, crée un compte sur <a href="https://github.com">GitHub</a></p>
<h2 id="clés-ssh"><a class="header" href="#clés-ssh">Clés SSH</a></h2>
<p>Pour que tu puisses utiliser ton dépôt, tu dois créer des clés SSH. Tu vas créer
deux clés, une clé privée, qui comme son nom l'indique doit rester privée, et
une clé publique, que tu peux montrer à tout le monde.</p>
<p>Quand tu installeras ta clé publique sur GitHub, il y aura une opération
cryptographique entre ta clé privée et la clé publique pour assurer que tu as
les droits de pousser ton travail sur GitHub.</p>
<p>Ca semble compliqué dit comme ça, ne t'inquiète pas, tout est transparant pour
toi, tu n'auras rien à faire une fois que tout est installé.</p>
<p>Va dans ton <strong>HOME</strong> et crée le répertoire <strong>.ssh</strong>. Dedans, crée les clés SSH.</p>
<pre><code class="language-text">$ cd
$ mkdir .ssh
$ cd .ssh
$ ssh-keygen -t ed25519
</code></pre>
<p>Là, un prompt te demande comment tu veux appeler ta clé. Appelle la <strong>github</strong>.</p>
<p>Ensuite, un prompt te demande si tu veux mettre un mot de passe à ta clé. C'est
une sécurité en plus. A chaque fois que tu feras appel à cette clé pour faire
une connexion avec la remote de GitHub, tu devras rentrer ce mot de passe.</p>
<p>Met un mot de passe si tu veux.</p>
<p><strong>ATTENTION</strong>, si tu veux absolument mettre un mot de passe, alors je te
conseille de changer la génération de tes clés avec cette commande</p>
<pre><code class="language-text">$ ssh-keygen -t ed25519 -a 100
</code></pre>
<p>La différence est qu'il y aura une centaine de passages sur ta clé avec un
chiffrement particulier. Par défaut la valeur est 16. 100 est une assez bonne
valeur pour augmenter la robustesse de la clé si quelqu'un te la vole et tente
de casser le mot de passe avec une attaque bruteforce sans que ça ralentisse
trop les vérifications de mot de passe à chaque utilisation de la clé.</p>
<p>Maintenant que tu as crées les clés, tu vas créer dans le répertoire ~/.ssh/ le
fichier config que tu vas configurer pour la connexion à GitHub.</p>
<pre><code class="language-text">$ cat ~/.ssh/config
Host github.com
    Hostname github.com
    User git
    IdentityFile ~/.ssh/github
$
</code></pre>
<p>Laisse <strong>git</strong> dans la partie <strong>User</strong>.</p>
<p>Tu as deux clés. <strong>github</strong> et <strong>github.pub</strong>. La première est la clé privée, la
seconde la clé publique.</p>
<p>Dans GitHub, dirige toi dans <a href="https://github.com/settings/keys">Settings &gt; Access &gt; SSH and GPG keys</a></p>
<p>Clique sur <strong>New SSH key</strong>. Donne lui un nom, le nom de ton PC par exemple, et
colle la clé publique dans le champ prévu à cet effet. Sauvegarde en cliquant
sur <strong>Add SSH key</strong>.</p>
<p>Tu vas maintenant tester la connexion.</p>
<pre><code class="language-text">$ ssh -T git@github.com
The authenticity of host 'github.com (IP ADDRESS)' can't be established.
ED25519 key fingerprint is SHA256:+DiY3wvvV6TuJJhbpZisF/zLDA0zPMSvHdkr4UvCOqU.
Are you sure you want to continue connecting (yes/no)?
</code></pre>
<p>Ecris <strong>yes</strong> et appuie sur Entrée.</p>
<pre><code class="language-text">Hi Gelules! You've successfully authenticated, but GitHub does not provide shell access.
</code></pre>
<p>Evidemment tu devrais voir ton login à la place du mien.</p>
<h2 id="création-du-projet"><a class="header" href="#création-du-projet">Création du projet</a></h2>
<p>Retourne sur l'accueil de <a href="https://github.com">GitHub</a>.</p>
<p>En haut à gauche, il y a un bouton vert <strong>New</strong>. Clique dessus pour créer un
nouveau distant. Appelle le <strong>file_creator</strong>. Tu peux le rendre publique ou
privée au choix.</p>
<p><img src="git/./github/create_project.png" alt="Création du projet sur GitHub" title="Création du projet sur GitHub" /></p>
<p>Crée le projet.</p>
<h2 id="clone-du-projet"><a class="header" href="#clone-du-projet">Clone du projet</a></h2>
<p>Te voilà maintenant sur le projet, vide.</p>
<p>Tu as au milieu une partie <em>Quick setup</em> avec deux boutons, HTTPS et SSH. Clique
sur <strong>SSH</strong>. Copie le lien qui est inscrit. Le mien ressemble à ceci :
git@github.com:Gelules/file_creator.git</p>
<p>Retourne dans ton <strong>HOME</strong> et exécute la commande suivante :</p>
<pre><code class="language-text">$ git clone git@github.com:Gelules/file_creator.git
...
$ cd file_creator
</code></pre>
<p>Remplace le lien par le tien, évidemment.</p>
<h2 id="retour-au-projet"><a class="header" href="#retour-au-projet">Retour au projet</a></h2>
<p>Le projet, créer un générateur de fichiers. Le même que tu as fait dans les
chapitres de shell, mais on va ici le construire petit à petit et faire un
commit à chaque nouvelle fonctionnalité.</p>
<p>Tu vas recréer le fichier <strong>file_creator.sh</strong> et <strong>README</strong>, vides. Les ajouter
et les commit avec le message <strong>initial commit</strong>.</p>
<h2 id="push"><a class="header" href="#push">push</a></h2>
<p>Maintenant que tu es retourné à l'état du chapitre précédent, tu vas pousser tes
fichiers vides.</p>
<pre><code class="language-text">$ git push
Enumerating objects: 3, done.
Counting objects: 100% (3/3), done.
Delta compression using up to 4 threads
Compressing objects: 100% (2/2), done.
Writing objects: 100% (3/3), 233 bytes | 233.00 KiB/s, done.
Total 3 (delta 0), reused 0 (delta 0), pack-reused 0 (from 0)
To github.com:Gelules/file_creator.git
 * [new branch]      main -&gt; main
$
</code></pre>
<p>Retourne sur GitHub, et rafraichis la page. Surprise ! Tes fichiers y sont.
Toujours vides.</p>
<h2 id="avancement"><a class="header" href="#avancement">Avancement</a></h2>
<p>Comme je te l'avais dit, git suit ce qu'on appelle le <em>execution bit</em>, le bit
qui indique qu'un fichier est exécutable ou non.</p>
<p>Pour le voir par l'exemple, tu vas rendre <strong>file_creator.sh</strong> exécutable,
exécuter <strong>git status</strong>, tu verras qu'il t'indique d'ajouter le fichier.</p>
<p>Rends le exécutable, ajoute le, crée un commit pour indiquer que le fichier doit
être exécutable et pousse ton travail.</p>
<pre><code class="language-text">$ chmod +x file_creator.sh
$ git status
$ git add file_creator.sh
$ git commit -m "file_creator must be executable"
$ git push
$ git log
</code></pre>
<p>Dans les logs, tu peux voir que les commits montent à chaque nouvelle
sauvegarde.</p>
<p>Tu peux voir à la fin du premier commit que la <strong>HEAD</strong> est sur la branche
<strong>main</strong>, qui est la branche par défaut sur git, et que la branche <strong>main</strong> de
la remote <strong>origin</strong> est aussi sur le dernier commit : tu es à jour sur ton
dépôt local et sur la remote.</p>
<p>Voilà, tu as ici l'utilisation moyenne de git. Tu modifies, tu vérifies que tout
aille bien</p>
<p>Tu vas commencer par un script qui genère des fichiers qui suivent ce pattern :
test_NUMERO.txt allant de 0 à 10.</p>
<pre><code class="language-sh">#!/bin/sh

i=0
while [ $i -le 10 ]
do
    touch test_${i}.txt
done
</code></pre>
<p>En temps normal, tu dois tester ta nouvelle fonctionnalité.
Quand tous tes tests sont bons, alors tu peux commit ton travail.</p>
<p>Que manque t-il ici ? L'incrémentation de <strong>i</strong> à chaque création de fichier. Je
te laisse faire le changement nécessaire.</p>
<p>Ajoute dans le README un message pour indiquer comment utiliser ton projet.</p>
<pre><code class="language-text">$ cat README
file_generator is a super project to generate a lot of files with different
extensions. For now it's only able to generate 10 test files.
$ git add file_generator.sh README
$ git commit -m "generate 10 tests file"
$ git log
</code></pre>
<p>Tu peux le voir, ta remote est maintenant en retard d'un commit. Pousse ton
travail pour que tout soit à jour.</p>
<pre><code class="language-text">$ git push
</code></pre>
<h3 id="nom-de-fichiers"><a class="header" href="#nom-de-fichiers">Nom de fichiers</a></h3>
<p>Tu vas maintenant modifier le script pour qu'il gère un nom de fichier différent
selon le paramètre que tu envoies.</p>
<pre><code class="language-sh">#!/bin/sh

if [ $# -ne 1 ]
then
    echo "Usage: $0 FILENAME" &gt;&amp;2
    exit 1
fi

filename=$1

i=0
while [ $i -le 10 ]
do
    touch ${filename}_${i}.txt
    $i=$((i + 1))
done
</code></pre>
<p>Modifie le README en conséquence.</p>
<p>Ajoute tes modifications à git, commit et pousse.</p>
<p>N'oublie pas d'utiliser <strong>git status</strong> et <strong>git log</strong> pour voir l'évolution.</p>
<h3 id="nombre-de-fichiers"><a class="header" href="#nombre-de-fichiers">Nombre de fichiers</a></h3>
<p>Nouvelle évolution : Tu vas maintenant avoir un script qui peut générer un
nombre de fichiers différents, qui part d'un nombre donné en paramètre et qui
termine sur un autre nombre donné en paramètre.</p>
<pre><code class="language-sh">#!/bin/sh

if [ $# -ne 3 ]
then
    echo "Usage: $0 FILENAME START STOP" &gt;&amp;2
    exit 1
fi

if [ "$stop" -le "$start" ]
then
    echo "START number must be greater than STOP number" 2&gt;
    exit 1
fi

filename=$1
start=$2
stop=$3

while [ "$start" -le "$stop" ]
do
    touch ${filename}_${start}.txt
    start=$((start + 1))
done
</code></pre>
<p>Modifie le README en conséquence.</p>
<p>Ajoute tes modifications à git, commit et pousse.</p>
<p>N'oublie pas d'utiliser <strong>git status</strong> et <strong>git log</strong> pour voir l'évolution.</p>
<h3 id="reclone"><a class="header" href="#reclone">reclone</a></h3>
<p>J'ai besoin que tu connaisses la commande <strong>git pull</strong>. Pour ça tu vas cloner
une deuxième fois ton dépôt ailleurs. Dans le répertoire <strong>/tmp</strong> par exemple.</p>
<p>Ouvre un deuxième terminal et effectue ces commandes.</p>
<pre><code class="language-text">$ cd /tmp
$ git clone git@github.com:Gelules/file_creator.git
...
$ cd file_creator
</code></pre>
<p>Tu viens de cloner ton dépôt dans le dernier état auquel tu avais poussé ton
travail.</p>
<p>Garde ce terminal de côté et retourne sur le premier.</p>
<h3 id="extension"><a class="header" href="#extension">Extension</a></h3>
<p>Tu vas ajouter la dernière modification. Tu vas demander à l'utilisateur de
donner une extension aux fichiers générés.</p>
<pre><code class="language-sh">#!/bin/sh

if [ $# -ne 4 ]
then
    echo "Usage: $0 FILENAME START STOP EXTENSION" &gt;&amp;2
    exit 1
fi

if [ "$stop" -le "$start" ]
then
    echo "START number must be greater than STOP number" 2&gt;
    exit 1
fi

filename=$1
start=$2
stop=$3
extension=$4

while [ "$start" -le "$stop" ]
do
    touch ${filename}_${start}.${extension}
    start=$((start + 1))
done
</code></pre>
<p>Modifie le README en conséquence.</p>
<p>Ajoute tes modifications à git, commit et pousse.</p>
<p>N'oublie pas d'utiliser <strong>git status</strong> et <strong>git log</strong> pour voir l'évolution.</p>
<h3 id="pull"><a class="header" href="#pull">pull</a></h3>
<p>Tu te souviens du deuxième terminal qui avait clone la remote ?</p>
<p>Ce répertoire n'est plus à jour avec la nouvelle modification ! Tu vas y
remédier.</p>
<p>Sur ton deuxième terminal :</p>
<pre><code class="language-text">$ git pull
...
$
</code></pre>
<p>Et voilà, tu as <strong>pull</strong> ta mise à jour.</p>
<p>Evidemment sur le même ordinateur ce n'est pas utile.</p>
<p>Mais si tu travailles sur plusieurs machines ou que tu es un groupe à plusieurs
personnes sur un projet, alors chacun pourra mettre à jour le projet ainsi.</p>
<p>Evidemment il peut y avoir des conflits si tout le monde touche au même fichier
en même temps, mais c'est un problème que tu apprendras à résoudre pendant tes
études.</p>
<p>Bravo ! Tu as terminé ton pédiluve sur git !</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="langage-c"><a class="header" href="#langage-c">Langage C</a></h1>
<p>Le langage C n'est pas le langage de programmation le plus simple à apprendre.
Si on veut le maitriser, il faut aller en profondeur dans les entrailles du
système, ce qui n'est pas évident au début.</p>
<p>La bonne nouvelle, c'est qu'on peut s'en servir pour de simples applications
sans trop s'inquiéter de ces fameuses entrailles. C'est ce que tu vas voir ici.</p>
<p>Tu vas apprendre à faire un peu de C. Assez pour comprendre à utiliser le
langage et ne pas être perdu au début de ta piscine.</p>
<p>Je donne quand même quelques petites astuces qui ne sont pas souvent données
dans les cours en ligne pour garder de bons réflexes et être sûr de ne pas faire
n'importe quoi.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="abécédaire"><a class="header" href="#abécédaire">Abécédaire</a></h1>
<p>Les chapitres de l'abécédaire vont te permettre de souffler après autant de
Shell. Ils sont écrits en sorte à ce que tu puisses t'amuser à faire des petits
programmes sans comprendre les magouilles techniques qui se cachent pendant
l'exécution de ton programme.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="compilation-de-test"><a class="header" href="#compilation-de-test">Compilation de test</a></h1>
<p>Le langage C est un langage <strong>compilé</strong>. A l'inverse du shell, tu ne vas pas
exécuter du C comme tu l'écris. Tu vas utiliser un <strong>compilateur</strong> pour
transformer ton code course en <strong>langage machine</strong>.</p>
<p>Tu vas pour ce cours faire tes codes de test dans un seul et unique fichier que
tu vas appeler <strong>test.c</strong>. Ton compilateur est <strong>gcc</strong>. Installe le si tu ne
l'as pas.</p>
<pre><code class="language-text">$ which gcc
/usr/bin/gcc
$
</code></pre>
<p>Voici le fichier le plus petit que tu peux utiliser pour faire du C.</p>
<pre><code class="language-c">int main(void)
{
    return 0;
}
</code></pre>
<p>Tu peux écrire ton code entre les accolades pour commencer.</p>
<p>Pour compiler et essayer ton programme, voici la commande à utiliser :</p>
<pre><code class="language-text">$ gcc test.c -o mon_super_programme
$ ./mon_super_programme
$
</code></pre>
<p>Sache que tu peux commenter ton code pour le documenter et décrire que tu fais.
Il existe deux types de commentaire. Les singie lines et les multilines.</p>
<pre><code class="language-c">/* Cette fonction main
ne prend rien en entrée et ne fait que
retourner 0 */

int main(void)
{
    // retourne 0 en exit status;
    return 0;
}
</code></pre>
<p>Voilà, tu es prêt pour la suite.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="la-fonction-main-et-lenvironnement-de-développement"><a class="header" href="#la-fonction-main-et-lenvironnement-de-développement">La fonction main et l'environnement de développement</a></h1>
<p>La fonction main est le point d'entrée des programmes en C.</p>
<p>Une fonction est une zone qui contient du code.</p>
<p>Tu pourras créer tes propres fonctions plus tard, que tu pourras appeler depuis
la fonction main.</p>
<p>Pour l'instant, voici ce que tu as :</p>
<pre><code class="language-c">int main(void)
{
    return 0;
}
</code></pre>
<p>Décortiquons tout ça.</p>
<p><strong>int</strong> signifie que la fonction retourne un <strong>int</strong>eger, c'est à dire un
entier. C'est effectivement le cas avec le <strong>return 0</strong> dans le code. Tu
retournes la valeur 0 dans le shell comme <strong>exit status</strong>.</p>
<p><strong>void</strong> veut dire que la fonction ne prend pas de paramètres. Donc tu ne peux
pas envoyer de paramètre à l'exécution de ton programme, à l'inverse de
programmes que tu as déjà utilisés comme <strong>ls</strong>, <strong>echo</strong>, <strong>mkdir</strong>, etc. Tu
verras juste après comment faire.</p>
<p>Change le 0 par un 42, compile ton programme, et exécute le. Tu verras que tu
auras un <strong>exit status</strong> à 42.</p>
<pre><code class="language-c">int main(void)
{
    return 42;
}
</code></pre>
<pre><code class="language-text">$ gcc test.c -o mon_super_programme
$ ./mon_super_programme
$ echo $?
42
$
</code></pre>
<p>Tu comprends mieux maintenant comment les programmes que tu sais utiliser te
renvoient des <strong>exit status</strong> maintenant.</p>
<h2 id="argument"><a class="header" href="#argument">Argument</a></h2>
<p>La fonction <strong>main</strong> peut prendre des arguments. Voici comment :</p>
<pre><code class="language-c">int main(int argc, char *argv[])
{
    return 0;
}
</code></pre>
<p>Oh là là, en voilà une nouvelle écriture compliquée.</p>
<p>Décortiquons tout ça.</p>
<p><strong>int argc</strong> signifie que <strong>argc</strong> est de type <strong>int</strong>, c'est un entier. Il
s'agit ici du nombre d'arguments (<em>arguments counter</em>) que ton programme reçoit à son exécution. En
shell, c'est l'équivalent de la variable <strong>$#</strong>.</p>
<p>char *argv[] ; celui là est un peu plus difficile. <strong>char</strong> signifie caractère.
Donc il y a des caractères en jeu ici, du texte.</p>
<p>L'étoile * signifie pointeur, tu sauras ce que c'est plus tard.o</p>
<p>[] signifie <strong>tableau</strong> (array).</p>
<p>argv est un tableau de chaines de caractères. Il contient autant de chaines de
caractères que la valeur de <strong>argc</strong>.</p>
<p>Son nom signifie <em>arguments values</em></p>
<p>Voici un bout de code pour voir les paramètres que tu envoies en entrée à ton
programme.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
    for (int i = 0; i &lt; argc; i = i + 1)
    {
        printf("argv[%d] = %s\n", i, argv[i]);
    }

    return 0;
}
</code></pre>
<p>Que de nouvelles complications !</p>
<p>Décortiquons tout ça.</p>
<p>#include &lt;stdio.h&gt; veut dire qu'on va inclure stdio.h. C'est un fichier quelque
part dans les répertoires systèmes. C'est ce qu'on appelle une bibliothèque (et
pas une librairie, une librairie c'est un endroit avec des livres. En revanche
la traduction de bibliothèque en Anglais et library, d'où cet abus de langage).
Cette bibliothèque contient du code pour indiquer à gcc qu'il existe quelque
part une fonctione appelée <strong>printf</strong>.</p>
<p>Ensuite il y a une boucle for. La boucle for initialise une variable <strong>i</strong> de
type <strong>int</strong> à 0.
Elle va continuer son exécution tant que <strong>i est plus petit que argc</strong>, et à
chaque itération, <strong>i s'incrémente de 1</strong>. Tu peux voir que toutes les étapes de
la boucle sont séparées par des point-virgules ';'.</p>
<p>Ensuite, entre les accolades de la boucle, il y a un appel à la fonction
<strong>printf</strong>. Le nom de la fonction signifie <strong>print format</strong>. Tu vas formater du
texte avec des arguments.</p>
<p>Dans argv[%d], %d attend un entier. <strong>i</strong> qui est envoyé en paramètre juste
après sera remplacé et aura sa valeur affichée entre les crochets.</p>
<p>%s est un code qui attend une chaine de caractères. <strong>argv</strong> est le tableau qui
contient des chaines de caractères.</p>
<p>Enfin, \n signifie <strong>saut à la ligne</strong>. Plus exactement <em>linefeed</em>.</p>
<p>Compile et exécute ton programme ainsi :</p>
<pre><code class="language-text">$ gcc test.c -o mon_super_programme
$ ./mon_super_programme coucou les loulous 0 1 10
argv[0] = ./mon_super_programme
argv[1] = coucou
argv[2] = les
argv[3] = loulous
argv[4] = 0
argv[5] = 1
argv[6] = 10
$
</code></pre>
<p>Voilà à quoi ressemble <strong>argv</strong> au moment de l'exécution
argv =
[
./mon_super_programme
coucou
les
loulous
0
1
10
]</p>
<p>Tu peux voir que <strong>i</strong> va aller de ligne en ligne pour afficher chaque valeur.</p>
<p>Tu te poses peut-être la question de pourquoi i commence à 0 et pas 1 ? C'est
comme ça que beaucoup de langages de programmation gèrent les accès mémoires, en
commençant par 0.</p>
<p>Attention, en shell tu aurais pu utiliser les valeurs 0, 1 et 10 comme entiers.
Ce n'est pas le cas ici, les valeurs sont des caractères, tu ne peux pas les
utiliser pour faire des maths comme tu as l'habitude de faire en shell.</p>
<p>Pour transformer une chaine de caractères en entier, tu peux utiliser la
fonction <strong>atoi</strong> qui signifie <em>ascii to integer</em>.</p>
<p>ASCII est un standard pour représenter des caractères.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char *argv[])
{
    int age = 0;

    if (argc != 2)
        return 1;

    age = atoi(argv[1]);

    printf("J'ai %d ans\n", age);

    return 0;
}
</code></pre>
<p>Tout d'abord, la bibliothèque stdlib.h est inclue. Je te montrerai juste après
comment savoir quelle bibliothèque inclure selon ce que tu veux utiliser.</p>
<p>Je crée la variable <strong>age</strong> à 0 en tant qu'entier. C'est une bonne pratique,
toujours créer ses variables au tout début, avec des valeurs définies à 0, sauf
si tu as absolument besoin d'une autre valeur d'initialisation.</p>
<p>Ici, je teste si argc est différent de 2. Si c'est le cas, je quitte le
programme avec un exit status à 1. Tu peux voir que ce n'est pas comme en shell.
Je teste les valeurs avec des signes d'égalités, pas avec <strong>-ne</strong> comme tu as pu
le voir en shell.</p>
<p>Ensuite je dis que age est égal à l'appel de <strong>atoi</strong> sur le 1er argument. Puis
je l'affiche.</p>
<p>Je t'invite à compiler ton programme et le tester ainsi :</p>
<pre><code class="language-text">$ gcc test.c -o mon_super_programme
$ ./mon_super_programme
$ echo $?
1
$ ./mon_super_programme 42
J'ai 42 ans
$ echo $?
0
$./mon_super_programme coucou
J'ai 0 ans
$ ./mon_super_programme 42coucou
J'ai 42 ans
$ ./mon_super_programme coucou42
J'ai 0 ans
$
</code></pre>
<p><strong>atoi</strong> transforme ton paramètre en nombre seulement s'il trouve au début un
nombre, sinon il renvoie 0.</p>
<h3 id="man-et-bibliothèque"><a class="header" href="#man-et-bibliothèque">man et bibliothèque</a></h3>
<p>Pour savoir quel bibliothèque utiliser, tu vas utiliser ton meilleur ami, le
man.</p>
<pre><code class="language-text">$ man atoi
...
</code></pre>
<p>Tu peux voir dans le man de atoi qu'il faut inclure stdlib.h.</p>
<p>Tu peux également vérifier dans le main quelle est la bibliothèque à inclure
pour printf. Il s'agit bien de stdio.h.</p>
<pre><code class="language-text">$ man 3 printf
...
</code></pre>
<p>Attention à bien mettre 3 pour bien dire que c'est le printf du langage C que tu
veux utiliser, pas le binaire installé sur le système.</p>
<p>Plus tard dans ton cursus, tu utiliseras des <em>syscalls</em>, des appels systèmes. Ce
sont des fonctions fournies par le kernel Linux. La différence est qu'il faut
demander la 2eme section du manuel.</p>
<pre><code class="language-text">$ man 2 write
</code></pre>
<p>Tu sauras avec le temps si tu cherches un syscall ou une fonction.</p>
<h4 id="recherche-dans-le-man"><a class="header" href="#recherche-dans-le-man">Recherche dans le man</a></h4>
<p>Si tu veux lister les sections pour un mot en particulier dans le man, tu peux
utiliser la commande suivante :</p>
<pre><code class="language-text">$ man -k printf
...
</code></pre>
<p>Tu verras que ça va générer <strong>BEAUCOUP</strong> de lignes. Tu peux filter en rajoutant
un circonflexe '^' au début du mot et un dollar '$' à a fin, le tout entre
simple quote.</p>
<pre><code class="language-test">$ man -k '^printf$'
...
</code></pre>
<p>Ce sont des caractères spéciaux. ^ signifie début de ligne et $ signifie fin de
ligne.</p>
<pre><code class="language-text">$ man -k '^read$'
...
</code></pre>
<p>Tu peux voir que <em>read</em> existe dans la section 1p, 2 et 3p. Si tu n'avais pas
limité la recherche avec ^ et $, tu aurais eu énormément de résultats pas très
intéressants.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="types-prédéfinis"><a class="header" href="#types-prédéfinis">Types prédéfinis</a></h1>
<h2 id="types"><a class="header" href="#types">Types</a></h2>
<p>Tu as déjà joué avec deux types depuis le début du chapitre en C : les entiers
et les pointeurs sur caractères.</p>
<p>Voici une liste de types que tu peux créer, je vais aussi te montrer les codes à
utiliser pour les afficher avec printf.</p>
<p>Tu peux retrouver les informations des codes à utiliser dans <strong>man 3 printf</strong>.</p>
<h3 id="entiers"><a class="header" href="#entiers">Entiers</a></h3>
<p>Les entiers se reconnaissent avec l'utilisation du type <strong>int</strong>. Mais tu peux
ajouter des qualificateurs pour changer la façon de les utiliser.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    // Peut être négatif et positif
    int entier_simple = -42;
    printf("entier_simple = %d\n", entier_simple);

    // Ne peut pas être négatif
    unsigned int entier_non_signe = 333;
    printf("entier_simple = %u\n", entier_non_signe);

    // Ne peut pas avoir une grande taille
    short int petit = 32767;
    printf("petit = %d\n", petit);
    petit = petit + 1;
    printf("petit = %d\n", petit);

    long int large = 2000000000; // 2 milliards
    printf("large = %ld\n", large);

    long long int tres_large = 30000000000; // 30 milliards
    printf("tres_large = %lld\n", tres_large);

    return 0;
}
</code></pre>
<p>Je te laisse essayer ce code. Il n'est pas exhaustif sur les combinaisons
possibes sur les entiers qu'on peut créer.</p>
<p>Décortiquons tout ça.</p>
<p>La variable <strong>entier_simple</strong> est un entier tout ce qu'il y a de plus simple.
Elle peut aller dans le négatif et le positif.</p>
<p>La variable <strong>entier_non_signe</strong> ne peut pas avoir de signe négatif. Elle sera
toujours strictement positive. La différence avec <strong>entier_simple</strong> est qu'elle
peut avoir une valeur positive deux fois plus grande, mais en contrepartie elle
ne peut peut pas être négative.</p>
<p>Que s'est-il passé avec la variable <strong>petit</strong> ? Le qualificateur <strong>short</strong>
informe que la variable a une petite taille en mémoire, elle peut aller de
-32768 à 32767. Si elle dépasse 32767, elle revient à la valeur la plus petite
qu'elle peut prendre. On appelle ça un <strong>overflow</strong>.</p>
<p>Les variables <strong>large</strong> et <strong>tres_large</strong> peuvent avoir des valeurs énormes.</p>
<p>Tu peux ajouter <strong>unsigned</strong> avec tous les qualificateurs que tu viens de voir.
Ils pourront avoir une valeur positive deux fois plus grande que les variables
implicitement <strong>signed</strong> mais ne pourront jamais avoir une valeur négative.</p>
<p>Voici un tableau des types d'entiers que tu peux avoir, la place qu'ils prennent
en mémoire et leurs limites.</p>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Octets</th><th>Valeurs</th></tr></thead><tbody>
<tr><td>short int</td><td>2</td><td>-32768 à 32767</td></tr>
<tr><td>unsigned short int</td><td>2</td><td>0 à 65535</td></tr>
<tr><td>int</td><td>4</td><td>-2147483648 à 2147483647</td></tr>
<tr><td>unsigned int</td><td>4</td><td>0 à 4294967295</td></tr>
<tr><td>long int</td><td>8</td><td>-9223372036854775808 à 9223372036854775807</td></tr>
<tr><td>unsigned long int</td><td>8</td><td>0 à 18446744073709551615</td></tr>
<tr><td>long long int</td><td>8</td><td>-9223372036854775808 à 9223372036854775807</td></tr>
<tr><td>unsigned long long int</td><td>8</td><td>0 à 18446744073709551615</td></tr>
</tbody></table>
</div>
<p>S'il n'y a pas de différence entre <strong>long int</strong> et <strong>long long int</strong>, c'est parce
que les architectures actuelles sont des architectures 64 bits. Juste avant
notre ère actuelle, les ordinateurs étaient sur des architectures 32 bits, et
les types en C étaient bien différents.</p>
<p>L'architecture que j'utilise est de l'Intel 64 bits. Mais par exemple Apple qui
a une autre architecture aura peut-être des valeurs différentes.</p>
<p>Pour calculer combien de nombres tu peux avoir avec un type, prends sa taille en
mémoire (sous la colonne <strong>Octets</strong> du tableau), multiplie la par 8. Pourquoi ?
Rappelle toi du chapitre <a href="c/../preliminaires/bit_byte.html">bits et octets</a>. Un
octet et constitué de 8 bits.</p>
<p>Maintenant que tu as multiplié par 8, pose cette valeur en puissance de 2.</p>
<p>Par exemple, le <strong>short int</strong> prend 2 octets en mémoire, donc 16 bits.</p>
<p>\[ 2 ^{16} = 65536 \]</p>
<p>Tu as donc 65536 nombres possibles avec un <strong>short int</strong>. C'est pour ça que
<strong>signé</strong> tu as la moitié de cette valeur disponible en négatif et pareil en
positif.</p>
<p>Pour le formatage avec <strong>printf</strong>, tu dois utiliser <strong>%d</strong> pour les entiers
signés et <strong>%u</strong> pour les entiers non signés.</p>
<p>Tu dois ajouter <strong>l</strong> pour un <strong>long</strong> et <strong>ll</strong> pour un <strong>long long</strong>. Selon le
système sur lequel tu te trouves, vérifie toujours la taille en octet des types
prédéfinis. Je te montre à la fin de ce chapitre comment faire ça.</p>
<h3 id="décimales"><a class="header" href="#décimales">Décimales</a></h3>
<p>Tu peux également utiliser des variables à décimales. Tu en as deux : <strong>float</strong>
et <strong>double</strong>.</p>
<p>Sur mon architecture, <strong>float</strong> prend 4 octets en mémoire et <strong>double</strong> prend 8
octets. On dit que <strong>double</strong> a une précision double.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    float f =  1.234567891011121314;
    double d = 1.234567891011121314;
    long double ld = 1.234567891011121314;

    printf("f  = %.15f\n", f);
    printf("d  = %.15lf\n", d);
    printf("ld = %.15Lf\n", ld);

    return 0;
}
</code></pre>
<p>Ici, je veux te faire comprendre la différence entre <strong>float</strong> et <strong>double</strong>.</p>
<p><strong>float</strong> a une précision de 7 chiffres après la virgule, là où <strong>double</strong> a une
précision de 15 chiffres après la virgule.</p>
<p>Dans le printf, j'utilise la notation <strong>%.15f</strong> pour demander à printf de
m'afficher 15 chiffres après la virgule, même à <strong>float</strong>.</p>
<p>Comme tu peux le voir, au bout de quelques chiffres, la valeur affichée n'est
pas du tout la même que celle affectée dans le code.</p>
<p>Voici un tableau récapitulatif sur l'utilisation de float et double.</p>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Octets</th></tr></thead><tbody>
<tr><td>float</td><td>4</td></tr>
<tr><td>double</td><td>8</td></tr>
<tr><td>long double</td><td>16</td></tr>
</tbody></table>
</div>
<p>Si <strong>long double</strong> peut prendre 128 bis même sur une architecture 64 bits, c'est
parce qu'une partie est utilisée pour la précision, c'est à dire le nombre de
chiffres possible derrière la virgule.</p>
<h3 id="caractère"><a class="header" href="#caractère">Caractère</a></h3>
<p>Il existe un type pour les caractères : <strong>char</strong>.</p>
<p>Tu peux l'utiliser comme un entier pour avancer dans l'alphabet.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    char alpha = 'a'; // Des simple quotes, surtout pas des double quotes !
    printf("alpha = %c\n", alpha);
    printf("alpha = %d\n", alpha);
    alpha = alpha + 1;
    printf("alpha = %c\n", alpha);
    printf("alpha = %d\n", alpha);

    return 0;
}
</code></pre>
<p>Je vais devoir expliquer ce qu'il se passe ici un peu plus en détail.</p>
<pre><code class="language-text">$ gcc test.c -o mon_super_programme
$ ./mon_super_programme
alpha = a
alpha = 97
alpha = b
alpha = 98
$
</code></pre>
<p>le caractère 'a' est codé sur la valeur 97. Où trouver cette information ?</p>
<p>Dans le <strong>man ascii</strong>.</p>
<pre><code class="language-text">Oct   Dec   Hex   Char                        Oct   Dec   Hex   Char
────────────────────────────────────────────────────────────────────────
000   0     00    NUL '\0' (null character)   100   64    40    @
001   1     01    SOH (start of heading)      101   65    41    A
002   2     02    STX (start of text)         102   66    42    B
003   3     03    ETX (end of text)           103   67    43    C
004   4     04    EOT (end of transmission)   104   68    44    D
005   5     05    ENQ (enquiry)               105   69    45    E
006   6     06    ACK (acknowledge)           106   70    46    F
007   7     07    BEL '\a' (bell)             107   71    47    G
010   8     08    BS  '\b' (backspace)        110   72    48    H
011   9     09    HT  '\t' (horizontal tab)   111   73    49    I
012   10    0A    LF  '\n' (new line)         112   74    4A    J
013   11    0B    VT  '\v' (vertical tab)     113   75    4B    K
014   12    0C    FF  '\f' (form feed)        114   76    4C    L
015   13    0D    CR  '\r' (carriage ret)     115   77    4D    M
016   14    0E    SO  (shift out)             116   78    4E    N
017   15    0F    SI  (shift in)              117   79    4F    O
020   16    10    DLE (data link escape)      120   80    50    P
021   17    11    DC1 (device control 1)      121   81    51    Q
022   18    12    DC2 (device control 2)      122   82    52    R
023   19    13    DC3 (device control 3)      123   83    53    S
024   20    14    DC4 (device control 4)      124   84    54    T
025   21    15    NAK (negative ack.)         125   85    55    U
026   22    16    SYN (synchronous idle)      126   86    56    V
027   23    17    ETB (end of trans. blk)     127   87    57    W
030   24    18    CAN (cancel)                130   88    58    X
031   25    19    EM  (end of medium)         131   89    59    Y
032   26    1A    SUB (substitute)            132   90    5A    Z
033   27    1B    ESC (escape)                133   91    5B    [
034   28    1C    FS  (file separator)        134   92    5C    \  '\\'
035   29    1D    GS  (group separator)       135   93    5D    ]
036   30    1E    RS  (record separator)      136   94    5E    ^
037   31    1F    US  (unit separator)        137   95    5F    _
040   32    20    SPACE                       140   96    60    `
041   33    21    !                           141   97    61    a
042   34    22    "                           142   98    62    b
043   35    23    #                           143   99    63    c
044   36    24    $                           144   100   64    d
045   37    25    %                           145   101   65    e
046   38    26    &amp;                           146   102   66    f
047   39    27    '                           147   103   67    g
050   40    28    (                           150   104   68    h
051   41    29    )                           151   105   69    i
052   42    2A    *                           152   106   6A    j
053   43    2B    +                           153   107   6B    k
054   44    2C    ,                           154   108   6C    l
055   45    2D    -                           155   109   6D    m
056   46    2E    .                           156   110   6E    n
057   47    2F    /                           157   111   6F    o
060   48    30    0                           160   112   70    p
061   49    31    1                           161   113   71    q
062   50    32    2                           162   114   72    r
063   51    33    3                           163   115   73    s
064   52    34    4                           164   116   74    t
065   53    35    5                           165   117   75    u
066   54    36    6                           166   118   76    v
067   55    37    7                           167   119   77    w
070   56    38    8                           170   120   78    x
071   57    39    9                           171   121   79    y
072   58    3A    :                           172   122   7A    z
073   59    3B    ;                           173   123   7B    {
074   60    3C    &lt;                           174   124   7C    |
075   61    3D    =                           175   125   7D    }
076   62    3E    &gt;                           176   126   7E    ~
077   63    3F    ?                         │ 177   127   7F    DEL
</code></pre>
<p>La première colonne est la valeur en <strong>octal</strong> (base 8), la deuxième en base 10,
la troisième en base 16 et enfin la dernière le caractère codé derrière ces
valeurs.</p>
<p>Tu peux retrouver le 'a' minuscule à la valeur 97.</p>
<p>Retiens bien ça, ça sera très important pour la suite de ton cursus.</p>
<div class="table-wrapper"><table><thead><tr><th>Nom</th><th>Octets</th><th>Valeurs</th></tr></thead><tbody>
<tr><td>char</td><td>1</td><td>-128 à 127</td></tr>
<tr><td>unsigned char</td><td>1</td><td>0 à 255</td></tr>
</tbody></table>
</div>
<h3 id="void"><a class="header" href="#void">Void</a></h3>
<p><strong>void</strong> est un type particulier qui signifie <strong>pas de type</strong>. Il n'a pas de
taille.</p>
<p>Tu verras plus tard comment il est utilisé.</p>
<h4 id="sizeof"><a class="header" href="#sizeof">sizeof</a></h4>
<p>Pour avoir la taille d'un type, tu peux utiliser la macro <strong>sizeof</strong>. Elle te
donne en octet la taille prise par le type donné en paramètre. Pour information,
sizeof renvoie un <strong>long unsigned int</strong>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    printf("sizeof (char): %lu\n", sizeof (char));
    printf("sizeof (char*): %lu\n", sizeof (char*));

    printf("sizeof (int): %lu\n", sizeof (int));
    printf("sizeof (int*): %lu\n", sizeof (int*));
    printf("sizeof (short int): %lu\n", sizeof (short int));
    printf("sizeof (long int): %lu\n", sizeof (long int));
    printf("sizeof (long long int): %lu\n", sizeof (long long int));
    printf("sizeof (long long int*): %lu\n", sizeof (long long int*));

    printf("sizeof (float): %lu\n", sizeof (float));
    printf("sizeof (float*): %lu\n", sizeof (float*));

    printf("sizeof (double): %lu\n", sizeof (double));
    printf("sizeof (long double): %lu\n", sizeof (long double));
    printf("sizeof (long double*): %lu\n", sizeof (long double*));

    printf("sizeof (void*): %lu\n", sizeof (void*));

    return 0;
}
</code></pre>
<pre><code class="language-text">$ gcc test.c -o mon_super_programme
$ ./mon_super_programme
sizeof (char): 1
sizeof (char*): 8
sizeof (int): 4
sizeof (int*): 8
sizeof (short int): 2
sizeof (long int): 8
sizeof (long long int): 8
sizeof (long long int*): 8
sizeof (float): 4
sizeof (float*): 8
sizeof (double): 8
sizeof (long double): 16
sizeof (long double*): 8
sizeof (void*): 8
$
</code></pre>
<p>Les valeurs avec des étoiles '*' sont ce qu'on appelle des <strong>pointeurs</strong>. Tu
verras ce que c'est plus tard. Sache qu'un pointeur fait <strong>toujours</strong> 8 octets.</p>
<h2 id="chaines-de-caractères"><a class="header" href="#chaines-de-caractères">Chaines de caractères</a></h2>
<p>Je ne vais pas encore détailler ce qu'est une chaine de caractères, mais je vais
te montrer comment en créer que tu puisses jouer avec.</p>
<pre><code class="language-c">char *string = "My name Lules. Gé Lules";

printf("string: %s\n", string);
</code></pre>
<p>Comme tu peux le voir, ça utilise le mot-clé <strong>char</strong> de caractère, mais avec
l'utilisation d'un pointeur en plus. Et tu dois définir ta chaine de caractères
entre guillements.</p>
<p>Sache juste que tu ne peux pas modifier les chaines de caractères définies de
cette manière. Tu verras comment réellement jouer avec plus tard.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fonctions"><a class="header" href="#fonctions">Fonctions</a></h1>
<p>Une fonction est un bout de code que tu peux appeler quand tu veux.</p>
<p>Une fonction possède un identifiant (un nom), un type de retour et une entrée
pour des paramètres. C'est ce qu'on appelle la <strong>signature</strong>.</p>
<p>Voici comment définir une fonction et sa <strong>portée</strong> (la zone qui délimite le
début et la fin du code qui sera exécuté).</p>
<p>Les variables déclarées et définies dans une fonction ne sont vivantes que
pendant l'exécution de cette fonction. Au <strong>retour</strong> d'une fonction, toutes les
variables disparaissent.</p>
<pre><code class="language-c">type identifiant(type_param1 param1, type_param2 param2)
{
}
</code></pre>
<p>Tu n'es pas obligé de mettre des paramètres ou de valeurs de retour. Tu peux
utiliser le type <strong>void</strong> pour ça.</p>
<pre><code class="language-c">
// Ne retourne rien et ne prend rien en entrée
void fonction_1(void)
{
}

// Retourne un float et ne prend rien en entrée
float fonction_2(void)
{
}

// Ne retourne rien et prend un entier en entrée
void fonction_3(int entier)
{
}

// Retourne un caractère et prend 1 float et 1 caractère en entrée
char fonction_4(float flottant, char caractere)
{
}
</code></pre>
<p>Comme avec la fonction main, il ne te reste plus qu'à mettre le code entre les
accolades.</p>
<p>Attention, si tu veux créer une fonction, pour le moment écrit la au dessus de
la fonction main.</p>
<p>Le compilateur est un outil puissant mais pas très intelligent. Si ta fonction
main appelle la fonction <strong>fonction_1</strong>, elle doit être <strong>définie</strong> au dessus de
la fonction main pour qu'il sache qu'elle existe déjà. Si elle est en dessous,
il te dira qu'il ne trouve pas ta fonction. Le compilateur lit un code source
comme nous : de gauche à droite de haut en bas.</p>
<p>Crée une fonction qui prend deux entiers en entrée et retourne l'addition des
deux.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int addition(int a, int b)
{
    return a + b;
}

int main(void)
{
    int val_1 = 42;
    int val_2 = 51;
    int result = addition(val_1, val_2);

    printf("result = %d\n", result);

    return 0;
}
</code></pre>
<p>Bravo ! Tu viens de créer ta première fonction. Quelle fierté. Tant d'autres
t'attendent déjà.</p>
<p>Le positionnement des variables est important. <strong>val_1</strong> enverra sa valeur à
<strong>a</strong> et <strong>val_2</strong> enverra sa valeur à <strong>b</strong>.</p>
<p>Il faut que les variables que tu envoies soient du même type. Si j'avais défini
<strong>val_1</strong> comme étant un <strong>float</strong>, mon code aurait été faux.</p>
<p>Petit exercice pratique : Crée 4 fonctions pour les 4 opérations mathémathiques
que tu as appris plus jeune : addition, soustraction, multiplication et
division.</p>
<p>Voici une correction... sera t-il parfaite ?</p>
<pre><code class="language-c">int addition(int a, int b)
{
    return a + b;
}

int soustraction(int a, int b)
{
    return a - b;
}

int multiplication(int a, int b)
{
    return a * b;
}

int division(int a, int b)
{
    return a / b;
}
</code></pre>
<p>Penses-tu que tout fonctionne correctement avec ce que tu connais des
mathématiques ?</p>
<p>Il y a une <em>petite</em> erreur : si tu envoies <strong>0</strong> en deuxième paramètre à la
fonction <strong>division</strong>, il y aura une <strong>division par 0</strong>.</p>
<p>Voici une correction possible : si b vaut 0, alors on retourne 0.</p>
<pre><code class="language-c">int division(int a, int b)
{
    if (b == 0)
    {
        return 0;
    }

    return a / b;
}
</code></pre>
<p>Pour tester une égalité, tu dois utiliser la double égalité '=='. Avant que tu
n'essaies, non, ça ne fonctionne pas avec les chaines de caractères. Mais ça
fonctionne sur les caractères uniques.</p>
<p>Tu verras plus tard comment agrémenter ton code de tests et conditions.</p>
<h3 id="quitter-une-fonction-qui-ne-renvoie-rien"><a class="header" href="#quitter-une-fonction-qui-ne-renvoie-rien">Quitter une fonction qui ne renvoie rien</a></h3>
<p>Si tu fois quitter une fonction qui ne renvoie rien (void), tu peux utiliser le
mot-clé <strong>return</strong> seul.</p>
<pre><code class="language-c">void positive_printer(int n)
{
    if (n &lt; 0)
    {
        return;
    }

    printf("n: %d\n");
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mathématiques-1"><a class="header" href="#mathématiques-1">Mathématiques</a></h1>
<p>Tu viens de voir précédemment comment faire des opérations arithématiques
simples avec l'addition, la soustraction, la multiplication et la division. Mais
il reste quelques particularité à découvrir.</p>
<h2 id="modulo"><a class="header" href="#modulo">Modulo</a></h2>
<p>Tu vas vu la division, mais tu n'as pas encore vu le reste de la division.</p>
<p>Tu dois utiliser le caractère <strong>%</strong>.</p>
<pre><code class="language-c">int valeur = 666;
int diviseur = 111;
int reste = valeur % diviseur;

printf("reste de %d par %d = %d%d\n", valeur, diviseur, reste);
</code></pre>
<h3 id="parité"><a class="header" href="#parité">Parité</a></h3>
<p>Si tu veux savoir si un nombre est pair ou impair, tu peux vérifier le reste de
la division par 2. S'il reste 0 alors le nombre est pair, s'il reste 1, alors
le nombre est impair.</p>
<pre><code class="language-c">int pair = 10;
int impair = 11;

int reste = pair % 2;
printf("%d\n", reste);

reste = impair % 2;
printf("%d\n", reste);
</code></pre>
<h2 id="sucre-syntaxique"><a class="header" href="#sucre-syntaxique">Sucre syntaxique</a></h2>
<p>Pour ajouter une valeur à une variable en C, tu serais très tenté de l'écrire de
cette façon :</p>
<pre><code class="language-c">int i = 0;

// Du code...

i = i + 1;
</code></pre>
<p>Mais tu peux l'écrire plus rapidement de cette façon :</p>
<pre><code class="language-c">int i = 0;

// Du code...

i += 1; // =&gt; i = i + 1
</code></pre>
<p>Ca revient à la même chose. Tu peux évidemment mettre un autre signe que le
signe '+' et n'importe quelle expression à droite du égal.</p>
<p>Si tu veux par exemple diviser une valeur par 10 :</p>
<pre><code class="language-c">int valeur = 5467;

// Du code

valeur /= 10; // =&gt; valeur = valeur / 10
</code></pre>
<p>C'est ce qu'on appelle du sucre syntaxique. La syntaxe est adoucit pour la
rendre plus agréable.</p>
<h2 id="pré-incrémentation-et-post-incrémentation"><a class="header" href="#pré-incrémentation-et-post-incrémentation">pré-incrémentation et post-incrémentation</a></h2>
<p>Tu peux écrire encore plus rapidement une incrémentation en C avec l'opérateur
<strong>++</strong>.</p>
<pre><code class="language-c">int i = 0;

// Du code

i++; // =&gt; i = i + 1

// Du code

++i; // =&gt; i = i + 1
</code></pre>
<p>Il y a cependant une différence entre les deux.</p>
<p>La première forme, i++, est une pré-incrémentation. Une autre variable peut
récupérer la valeur de <strong>i</strong> avant que <strong>i</strong> ne s'incrémente.</p>
<p>La deuxième forme, ++i, est une post-incrémentation. <strong>i</strong> va s'incrémenter et
<strong>après</strong> ça, une autre variable peut récupérer la nouvelle valeur de <strong>i</strong>.</p>
<p>Voici un exemple :</p>
<pre><code class="language-c">int i = 10;

printf("i: %d\n", i);

int j = i++; // =&gt; j = 10 ; i = 11

printf("i: %d | j = %d\n", i, j);

int k = ++i; // =&gt; k = 12 ; i = 12

printf("i: %d | k = %d\n", i, k);
</code></pre>
<p>Tu peux faire la même logique avec l'opérateur de soustraction '-'.</p>
<h2 id="bitwise"><a class="header" href="#bitwise">Bitwise</a></h2>
<h3 id="logic-bit"><a class="header" href="#logic-bit">Logic bit</a></h3>
<p>En plus de faire des opérations sur les variables, tu peux faire des opérations
directement sur leurs bits.</p>
<p>Voici les portes logiques que tu connais en C :</p>
<ul>
<li>~ : NOT</li>
<li>&amp; : AND</li>
<li>| : OR</li>
<li>^ : XOR</li>
</ul>
<pre><code class="language-c">int maximum = ~0; // =&gt; NOT(00000000000000000000000000000000) =  11111111111111111111111111111111 = 4294967295

int op_and = 42 &amp; 51; //       101010
                      // AND
                      //       110011
                      //       ======
                      //       100010 = 34
printf("op_and = %d\n", op_and);

int op_or = 42 | 51; //        101010
                     // OR
                     //        110011
                     //        ======
                     //        111011 = 51
printf("op_or = %d\n", op_or);

int op_xor = 42 ^ 51; //       101010
                      // XOR
                      //       110011
                      //       ======
                      //       011001 = 25
printf("op_xor = %d\n", op_xor);
</code></pre>
<h3 id="shifting"><a class="header" href="#shifting">Shifting</a></h3>
<p>Tu peux aussi décaler des bits sur la gauche et sur la droite.</p>
<p>Prenons la valeur 42 en binaire, codée sur un int (4 octets, donc 32 bits).</p>
<pre><code class="language-text">00000000000000000000000000101010
</code></pre>
<p>Avec les opérateurs <strong>&lt;&lt;</strong> et <strong>&gt;&gt;</strong>, je peux décaler les bits sur la gauche et
sur la droite. Attention si un bit disparaît d'un côté, il ne réapparait pas de
l'autre.</p>
<pre><code class="language-c">int valeur = 42;      // valeur = 00000000000000000000000000101010 = 42

valeur = valeur &lt;&lt; 1; // valeur = 00000000000000000000000001010100 = 84

valeur = valeur &lt;&lt; 2; // valeur = 00000000000000000000000101010000 = 336

valeur = valeur &gt;&gt; 5; // valeur = 00000000000000000000000000001010 = 10

valeur = valeur &lt;&lt; 1; // valeur = 00000000000000000000000000010100 = 20
</code></pre>
<p>Tu peux aussi écrire ces instructions de ces façons :</p>
<pre><code class="language-c">valeur &lt;&lt;= 2;
valeur &gt;&gt;= 2;
</code></pre>
<h2 id="linverseur-logique"><a class="header" href="#linverseur-logique">L'inverseur logique</a></h2>
<p>Il existe un deuxième opérateur d'inversion en C qui est le point d'exclamation
'!'. Celui-ci n'inverse pas les valeurs des bits mais la <strong>véracité</strong> d'une
variable.</p>
<p>En C, la valeur 0 vaut <strong>Faux</strong> et n'importe quelle autre valeur vaut <strong>Vrai</strong>.
C'est exactement l'inverse du shell.</p>
<p>Voici comment l'utiliser :</p>
<pre><code class="language-c">int zero = 0;
int one = 1;
int two = 2;

zero = !zero; // =&gt; zero = 1
one = !one;   // =&gt; one = 0
two = !two;   // =&gt; two = 0

zero = !zero; // =&gt; zero = 0
one = !one;   // =&gt; one = 1
two = !two;   // =&gt; two = 1
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures-de-contrôles"><a class="header" href="#structures-de-contrôles">Structures de contrôles</a></h1>
<p>Faire du code, c'est bien. Faire du code qui n'exécute pas toujours la même
chose, c'est mieux.</p>
<p>Tu vas apprendre ici à créer des conditions en C.</p>
<h2 id="if-else"><a class="header" href="#if-else">if else</a></h2>
<p>Le C n'a que deux mot-clés pour créer des conditions, là où le shell en a trois.</p>
<p>Le mot-clé <strong>if</strong> prend en compte une condition, le mot-clé <strong>else</strong> n'en prend
pas <strong>sauf</strong> s'il est suivi d'un <strong>if</strong>, ce qui donne la construction <strong>else
if</strong>.</p>
<p>Tu ne peux pas facilement faire des comparaisons de chaines de caractères comme
en shell, en C tout se fait avec des entiers. Mais tu peux tester des chaines de
caractères avec des fonctions de la bibliothèque C qui vont retourner des
entiers pour dire <strong>Vrai</strong> ou <strong>Faux</strong>.</p>
<h3 id="entiers-1"><a class="header" href="#entiers-1">Entiers</a></h3>
<p>Pour tester des entiers, tu peux utiliser les opérateurs :</p>
<ul>
<li>&lt; : strictement inférieur</li>
<li>&lt;= : inférieur ou égal</li>
<li>== : égal</li>
<li>!= : différent</li>
<li>&gt;= : supérieur ou égal</li>
<li>&gt; : strictement supérieur</li>
</ul>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main(void)
{
    int secret = 42;
    int guess = atoi(argv[1]);

    if (guess &lt; secret)
    {
        printf("Plus grand\n");
    }
    else if (guess &gt; secret)
    {
        printf("Plus petit");
    }
    else // Si ce n'est ni plus petit ni plus grand, alors c'est égal
    {
        printf("Bien deviné !");
    }

    return !(guess == secret);
}
</code></pre>
<p>La dernière ligne doit être décortiquée.</p>
<pre><code class="language-c">(guess == secret)
</code></pre>
<p>retourne 1 si c'est <strong>Vrai</strong> et 0 si c'est <strong>Faux</strong>.</p>
<p>L'opérateur d'inversion '!' va inverser la valeur logique.</p>
<pre><code class="language-c">// Dans le cas où guess == secret

!(guess == secret) // =&gt; !(1)
!(1) // =&gt; 0

// Dans le cas où guess != secret
!(guess != secret) // =&gt; !(0)
!(0) // =&gt; 1
</code></pre>
<p>Pourquoi faire ça ?</p>
<p>Parce qu'en shell, 0 est Vrai et autre chose que 0 est Faux. Donc pour garder
une cohérence avec le shell qui va recevoir la valeur de retour de ton
programme, j'ai besoin que l'exit status soit à 0 si le nombre deviné est bon et
que l'exit status soit à 1 si le nombre deviné n'est pas le bon.</p>
<h3 id="chaines-de-caractères-1"><a class="header" href="#chaines-de-caractères-1">Chaines de caractères</a></h3>
<p>Si tu veux tester deux chaines de caractères, tu peux utiliser la fonction
<strong>strcmp</strong>. Je t'invite à lire le man de cette fonction <strong>man 3 strcmp</strong>,
spécialement la fin du manuel ;)</p>
<p>Elle prend deux chaines de caractères en paramètres, retourne 0 si les deux sont
égales, une valeur négative si la première chaine de caractères est
<strong>alphabétiquement</strong> plus petite que la deuxième, une valeur positive dans le
cas inverse.</p>
<p>L'ordre alphabétique est basée sur la table ASCII que tu as vu précédemment.</p>
<p>Ainsi</p>
<pre><code class="language-c">char *s1 = "a";
char *s2 = "B";
</code></pre>
<p>s2 est plus petit que s1, car dans la table ASCII, 'B' vient avant 'a'.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main(int argc, char *argv[])
{
    char *secret = "pediluve";
    char *guess = argv[1];
    int result = strmpc(guess, secret);

    if (result != 0)
    {
        printf("Mauvais mot de passe\n");
    }
    else
    {
        printf("Bon mot de passe\n");
    }

    return result;
}
</code></pre>
<p>Attention, rappelle toi quand même qu'en shell, l'exit status va de 0 à 255, si
tu retournes une valeur négative, elle sera transformée en une autre valeur.</p>
<h2 id="switch"><a class="header" href="#switch">switch</a></h2>
<p>Pour éviter de faire des <strong>if else</strong> à rallonge, tu peux tester une variable sur
un <strong>switch</strong> et faire un code beaucoup plus élégant et agréable à lire.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// Ici un ensemble de fonctions

int main(int argc, char *argv[])
{
    int choice = atoi(argv[1]);

    switch (choice)
    {
        case -1:
            printf("En route pour le donjon :\n");
            dungeon();
            break;
        case 0:
            printf("Vous êtes déjà dans le lobby\n");
            break;
        case 1:
            printf("En route pour la tour !\n");
            tower();
            break;
        case 666:
            printf("En route pour le boss\n");
            boss();
            break;
        default:
            printf("Je ne peux accéder à votre requête\n");
    }

    return 0;
}
</code></pre>
<p>Tu peux voir que c'est beaucoup plus lisible qu'un enchaînement de <strong>if else</strong>.</p>
<p>Le mot-clé <strong>break</strong> sert à partir du <strong>switch</strong> si un des cas était <strong>Vrai</strong> et
pour éviter de tester les autres cas suivants.</p>
<p>Le mot-clé <strong>default</strong> agit comme un <strong>else</strong>, si tous les cas précédents
étaient faux, alors le code de <strong>default</strong> sera exécuté.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tableaux"><a class="header" href="#tableaux">Tableaux</a></h1>
<p>Un tableau est une collection de valeurs du même type. On peut accéder aux
éléments par des index.</p>
<p>Un tableau se crée ainsi :</p>
<pre><code class="language-text">type nom_tableau[nombre_elements] = { valeur_1, valeur_2, valeur_3 };
</code></pre>
<p>On peut mettre autant d'éléments que l'on veut.</p>
<h2 id="tableaux-de-types-simples"><a class="header" href="#tableaux-de-types-simples">Tableaux de types simples</a></h2>
<p>Pour créer un tableau d'entiers, de floats ou de char, il suffit de remplir le
tableau avec les bonnes valeurs.</p>
<pre><code class="language-c">int variable = 666;
int levels[6] = {0, 1, -1, 2600, variable, 42 };

char alpha[3] = {'x', 'y', 'z'};
</code></pre>
<p>Pour accéder à un élément du tableau, il suffit d'utiliser cette notation :</p>
<pre><code class="language-c">element = array[index];
</code></pre>
<p>A savoir : l'index commence <strong>toujours</strong> à 0.</p>
<p>Ainsi si je reprends le tableaux levels, il faut le lire avec les index suivants
:</p>
<div class="table-wrapper"><table><thead><tr><th>Index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th></tr></thead><tbody>
<tr><td>Valeur</td><td>0</td><td>1</td><td>-1</td><td>2600</td><td>666</td><td>42</td></tr>
</tbody></table>
</div>
<p>Ainsi, pour accéder à un élémeent d'un tableau de type <strong>int</strong> :</p>
<pre><code class="language-c">int levels[6] = {0, 1, -1, 2600, variable, 42 };

int level = levels[2]; // =&gt; level = -1

levels[0] = 21; // array = 21 1 -1 2600 666 42
</code></pre>
<p>Attention à ne pas utiliser un index plus grand que le nombre d'éléments dans le
tableau. Si tu dépasses, tu récupéreras une valeur ailleurs en mémoire, que tu
ne contrôles pas.</p>
<h4 id="tableau-à-zéro"><a class="header" href="#tableau-à-zéro">Tableau à zéro</a></h4>
<p>Si tu veux remplir une partie du tableau et laisser le reste à 0 ou même
l'initialiser complètement à 0, tu n'es pas obligé de tout définir, le
compilateur va pour toi mettre la partie non définie à 0.</p>
<pre><code class="language-c">int array_1[10] = { 1, 1, 1 }; // =&gt; 1 1 1 0 0 0 0 0 0 0
int array_2[10] = { 0 }; // =&gt; 0 0 0 0 0 0 0 0 0 0
</code></pre>
<h4 id="nombre-déléments-calculé-à-la-compilation"><a class="header" href="#nombre-déléments-calculé-à-la-compilation">Nombre d'éléments calculé à la compilation</a></h4>
<p>Si tu ne sais pas combien d'éléments ton tableau va recevoir, tu n'es pas obligé
de mettre une taille, le compilateur comptera le nombre d'éléments que tu as
écrit entre les accolades.</p>
<pre><code class="language-c">int array[] = { 1, 2, 3, 4, 5 }; // =&gt; 5 éléments
</code></pre>
<h3 id="taille-dun-tableau"><a class="header" href="#taille-dun-tableau">Taille d'un tableau</a></h3>
<p>Pour avoir la taille utilisée par un tableau en mémoire, tu peux utiliser
l'opérateur que tu connais, <strong>sizeof</strong>.</p>
<p>A ton avis, combien d'octets prend en mémoire un tableau de type <strong>int</strong> à
<strong>10</strong> éléments ?</p>
<p>Si un <strong>int</strong> utilise 4 octets, alors 10 <strong>int</strong> vont en utiliser 10 fois plus,
donc 40 octets.</p>
<pre><code class="language-c">int array[10] = { 0 };
int size = sizeof (array);

printf("size of array: %lu\n", size);
</code></pre>
<h3 id="nombre-déléments-dans-un-tableau"><a class="header" href="#nombre-déléments-dans-un-tableau">Nombre d'éléments dans un tableau</a></h3>
<p>Pour savoir le nombre d'éléments dans un tableau sans compter un par un, on peut
utiliser <strong>sizeof</strong>.</p>
<pre><code class="language-c">int array[] = { beaucoup mais alors vraiment beaucoup de valeurs };

int nbr_elements = sizeof (array) / sizeof (array[0]);
</code></pre>
<p>Que fait-on exactement ?</p>
<p><strong>sizeof (array)</strong> donne la taille du tableau en octets</p>
<p><strong>sizeof (array[0])</strong> donne la taille d'un élément du tableau en octets</p>
<p>Si on divise la taille totale par la taille d'un élément, nous avons bien le
nombre d'éléments dans un tableau.</p>
<p>On utilise <strong>array[0]</strong> car on ne sait pas combien d'éléments a le tableau, mais
étant donné qu'il doit en avoir au moins 1, on utilise tout simpelemnt le
premier qui est obligatoirement existant.</p>
<h2 id="tableaux-pour-chaines-de-caractères"><a class="header" href="#tableaux-pour-chaines-de-caractères">Tableaux pour chaines de caractères</a></h2>
<p>Je t'avais dis que pour faire une chaîne de caractères, tu devais écrire :</p>
<pre><code class="language-c">char *text = "salut les loulous";
</code></pre>
<p>et que cette chaîne de caractères est constante et que tu ne peux pas la
modifier.</p>
<p>Tu peux utiliser la notation de tableau pour avoir une chaîne de caractères que
tu peux modifier.</p>
<pre><code class="language-c">char text[] = "salut les poutous";
printf("%s\n", text);
text[10] = 'l';
text[13] = 'l';
printf("%s\n", text);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chaîne-de-caractères"><a class="header" href="#chaîne-de-caractères">Chaîne de caractères</a></h1>
<p>Il y a une chose que je n'ai pas mentionnée quant aux chaînes de caractères,
c'est comment elles sont réellement construites par le compilateur.</p>
<p>Quand <strong>printf</strong> affiche ta chaîne, il ne peut pas calculer la taille avec la
technique de <strong>sizeof</strong>.</p>
<p>Pour ça, le compilateur va ajouter une valeur très spéciale à la fin de la
chaîne de caractères, la valeur <strong>\0</strong>.</p>
<p>Ainsi en <strong>parcourant</strong> ta chaîne de caractères, <strong>printf</strong> sait où s'arrêter :
une fois qu'il a atteind <strong>\0</strong>.</p>
<p>Voici comment est en mémoire une chaîne de caractères.</p>
<p>Pour la chaîne de caractères suivante :</p>
<pre><code class="language-c">char text[] = "coucou";
</code></pre>
<div class="table-wrapper"><table><thead><tr><th>Index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody>
<tr><td>Valeur</td><td>c</td><td>o</td><td>u</td><td>c</td><td>o</td><td>u</td><td>\0</td></tr>
</tbody></table>
</div>
<p>Tu peux voir dans le <strong>man 1 ascii</strong> que le caractère <strong>\0</strong> a la valeur <strong>0</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointeurs"><a class="header" href="#pointeurs">Pointeurs</a></h1>
<p>Il est dit par certains que la notion de pointeur est ce qu'il y a de plus
difficile à comprendre en C. Aussi, tu vas répéter avec moi ces quelques
phrases.</p>
<p><strong>Un pointeur est une adresse.</strong></p>
<p><strong>Un pointeur est une adresse.</strong></p>
<p><strong>Un pointeur est une adresse.</strong></p>
<p>Et pour être un peu plus correct.</p>
<p><strong>Un pointeur est une adresse sur un type.</strong></p>
<p><strong>Un pointeur est une adresse sur un type.</strong></p>
<p><strong>Un pointeur est une adresse sur un type.</strong></p>
<p>Voilà. Maintenant tu vas voir, les pointeurs, c'est pas si terrible.</p>
<h2 id="mémoire"><a class="header" href="#mémoire">Mémoire</a></h2>
<p>Il faut comprendre que quand tu exécutes ton programme, il est copié dans la RAM
de ton PC. Tout est dans une <strong>mémoire virtuelle</strong>. Qui va de 0 à 2<sup>64</sup>.</p>
<p>La mémoire fonctionne comme un tableau. Il y a l'adresse 0, puis 1, puis 2, ...</p>
<p>Et dans ces cases mémoires, se trouvent tout ton programme, avec les valeurs de
tes variables.</p>
<h2 id="initialiser-un-pointeur-à-zéro"><a class="header" href="#initialiser-un-pointeur-à-zéro">Initialiser un pointeur à zéro</a></h2>
<p>Avant d'utiliser un pointeur, tu vas voir comment initialiser unpointeur <em>à
zéro</em>.</p>
<p>Pour cela, tu vas lui affecter la valeur <strong>NULL</strong>. C'est un <em>alias</em> sur un
pointeur sur void à la valeur 0. C'est à dire (void *)0.</p>
<pre><code class="language-c">int *ptr = NULL;
</code></pre>
<p>Voilà, si tu ne sais pas encore où pointera ton pointeur, par sécurité, met le à
NULL.</p>
<h2 id="afficher-ladresse-dune-variable"><a class="header" href="#afficher-ladresse-dune-variable">Afficher l'adresse d'une variable</a></h2>
<p>Pour afficher l'adresse d'une variable, on va utiliser l'opérateur <strong>&amp;</strong>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int value = 42;
    void *addr_value = &amp;value;

    printf("Adresse de value = %p\n", addr_value);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Adresse de value = 0x7ffd2cd0df1c
$
</code></pre>
<p>Comme tu peux le voir, le pointeur <strong>addr_value</strong> a comme valeur une adresse.</p>
<p><strong>Un pointeur est une adresse.</strong></p>
<p>Une valeur qui commence par <strong>0x</strong> est de l'hexadécimal.</p>
<p>Tu auras très probablement une autre valeur affichée. D'ailleurs chaque
exécution <em>devrait</em> t'afficher une valeur différente (c'est une sécurité mise en
place par Linux).</p>
<h2 id="déréférencement"><a class="header" href="#déréférencement">Déréférencement</a></h2>
<p>C'est là où ça devient difficile.</p>
<p>Rappelle toi : <strong>Un pointeur est une adresse sur un type.</strong></p>
<p>Reprenons le code précédent, je vais le modifier un peu. Le code précédent
servait à avoir l'adresse de <strong>value</strong>, ici je vais avoir un pointeur sur le
<strong>type</strong> int pour récupérer sa valeur autrement que par <strong>value</strong>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int value = 42;
    int *ptr_value = &amp;value;

    return 0;
}
</code></pre>
<p><strong>value</strong> est une variable qui vaut 42. Cette variable a une valeur enregistrée
dans une adresse.</p>
<p><strong>addr_value</strong> est un pointeur. Sa valeur est une adresse, celle où se trouve la
valeur de <strong>value</strong>.</p>
<p>Pour pouvoir accéder à la case mémoire qui contient <strong>42</strong> depuis un pointeur,
il faut le déréférencer.</p>
<p>Rappelle toi, la mémoire fonctionne <strong>comme un tableau</strong>.</p>
<p>Un pointeur sur un int, tu peux le voir comme un tableau de int à un élément.</p>
<p>Tu peux donc utiliser ptr_value[0] pour accéder à la valeur 42.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int value = 42;
    int *ptr_value = &amp;value;

    printf("Valeur de value = %d\n", ptr_value[0]);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Valeur de value = 42
$
</code></pre>
<h3 id="encore-du-sucre-syntaxique"><a class="header" href="#encore-du-sucre-syntaxique">Encore du sucre syntaxique</a></h3>
<p>Tu verras dans d'autres cours que pour déréférencer un pointeur, il faut
utiliser, avec mon exemple, l'écriture suivant : <strong>*ptr_value</strong></p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int value = 42;
    int *ptr_value = &amp;value;

    printf("Valeur de value = %d\n", *ptr_value);

    return 0;
}
</code></pre>
<p>Le code est exactement le même. Parce que l'utilisation des crochets pour
l'accès tableau est du sucre syntaxique.</p>
<p>En réalite, quand tu écris <strong>array[0]</strong>, la mémoire utilise cette notation :
<strong>*(array + 0))</strong> qui est la même chose que <strong>*array</strong></p>
<p>Et quand tu écris <strong>array[1]</strong>, la mémoire utilise cette notation :
<strong>*(array + 1))</strong></p>
<p>Et quand tu écris <strong>array[2]</strong>, la mémoire utilise cette notation :
<strong>*(array + 2))</strong></p>
<p>etc.</p>
<p>L'opérateur * sert à déréférencer un pointeur pour accéder à la case mémoire
vers laquelle il pointe.</p>
<p>On peut ainsi <strong>modifier</strong> la valeur d'une variable depuis un pointeur.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int value = 42;
    int *ptr_value = &amp;value;

    *ptr_value = 2600; // Equivalent à "ptr_value[0] = 2600;"

    printf("Valeur de value = %d\n", *ptr_value);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Valeur de value = 2600
$
</code></pre>
<p>Bon c'est bien, mais c'est quoi l'utilité réelle des pointeurs ?</p>
<h2 id="lutilité-des-pointeurs"><a class="header" href="#lutilité-des-pointeurs">L'utilité des pointeurs</a></h2>
<p>Tu peux utiliser les pointeurs pour changer la valeur d'une ou plusieurs
variables dans une autre fonction.</p>
<p>Quand tu envoies une variable en paramètre d'une fonction, tu envoies en réalité
une copie locale. Si tu modifies la variable dans la fonction appelée, elle
reviendra à sa valeur d'origine dans la fonction appelante.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void example(int value)
{
    value = 2600;
    printf("Valeur de value = %d\n", value);
}

int main(void)
{
    int value = 42;
    printf("Valeur de value = %d\n", value);

    example(value);

    printf("Valeur de value = %d\n", value);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Valeur de value = 42
Valeur de value = 2600
Valeur de value = 42
$
</code></pre>
<p>Utilise la notion de pointeur pour modifier la valeur de value dans la fonction
example.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void example(int *value)
{
    *value = 2600;
    printf("Valeur de value = %d\n", *value);
}

int main(void)
{
    int value = 42;
    printf("Valeur de value = %d\n", value);

    example(&amp;value);

    printf("Valeur de value = %d\n", value);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Valeur de value = 42
Valeur de value = 2600
Valeur de value = 2600
$
</code></pre>
<h2 id="pointeurs-sur-caractères"><a class="header" href="#pointeurs-sur-caractères">Pointeurs sur caractères</a></h2>
<p>Voilà donc ce qu'il se cache derrière les pointeurs sur caractères. Au lieu de
n'avoir qu'une valeur en mémoire de type char, il y a plusieurs valeurs de type
char en mémoire les unes à la suite des autres, accessibles avec les crochets du
tableau.</p>
<pre><code class="language-c">char *ptr_char = "vive le c";
char array_char[] = "vive linux";
</code></pre>
<p>Le premier <strong>v</strong> de chaque chaînes de caractères est enregistré quelque part en
mémoire, et les autres lettres qui suivent sont à la suite dans la mémoire. On
utilise la notion de pointeurs pour accéder à ses valeurs.</p>
<p>La différence, c'est qu'un tableau possède une taille fixe en mémoire, alors
qu'un pointeur fait 8 octets, car il ne pointe que sur une valeur. Il peut
accéder aux prochaines valeurs comme un tableau mais est défini autrement en
mémoire.</p>
<h2 id="arithmétique-des-pointeurs-1ere-partie"><a class="header" href="#arithmétique-des-pointeurs-1ere-partie">Arithmétique des pointeurs, 1ere partie</a></h2>
<p>Tu peux changer la valeur d'un pointeur et te déplacer vers la suite de la
chaine.</p>
<p>Pour ça, il suffit d'incrémenter le pointeur.</p>
<pre><code class="language-c">char *str = "Encore des pointeurs";

printf("%c\n", *str); // =&gt; 'E'

str = str + 1;

printf("%c\n", *str); // =&gt; 'n'
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="boucles-1"><a class="header" href="#boucles-1">Boucles</a></h1>
<p>Les boucles sont un moyen de répéter du code autant de fois que nécessaire.</p>
<h2 id="while-1"><a class="header" href="#while-1">while</a></h2>
<p>La boucle while exécute du code tant que la condition est <strong>Vraie</strong>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int i = 0;

    while (i &lt; 10)
    {
        printf("%d\n", i);
        ++i;
    }

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
0
1
2
3
4
5
6
7
8
9
$
</code></pre>
<p>Si la condition est tout de suite <strong>Fausse</strong>, alors la boucle ne sera <strong>jamais</strong>
exécutée.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int i = 10;

    while (i &lt; 10)
    {
        printf("%d\n", i);
        ++i;
    }

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
$
</code></pre>
<h2 id="do-while"><a class="header" href="#do-while">do while</a></h2>
<p><strong>do while</strong> est une boucle qui va exécuter <strong>au moins une fois</strong> le code de la
boucle.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int i = 0;

    do
    {
        printf("%d\n", i);
        ++i;
    } while (i &lt; 10);

    return 0;
}
</code></pre>
<p>Note le point-virgule ';' à la toute fin de la ligne avec le <strong>while</strong>.</p>
<pre><code class="language-text">$ ./mon_super_programme
0
1
2
3
4
5
6
7
8
9
$
</code></pre>
<p>Le code sera <strong>toujours</strong> exécuté au moins une fois.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    int i = 10;

    do
    {
        printf("%d\n", i);
        ++i;
    } while (i &lt; 10);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
10
$
</code></pre>
<h2 id="for-1"><a class="header" href="#for-1">for</a></h2>
<p>Une boucle <strong>for</strong> est séparée en trois instructions.</p>
<ul>
<li><strong>INITIALISATION</strong> qui est exécutée une seule fois au tout début de la boucle</li>
<li><strong>CONDITION</strong> qui est testée à chaque itération</li>
<li><strong>INSTRUCTION</strong> qui est exécutée à chaque itération après le test de la condition, sauf la première fois</li>
</ul>
<pre><code class="language-c">for (INITIALISATION; CONDITION; INSTRUCTION)
{
    // Le code
}
</code></pre>
<p>Note qu'il y a une séparation avec des point-virgules ';'.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int main(void)
{
    for (int i = 0; i &lt; 10; ++i)
    {
        printf("%d\n", i);
    }

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
0
1
2
3
4
5
6
7
8
9
$
</code></pre>
<p>Tu peux aussi t'en servir pour <strong>parcourir</strong> les chaînes de caractères.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

int my_strlen(char *str)
{
    int result = 0;
    for (int i = 0; str[i] != '\0'; ++i)
    {
        ++result;
    }

    return result;
}

int main(void)
{
    char *ptr = "coucou les loulous";
    int ptr_size = my_strlen(ptr);

    printf("Longueur de '%s' = %d\n", ptr, ptr_size);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Longueur de 'coucou les loulous' = 18
$
</code></pre>
<p>Ici tu recodes la fonction <strong>strlen</strong> qui retourne le nombre de caractères dans
une chaîne de caractères.</p>
<p>Je t'invite à lire <strong>man 3 strlen</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="exercices"><a class="header" href="#exercices">Exercices</a></h1>
<p>Voici une liste d'exercices pour t'entrainer sur tout ce que tu as vu.</p>
<p>Les corrections sont au prochain chapitre.</p>
<h2 id="fonctions-simples"><a class="header" href="#fonctions-simples">Fonctions simples</a></h2>
<p>Ecris le code des fonctions suivantes pour additionner, soustraire, multiplier
et diviser des entiers ensemble.</p>
<p>Attention, si tu viens à diviser par 0, retourne 0.</p>
<pre><code class="language-c">int addition(int a, int b);

int substraction(int a, int b);

int multiplication(int a, int b);

int divide(int a, int b);
</code></pre>
<p>Ecris le code des fonctions and, or, xor, not qui retournent les opérations
bitwises correspondantes.</p>
<pre><code class="language-c">int and(int a, int b);

int or(int a, int b);

int xor(int a, int b);

int not(int a);
</code></pre>
<p>Ecris le code qui retourne le double, le carré et le cube d'un entier.</p>
<pre><code class="language-c">int double_int(int a);

int square(int a);

int cube(int a);
</code></pre>
<p>Ecris le code qui retourne la valeur de 2<sup>n</sup>. Indice pour être efficace
: utilise le shifting.</p>
<pre><code class="language-c">int power_of_two(unsigned int n);
</code></pre>
<p>Ecris le code de la fonction <strong>int_len</strong> qui retourne le nombre de caractères
utilisés pour <strong>afficher</strong> un entier.</p>
<ul>
<li>Si n vaut 0 :  retourne 1</li>
<li>Si n vaut -1 : retourne 2</li>
<li>Si n vaut 1 : retourne 1</li>
<li>Si n vaut 2600 : retourne 4</li>
<li>Si n vaut -42 : retourne 3</li>
<li>etc.</li>
</ul>
<pre><code class="language-c">int int_len(n);
</code></pre>
<p>Ecris le code des fonctions</p>
<p><strong>is_lowercase</strong> qui retourne 1 si le caractère envoyé est une lettre de
l'alphabet en minuscule, 0 sinon.</p>
<p><strong>is_uppercase</strong> qui retourne 1 si le caractère envoyé est une lettre de
l'alphabet en majuscule, 0 sinon.</p>
<p><strong>is_num</strong> qui retourne 1 si le caractère envoyé est un caractère qui représente
un chiffre compris entre 0 et 9, 0 sinon.</p>
<p>Regarde bien le man ascii et réfléchis à comment tester si c'est bien dans la
partie minuscule, majuscule ou numérique.</p>
<pre><code class="language-c">int is_lowercase(char c);
int is_uppercase(char c);
int is_num(char c);
</code></pre>
<p>Ecris le code de la fonction <strong>is_alphanum</strong> qui retourne 1 si le caractère en
paramètre correspond à une lettre de l'alphabet en minuscule, ou un chiffre
compris entre 0 et 9, 0 sinon.</p>
<p>Tu peux tout à fait appeller les 3 dernières fonctions depuis la fonction
<strong>is_alphanum</strong>, pense à bien les écrire <strong>au dessus</strong> de la fonction
<strong>is_alphanum</strong>.</p>
<pre><code class="language-c">int is_lowercase(char c)
{
    // Le code
}

int is_uppercase(char c)
{
    // Le code
}

int is_num(char c)
{
    // Le code
}

int is_alphanum(char c)
{
    // Le code
}
</code></pre>
<p>Ecris la fonction <strong>graduate</strong> qui :</p>
<ul>
<li>Affiche "Mauvais" si la note est compris dans l'intervalle [0;8]</li>
<li>Affiche "Moyen" si la note est compris dans l'intervalle [9;12]</li>
<li>Affiche "Bien" si la note est compris dans l'intervalle [13;16]</li>
<li>Affiche "Très bien" si la note est compris dans l'intervalle [17;19]</li>
<li>Affiche "Parfait" si la note est à 20</li>
<li>Affiche "Quoi ?" si la note n'est pas compris dans l'intervalle [0;20]</li>
</ul>
<pre><code class="language-c">void graduate(int n);
</code></pre>
<h2 id="notions-de-pointeurs"><a class="header" href="#notions-de-pointeurs">Notions de pointeurs</a></h2>
<p>Ecris le code de la fonction <strong>moyenne</strong> qui renvoie la moyenne de 3 floats en
les remettant à 0 <strong>dans</strong> la fonction.</p>
<p>Une moyenne sur 42 éléments se calcule ainsi : (valeur_1 + valeur 2 + ... +
valeur_42) / 42</p>
<pre><code class="language-c">float moyenne(float *a, float *b, float *c);
</code></pre>
<p>Ecris le code de la fonction <strong>odd_even</strong> qui affiche :</p>
<ul>
<li>C'est pair : Si la valeur pointée est paire</li>
<li>C'est impair : Si la valeur pointée est impair</li>
</ul>
<pre><code class="language-c">void odd_even(int *value);
</code></pre>
<p>Ecris le code <strong>swap</strong> qui échange les valeurs pointées de deux pointeurs.</p>
<p>Si tu y arrives, fais le sans créer de variable dans la fonction. Sinon, ce
n'est pas grace, ça sera déjà bien !</p>
<pre><code class="language-c">void swap(int *a, int *b)
{
    // Le code
}

int main(void)
{
    int a = 42;
    int b = 2600;

    printf("a = %d | b =  %d\n"); // a = 42 | b = 2600
    swap(&amp;a, &amp;b);
    printf("a = %d | b =  %d\n"); // a = 2600 | b = 42

    return 0;
}
</code></pre>
<h2 id="chaînes-de-caractères"><a class="header" href="#chaînes-de-caractères">Chaînes de caractères</a></h2>
<p>Ecris le code de la fonction <strong>strlen</strong> qui renvoie le nombre de caractères dans
une chaîne de caractères</p>
<pre><code class="language-c">unsigned int strlen(char *s);
</code></pre>
<p>Ecris le code de la fonction <strong>upper</strong> qui prend un tableau de caractères en
entrée et qui change les caractères minuscules en caractères majuscules.</p>
<p>Ecris le code de la fonction <strong>lower</strong> qui prend un tableau de caractères en
entrée et qui change les caractères majuscules en caractères minuscules.</p>
<p>Tu peux tout à fait utiliser les fonctions <strong>uppercase</strong> et <strong>lowercase</strong>.</p>
<pre><code class="language-c">int uppercase(char c)
{
    // Le code
}

int lowercase(char c)
{
    // Le code
}

void upper(char *str)
{
    // Le code
}

void lower(char *str)
{
    // Le code
}

int main(void)
{
    char str[] = "J'aImE b3AuC0uP l3 PeDiLuvE";

    printf("%s\n", str); // "J'aImE b3AuC0uP l3 PeDiLuvE";

    upper(str);

    printf("%s\n", str); // "J'AIME B3AUC0UP L3 PEDILUVE";

    lower(str);

    printf("%s\n", str); // "j'aime b3auc0up l3 pediluve";

    return 0;
}
</code></pre>
<p>Ecris le code de la fonction <strong>vowels</strong> qui retourne le nombre de voyelles
présentes dans une chaîne de caractères.</p>
<pre><code class="language-c">int vowels(char *str);
</code></pre>
<p>Ecris le code de la fonction <strong>miniatoi</strong> qui retourne l'entier représenté sous
chaînes de caractères. Dès que tu rencontres un caractère qui n'est pas
numérique, retourne ce que tu as déjà calculé.</p>
<ul>
<li>Si str vaut "0", retourne 0</li>
<li>Si str vaut "2", retourne 2</li>
<li>Si str vaut "-42", retourne -42</li>
<li>Si str vaut "2600", retourne 2600</li>
<li>Si str vaut "pediluve", retourne 0</li>
<li>Si str vaut "pediluve666", retourne 0</li>
<li>Si str vaut "69pediluve777", retourne 69</li>
<li>Si str vaut "-pediluve7", retourne 0</li>
</ul>
<p>Tu peux utiliser la fonction <strong>is_num</strong> que tu as écris plus tôt.</p>
<pre><code class="language-c">int miniatoi(char *str);
</code></pre>
<p>Avec ça tu as déjà quelques exercices pour apprendre à faire un peu de C et être
à l'aise pour la suite des évènements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="corrections"><a class="header" href="#corrections">Corrections</a></h1>
<h2 id="fonctions-simples-1"><a class="header" href="#fonctions-simples-1">Fonctions simples</a></h2>
<pre><code class="language-c">int addition(int a, int b)
{
    return a + b;
}

int substraction(int a, int b)
{
    return a - b;
}

int multiplication(int a, int b)
{
    return a * b;
}

int divide(int a, int b)
{
    if (b == 0)
    {
        return 0;
    }

    return a / b;
}

int and(int a, int b)
{
    return a &amp; b;
}

int or(int a, int b)
{
    return a | b;
}

int xor(int a, int b)
{
    return a ^ b;
}

int not(int a)
{
    return ~a;
}

int double_int(int a)
{
    return a + a;
}

int square(int a)
{
    return a * a;
}

int cube(int a)
{
    return a * a * a;
}

int power_of_two(unsigned int n)
{
    return 1 &lt;&lt; n;
}
</code></pre>
<pre><code class="language-c">int int_len(n)
{
    int result = 0;
    int sign = (n &lt; 0);

    while (n != 0)
    {
        n = n / 10;
        ++result;
    }

    return result + sign;
}
</code></pre>
<pre><code class="language-c">int is_lowercase(char c)
{
    return ('a' &lt;= c &amp;&amp; c &lt;= 'z');
}

int is_uppercase(char c);
{
    return ('A' &lt;= c &amp;&amp; c &lt;= 'Z');
}

int is_num(char c);
{
    return ('0' &lt;= c &amp;&amp; c &lt;= '9');
}

int is_alphanum(char c)
{
    return (is_lowercase(c) || is_uppercase(c) || is_num(c));
}
</code></pre>
<pre><code class="language-c">void graduate(int n)
{
    if (0 &lt;= n &amp;&amp; n &lt;= 8)
    {
        printf("Mauvais\n");
    }
    else if (9 &lt;= n &amp;&amp; n &lt;= 12)
    {
        printf("Moyen\n");
    }
    else if (13 &lt;= n &amp;&amp; n &lt;= 16)
    {
        printf("Bien\n");
    }
    else if (17 &lt;= n &amp;&amp; n &lt;= 19)
    {
        printf("Très bien\n");
    }
    else if (n == 20)
    {
        printf("Parfait\n")
    }
    else
    {
        printf("Quoi ?\n");
    }
}
</code></pre>
<h2 id="notions-de-pointeurs-1"><a class="header" href="#notions-de-pointeurs-1">Notions de pointeurs</a></h2>
<pre><code class="language-c">float moyenne(float *a, float *b, float *c)
{
    float result = (*a + *b + *c) / 3

    *a = 0;
    *b = 0;
    *c = 0;

    return result;
}
</code></pre>
<pre><code class="language-c">void odd_even(int *value)
{
    if (*value % 2 == 0)
    {
        printf("C'est pair\n");
    }
    else
    {
        printf("C'est impair");
    }
}
</code></pre>
<pre><code class="language-c">void swap(int *a, int *b)
{
    int tempo = *a;
    *a = *b;
    *b = tempo;
}

// Ou alors en mode bitwise expert sans avoir à créer une variable temporaire

void swap(int *a, int *b)
{
    *a = *a ^ *b;
    *b = *a ^ *b;
    *a = *a ^ *b;
}
</code></pre>
<h2 id="chaînes-de-caractères-1"><a class="header" href="#chaînes-de-caractères-1">Chaînes de caractères</a></h2>
<pre><code class="language-c">unsigned int strlen(char *s)
{
    unsigned int result = 0;
    for (int i = 0; s[i] != '\0'; ++i)
    {
        ++result;
    }

    return result;
}
</code></pre>
<pre><code class="language-c">void upper(char *str)
{
    for (int i = 0; str[i] != '\0'; ++i)
    {
        if (is_uppercase(str[i])
        {
            str[i] = str[i] + 32;
        }
    }
}

void lower(char *str)
{
    for (int i = 0; str[i] != '\0'; ++i)
    {
        if (is_lowercase(str[i])
        {
            str[i] = str[i] - 32;
        }
    }

}
</code></pre>
<p>Pourquoi addition ou soustraire par 32 ?</p>
<p>Si tu regardes le <strong>man ascii</strong>, tu peux voir que la lettre majuscule 'A' a la
valeur 65 et que la lettre minuscule 'a' a la valeur 97. La différence entre 65
et 97 est 32. En additionant ou soustrayant par 32, on peut passer de
l'intervalle minuscule à majuscule et inversement.</p>
<pre><code class="language-c">int vowels(char *str)
{
    int result = 0;}

    for (int i = 0; str[i] != '\0'; ++i)
    {
        if (str[i] == 'a' || str[i] == 'e' || str[i] == 'i' || str[i] == 'o' || str[i] == 'u' || str[i] == 'y')
        {
            ++result;
        }
    }

    return result;
}
</code></pre>
<pre><code class="language-c">int is_num(char c);
{
    return ('0' &lt;= c &amp;&amp; c &lt;= '9');
}

int miniatoi(char *str)
{
    int result = 0;
    int sign = 1;

    if (str[0] == '-')
    {
        sign = -1;
        ++str;
    }

    for (int i = 0; str[i] != '\0'; ++i)
    {
        if (is_num(str[i]))
        {
            result = result * 10;
            result = str[i] - '0';
        }
        else
        {
            break;
        }
    }

    return result * sign;
}
</code></pre>
<p>Décortiquons.</p>
<p>La variable <strong>result</strong> est créée en étant multipliée par 10 petit à petit puis
on retourne le résultat multiplié par <strong>1</strong> ou <strong>-1</strong>.</p>
<p>Si j'envoie "1234", la variable <strong>result</strong> sera égale aux valeurs suivantes :</p>
<ul>
<li>0     // ligne 13 et ligne 27</li>
<li>1     // ligne 28</li>
<li>10    // ligne 27</li>
<li>12    // ligne 28</li>
<li>120   // ligne 27</li>
<li>123   // ligne 28</li>
<li>1230  // ligne 27</li>
<li>1234  // ligne 28</li>
</ul>
<p>Enfin, on retourne le résultat multiplié par <strong>1</strong> ou <strong>-1</strong>.</p>
<p>\[ 1234 * 1 = 1234 \]</p>
<p>Si j'envoie "-1234", on retient que le signe est négatif et on avance le
pointeur après le signe '-'. On refait les mêmes caluls et on retourne 1234
multiplié par -1.</p>
<p>\[ 1234 * -1 = -1234 \]</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structures-de-données"><a class="header" href="#structures-de-données">Structures de données</a></h1>
<p>Tu as vu comment utiliser les types prédéfinis par le langage C, mais le C te
permet de créer tes propres structures et quelque part tes propres types.</p>
<p>Il existe différents moyens de <em>créer ses propres types</em>, tels que les
<strong>struct</strong>, les <strong>enum</strong> et les <strong>unions</strong>.</p>
<p>Pour le Pédiluve, tu ne vas que voir les <strong>struct</strong>.</p>
<p>Une structure est une collection de différents types. Ca ne fonctionne pas tout
à fait comme un tableau car tu peux accéder aux attributs par leurs noms.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct player
{
    char *name;
    int level;
    float mana;
};

int main(void)
{
    struct player p;

    p.name = "gelules";
    p.level = 42;
    p.mana = 2600,6951;

    printf("Player:\n");
    printf("Name: %s\nLevel: %d\nMana: %f\n", p.name, p.level, p.mana);

    return 0;
}
</code></pre>
<p>Et voilà, tu peux définir des structures qui collectionnent des types
différents.</p>
<h2 id="par-pointeurs"><a class="header" href="#par-pointeurs">Par pointeurs</a></h2>
<p>L'accès aux structures par pointeurs est différent des accès aux tableaux. Quand
c'est une variable locale comme dans le code ci-dessus, tu accès aux attributs
par un point '.'. Quand c'est par pointeur, il faut une flèche '-&gt;'.</p>
<p>On va coder les fonctions <strong>player_create</strong> et <strong>player_print</strong>.</p>
<p><strong>player_create</strong> prend un pointeur vers une <strong>structure player</strong> pour la
remplir avec les paramètres restants.</p>
<p><strong>player_print</strong> affiche les attributs.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct player
{
    char *name;
    int level;
    float mana;
};

void player_create(struct player *p, char *name, int level, float mana)
{
    p-&gt;name = name;
    p-&gt;level = level;
    p-&gt;mana = mana;
}

void player_print(struct player *p)
{
    printf("Name: %s\n", p-&gt;name);
    printf("Level: %d\n", p-&gt;level);
    printf("Mana: %f\n", p-&gt;mana);
}

int main(void)
{
    struct player p;

    player_create(&amp;p, "gelules", 42, 2600.6951);

    player_print(&amp;p);

    return 0;
}
</code></pre>
<p>Tu peux aussi créer une structure en une seule instruction ainsi :</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct player
{
    char *name;
    int level;
    float mana;
};

void player_print(struct player *p)
{
    printf("Name: %s\n", p-&gt;name);
    printf("Level: %d\n", p-&gt;level);
    printf("Mana: %f\n", p-&gt;mana);
}

int main(void)
{
    struct player p = {.name = "gelules",
                       .level = 42,
                       .mana = 2600.6951};

    player_print(&amp;p);

    return 0;
}
</code></pre>
<p>Il n'y a même pas besoin de suivre l'ordre des attributs.</p>
<p>Tu peux voir la taille qu'utilise une structure en mémoire avec sizeof.</p>
<pre><code class="language-c">struct player
{
    char *name;
    int level;
    float mana;
};

unsigned long int size = sizeof (struct player);

printf("sizeof (struct player): %lu\n", size);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="avancé"><a class="header" href="#avancé">Avancé</a></h1>
<p>Tu as terminé le minimum dont tu as besoin pour être à l'aise pendant ta
prochaine Piscine. Hourra !</p>
<p>Les chapitres suivants sont des notions un peu plus avancées pour être encore
plus à l'aise, mais ce n'est pas grave si tu préfères attendre ta Piscine.</p>
<p>Je ne t'en voudrais pas. (Pas beaucoup).</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="flags-de-compilation"><a class="header" href="#flags-de-compilation">Flags de compilation</a></h1>
<p>Depuis le début, tu compiles ton code en appelant gcc sur ton fichier source et
le nom du binaire qu'il doit crée, sans aucune autre information.</p>
<p>Tu peux donner des paramètres à gcc pour orienter la compilation.</p>
<p>Voici les paramètres que tu devrais utiliser pour valider avec brio les codes
que tu envoies êtres testés :</p>
<ul>
<li>-std=c99 : Utilise le C version 99. Si tu ne suis pas la norme, tu auras un message d'avertissement (warning).</li>
<li>-pedantic : Utilise la norme ISO du C. Si tu ne suis pas la norme, tu auras un message d'avertissement.</li>
<li>-Wall : Active beaucoup de warnings.</li>
<li>-Wextra : Active encore plus de warnings.</li>
<li>-Werror : Transforme les warnings en erreurs.</li>
<li>-Wvla : Interdit les tableaux à taille variable.</li>
</ul>
<p>Un warning permet la compilation, le compilateur t'informe qu'il <em>peut</em> y avoir
un comportement indéfini à l'exécution.</p>
<p>Une erreur interdit la compilation. Ainsi si tu as ne serait-ce que le moindre
petit warning, la compilation échouera.</p>
<p>Voici comment compiler avec les flags de compilation présentés.</p>
<pre><code class="language-text">$ gcc -std=c99 -pedantic -Wall -Wextra -Werror -Wvla test.c -o mon_super_programme
</code></pre>
<p>Voici un code qui comporte des warnings et erreurs avec les flags de
compilation.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

void mystery(int *i)
{
    int j = *i * 42;
    *i += j;
}

int main(int argc, char *argv[])
{
    int i;
    int j = i + 1;
    int k = atoi(argv[1]);
    int array[k];
    printf("Coucou\n");

    mystery(&amp;i);

    printf("%u\n", i);
}
</code></pre>
<pre><code class="language-text">$ gcc -Wall -Wextra -Wvla -Werror -std=c99 -pedantic test.c -o mon_super_programme
test.c: In function ‘main’:
test.c:14:5: error: ISO C90 forbids variable length array ‘array’ [-Werror=vla]
   14 |     int array[k];
      |     ^~~
test.c:15:5: error: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration]
   15 |     printf("Coucou\n");
      |     ^~~~~~
test.c:2:1: note: include ‘&lt;stdio.h&gt;’ or provide a declaration of ‘printf’
    1 | #include &lt;stdlib.h&gt;
  +++ |+#include &lt;stdio.h&gt;
    2 |
test.c:15:5: error: incompatible implicit declaration of built-in function ‘printf’ [-Werror=builtin-declaration-mismatch]
   15 |     printf("Coucou\n");
      |     ^~~~~~
test.c:15:5: note: include ‘&lt;stdio.h&gt;’ or provide a declaration of ‘printf’
test.c:14:9: error: unused variable ‘array’ [-Werror=unused-variable]
   14 |     int array[k];
      |         ^~~~~
test.c:12:9: error: unused variable ‘j’ [-Werror=unused-variable]
   12 |     int j = i + 1;
      |         ^
test.c:9:14: error: unused parameter ‘argc’ [-Werror=unused-parameter]
    9 | int main(int argc, char *argv[])
      |          ~~~~^~~~
cc1: all warnings being treated as errors
$
</code></pre>
<p>Ca fait peur hein ? Il suffit pourtant de lire les messages d'erreurs.</p>
<pre><code class="language-text">test.c:14:5: error: ISO C90 forbids variable length array ‘array’ [-Werror=vla]
   14 |     int array[k];
      |     ^~~
</code></pre>
<p>Tu crées une tableau dont la taille ne peut être calculé à la compilation.
Comment savoir quelle place prendre en mémoire ? C'est interdit, tu dois définir
une taille fixe pour la compilation, pas l'exécution.</p>
<pre><code class="language-text">test.c:15:5: error: implicit declaration of function ‘printf’ [-Wimplicit-function-declaration]
   15 |     printf("Coucou\n");
      |     ^~~~~~
test.c:2:1: note: include ‘&lt;stdio.h&gt;’ or provide a declaration of ‘printf’
    1 | #include &lt;stdlib.h&gt;
  +++ |+#include &lt;stdio.h&gt;
    2 |

</code></pre>
<p>Tu appelles printf sans inclure stdio.h. Lis bien le message, il te dit même à
quelle ligne inclure le fichier.</p>
<pre><code class="language-text">test.c:12:9: error: unused variable ‘j’ [-Werror=unused-variable]
   12 |     int j = i + 1;
      |         ^
</code></pre>
<p>Tu crées une variable sans l'utiliser, quelle inutilité !</p>
<p>Si tu es entrain de créer du code que tu veux tester avec des variables pas
encore utilisées, tu peux faire ça :</p>
<pre><code class="language-c">int i = 0;
int j = i + 1;

(void) j;

fonction(&amp;i);
</code></pre>
<p>L'instruction ligne 4 ne fait strictement rien avec j. Mais ne rien faire, c'est
déjà faire quelque chose.</p>
<p>Pareil avec <strong>argc</strong>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plusieurs-fichiers"><a class="header" href="#plusieurs-fichiers">Plusieurs fichiers</a></h1>
<p>Depuis le début, tu compiles un seul et unique fichier. Mais un programme ce
n'est pas qu'un seul fichier. C'est une multitude de fichiers compilés ensemble.</p>
<p>Pour la ligne de commande, c'est simple, il suffit d'ajouter le nom de test
fichiers.</p>
<p>Tu as créer un fichier test.c avec le <strong>main</strong> et un fichier math.c avec les
fonctions <strong>addition</strong> et <strong>soustraction</strong> que tu connais si bien maintenant.</p>
<pre><code class="language-c">// test.c

#include &lt;stdio.h&gt;

int main(void)
{
    int a = 42;
    int b = 2600;
    int result = addition(a, b);

    printf("result: %d\n", result);

    return 0;
}
</code></pre>
<pre><code class="language-c">/// math.c

int addition(int a, int b)
{
    return a + b;
}

int soustraction(int a, int b)
{
    return a - b;
}
</code></pre>
<p>Compile.</p>
<pre><code class="language-text">$ gcc test.c math.c -o mon_super_programme
test.c: In function ‘main’:
test.c:9:18: error: implicit declaration of function ‘addition’ [-Wimplicit-function-declaration]
    9 |     int result = addition(a, b);
      |
</code></pre>
<p>Bigre, la fonction main ne trouve pas la fonction addition. Pourtant le fichier
est bien dans la compilation.</p>
<p>C'est parce que le compilateur ne fonctionne pas comme ça. C'est moche, mais tu
ne vas pas voir ça maintenant, mais pendant ta Piscine.</p>
<p>Il faut indiquer à la fonction main que tes fonctions de maths existent, et ça
dans le fichier test.c</p>
<p>Tu vas <strong>déclarer</strong> les fonctions.</p>
<p>Déclarer signifie que tu indiques au compilateur qu'il existe des fonctions avec
un identifiant, des paramètres et un type de sortie.</p>
<p>Définir signifie créer le code des fonctions déclarées.</p>
<p>Ca fonctionne aussi pour des variables. Tu peux définir <strong>i</strong> ainsi :</p>
<pre><code class="language-c">int i;
</code></pre>
<p>et le définir avec le symbole d'égalité.</p>
<pre><code class="language-c">i = 0;

// ou directement le définir en le déclarant

int i = 0;
</code></pre>
<p>Tu vas d'abord créer ton premier fichier header, que tu vas appeler <strong>math.h</strong>.</p>
<pre><code class="language-c">#ifndef MATH_H
#define MATH_H

int addition(int a, int b);
int soustraction(int a, int b);

#endif /* !MATH_H */
</code></pre>
<p>Ne fais pas attention aux code avec <strong>ifndef</strong>, <strong>define</strong> et <strong>endif</strong>. Ils
sont là pour éviter des redéfinitions de code. Tu sauras aussi ce que c'est
pendant ta Piscine.</p>
<p>Ce que tu fais ici, c'est annoncer qu'il existe, quelque part, des fonctions
<strong>addition</strong> et <strong>soustraction</strong>. <strong>addition</strong> prend 2 int en paramètres et
retourne 1 int. Pareil pour <strong>soustraction</strong>.</p>
<p>Tu vas maintenant informer <strong>test.c</strong> que ces fonctions existent.</p>
<pre><code class="language-c">// test.c

#include &lt;stdio.h&gt;

#include "math.h"

int main(void)
{
    int a = 42;
    int b = 2600;
    int result = addition(a, b);

    printf("result: %d\n", result);

    return 0;
}
</code></pre>
<p>Vois-tu la différence entre une bibliothèque installée dans le système et une
bibliothèque locale ?</p>
<p>Celle dans le système est inclue avec des chevrons '&lt;' et '&gt;' tandis que la
bibliothèque locale est inclue par des guillements '"'.</p>
<p>Egalement, ce sont dans ces fichiers que tu dois initialiser tes structures.</p>
<p>Recompile.</p>
<pre><code class="language-text">$ gcc test.c math.c -o mon_super_programme
$
</code></pre>
<p>Et voilà, à partir de maintenant, tu peux créer des programmes qui utilisent
plusieurs fichiers.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="makefile"><a class="header" href="#makefile">Makefile</a></h1>
<p>Un cours complet sur les Makefiles serait bien disproportionné pour un Pédiluve.</p>
<p>Aussi je t'invite à voir ces deux vidéos pour un cours plus complet.</p>
<p><a href="https://www.youtube.com/watch?v=om6pqsebNQo">Makefile, introduction</a></p>
<p><a href="https://www.youtube.com/watch?v=ETJH8ne8nAQ">Makefile, Wvla</a></p>
<p>Pour la suite, je vais te proposer un Makefile fonctionnel, préconstruit. Je te
montrerai comment l'utiliser et comment le modifier en cas d'ajout de fichier.</p>
<pre><code class="language-makefile">CFLAGS = -std=c99 -pedantic -Wall -Wextra -Wvla -Werror
OBJ = test.o math.o
BIN = test
TARGET = mon_super_programme

all: $(BIN)
        @mv $&lt; $(TARGET)

$(BIN): $(OBJ)

clean:
        $(RM) $(OBJ) $(BIN) $(TARGET)
</code></pre>
<p>Pour utiliser ce Makefile, tu dois tout simplement appeler <strong>make</strong>.</p>
<pre><code class="language-text">$ make
cc -std=c99 -pedantic -Wall -Wextra -Wvla -Werror   -c -o test.o test.c
cc -std=c99 -pedantic -Wall -Wextra -Wvla -Werror   -c -o math.o math.c
cc   test.o math.o   -o test
$ ls
Makefile  math.c  math.h  math.o  mon_super_programme  test.c  test.o
$
</code></pre>
<p>Et voilà, tu as automatisé ta compilation !</p>
<p>Décortiquons tout ça.</p>
<p>Il y a 4 variables dans ce Makefile, CFLAGS, OBJ, BIN et TARGET.</p>
<ul>
<li>CFLAGS a les flags de compilation.</li>
<li>OBJ est le nom de tes fichiers C compilés en fichiers objets, remplace tout simplement l'extension .c en .o</li>
<li>BIN est un de tes fichiers .c sans extension</li>
<li>TARGET est le nom du binaire que tu veux avoir comme programme</li>
</ul>
<p>Si tu veux ajouter des fichiers C dans tes projets, ajoute les noms des fichiers
dans OBJ en remplaçant .c par .o.</p>
<p>Pour faciliter la compilation, il faut que BIN soit le nom d'un fichier .o sans
l'extension.</p>
<p>TARGET est le nom du programme que tu veux avoir à la fin</p>
<p>Enfin, dans la recette <strong>all</strong>, on <em>move</em> le nom du binaire généré par celui de
TARGET. On utilise un arobase '@' devant l'instruction pour que ça ne soit pas
affiché pendant l'appel à <strong>make</strong>.</p>
<p>Un fichier objet est un fichier C compilé en langage machine.</p>
<p>Si tu veux supprimer les fichiers générés (le binaire, les fichiers objets,
...), appelle la target <strong>clean</strong> dans la ligne de commande.</p>
<pre><code class="language-text">$ make clean
rm -f test.o math.o test mon_super_programme
$
</code></pre>
<p>Je t'invite à regarder les vidéos pour avoir plus de détails sur les Makefiles.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="récursivité"><a class="header" href="#récursivité">Récursivité</a></h1>
<p>Avais-tu pensé à appeler la fonction dans laquelle tu étais ?</p>
<p>Voici un exemple :</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

unsigned int mystery(unsigned int n)
{
    if (n == 0)
    {
        return 0;
    }

    return n + mystery(n - 1);
}

int main(void)
{
    unsigned int value = 3;
    unsigned int result = mystery(value);
    printf("mystery(%u) = %u\n", value, result);

    return 0;
}
</code></pre>
<p>Arrives-tu à déterminer ce que fait cette fonction ?</p>
<p>Elle somme l'ensemble des nombres dans l'intervalle [0;n].</p>
<p>En effet, la fonction va sans cesse se rappeler en décrémentant n de 1 jusqu'à
arriver à 0.</p>
<p>Voilà ce qu'il se passe en mémoire avec <strong>n = 3</strong>.</p>
<p><img src="c/./recursive/recursive.svg" alt="n = 3" title="n = 3" /></p>
<p>\[ 3 + 2 + 1 + 0 = 6 \]</p>
<p>Prenons un autre exemple extrêmement simple :</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void counter(unsigned int n)
{
    printf("%u\n", n);

    if (n == 0)
    {
        return;
    }

    counter(n - 1);
}

int main(void)
{
    counter(10);
    return 0;
}
</code></pre>
<p>Avec <strong>n = 10</strong>, ça crée un compteur qui va de 10 à 0.</p>
<pre><code class="language-text">$ gcc test.c -o mon_super_programme
$ ./mon_super_programme
10
9
8
7
6
5
4
3
2
1
0
$
</code></pre>
<p>Il faut faire attention à une chose avec la récursivité : <strong>la condition
d'arrêt</strong>.</p>
<p>Dans les deux exemples ci-dessus, on vérifie toujours le cas où <strong>n == 0</strong>. Si
la condition est vraie, on quitte la fonction. Dans le cas contraire, on
rappelle la fonction avec <strong>n</strong> qui décrémente de 1.</p>
<p>Si tu ne mets pas de condition d'arrêt, tu vas partir en récursion infinie, et
avoir ce qu'on appelle un <strong>stack overflow</strong>.</p>
<p>Je te laisse essayer ce bout ce code qui n'a pas de condition d'arrêt :</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

void counter(unsigned int n)
{
    printf("%u\n", n);

    counter(n - 1);
}

int main(void)
{
    counter(10);
    return 0;
}
</code></pre>
<p>A chaque appel de la fonction <strong>counter</strong>, la mémoire recrée une zone mémoire
pour la nouvelle fonction appelée, qui est une <strong>stack</strong>. Ta mémoire n'étant pas
infinie, quand elle n'a pas de place pour une nouvelle <strong>stack</strong>, le programme
crash avec un <strong>stack overflow</strong>.</p>
<p>Tu verras pendant ta Piscine d'autres cas d'utilisation de la récursivité. Sache
que c'est utile pour résoudre des gros problèmes en découpant un problème en
sous-problème et en itérant dessus.</p>
<p>La récursivité a l'avantage d'être plus élégante mais a le défaut d'être plus
lente qu'une boucle à l'exécution car à chaque rappel de la fonction, se créé en
mémoire tout le contexte nécessaire pour créer une fonction, et à la fin de la
récursion, il faut remonter tous les appels effectués pour revenir au point de
départ. Si tu fais des récursions sur des milliers et milliers de nombres, tu
perdras rapidement en efficacité.</p>
<p>Voici par exemple, la <a href="https://fr.wikipedia.org/wiki/Fonction_d%27Ackermann">fonction d'Ackermann</a> :</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#include &lt;stdio.h&gt;

int ackermann(int m, int n)
{
    if (m == 0)
    {
        return n + 1;
    }

    if (m &gt; 0 &amp;&amp; n == 0)
    {
        return ackermann(m - 1, 1);
    }

    if (m &gt; 0 &amp;&amp; n &gt; 0)
    {
        return ackermann(m - 1, ackermann(m, n - 1));
    }
}


int main(int argc, char *argv[])
{
    if (argc != 3)
        return 1;

    int m = atoi(argv[1]);
    int n = atoi(argv[2]);
    int a = ackermann(m, n);

    printf("ackermann(%d, %d) = %d\n", m, n, a);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ gcc test.c -o mon_super_programme
$ time ./mon_super_programme 3 14
ackermann(3, 14) = 131069
./ackermann 3 14  69.22s user 0.56s system 98% cpu 1:10.59 total
$
</code></pre>
<p>La fonction met 69 secondes à s'exécuter sur ma machine.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pointeurs-avancés"><a class="header" href="#pointeurs-avancés">Pointeurs avancés</a></h1>
<h2 id="arithmétique-des-pointeurs-2ème-partie"><a class="header" href="#arithmétique-des-pointeurs-2ème-partie">Arithmétique des pointeurs, 2ème partie</a></h2>
<p>Plus tôt, je t'ai dit qu'on pouvait incrémenter un pointeur pour avancer dans un
tableau. Mais comment penses-tu que cela se passe en mémoire ?</p>
<p>Prends deux tableaux de types différents.</p>
<pre><code class="language-c">char ptr_c[] = "abcdefghijklmnopqrstuvwxyz";
double ptr_d[26] = { 0 };
</code></pre>
<p>Maintenant tu vas créer les deux <strong>pointeurs</strong> pour avancer en mémoire, et les
deux <strong>pointeurs sur void</strong> correspondants pour avoir leurs adresses.</p>
<pre><code class="language-c">char array_c[] = "abcdefghijklmnopqrstuvwxyz";
double array_d[26] = { 0 };
char *ptr_c = array_c;
double *ptr_d = array_d;
void *addr_c = ptr_c;
void *addr_d = ptr_d;

</code></pre>
<p>Pas besoin d'utiliser l'esperluette '&amp;' pour avoir l'adresse, un tableau agit
déjà comme un pointeur, sa valeur est donc déjà une adresse.</p>
<p>Fais quelques affichages.</p>
<pre><code class="language-c">char array_c[] = "abcdefghijklmnopqrstuvwxyz";
double array_d[26] = { 0 };
char *ptr_c = array_c;
double *ptr_d = array_d;
void *addr_c = ptr_c;
void *addr_d = ptr_d;

printf("addr ptr_c: %p with value %c\n", addr_c, *ptr_c);
printf("addr ptr_d: %p with value %lf\n", addr_d, *ptr_d);

ptr_c = ptr_c + 1;
++ptr_d;
addr_c = ptr_c;
addr_d = ptr_d;

printf("addr ptr_c: %p with value %c\n", addr_c, *ptr_c);
printf("addr ptr_d: %p with value %lf\n", addr_d, *ptr_d);

++ptr_c;
++ptr_d;
addr_c = ptr_c;
addr_d = ptr_d;

printf("addr ptr_c: %p with value %c\n", addr_c, *ptr_c);
printf("addr ptr_d: %p with value %lf\n", addr_d, *ptr_d);
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
addr ptr_c: 0x7ffccc171530 with value a
addr ptr_d: 0x7ffccc171460 with value 0.000000
addr ptr_c: 0x7ffccc171531 with value b
addr ptr_d: 0x7ffccc171468 with value 0.000000
addr ptr_c: 0x7ffccc171532 with value c
addr ptr_d: 0x7ffccc171470 with value 0.000000
$
</code></pre>
<p>Comme tu peux le voir, le pointeur vers caractère avance de 1 en 1, tandis que
le pointeur vers double avance de 8 en 8 (rappelle toi on est en hexadécimal,
0x8 + 0x8 = 0x10)</p>
<p>Pourquoi ? Parce qu'un caractère prend 1 octet en mémoire et un double prend 8
octets en mémoire, le pointeur va donc avancer d'autant d'octets.</p>
<p>Imagine avoir un tableau de <strong>struct player</strong> assez large.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;

struct player
{
    char *name;
    int level;
    double mana;
    int x;
    int y;
    int z;
    char *weapon;
};

int main(void)
{
    unsigned long int size = sizeof (struct player);
    struct player players[16];
    struct player *p = players;
    void *addr_p = p;

    printf("sizeof (struct player): %lu\n", size);

    for (int i = 0; i &lt; 16; ++i)
    {
        addr_p = p + i;
        printf("addr of p[%d]: %p\n", i, addr_p);
    }
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
sizeof (struct player): 48
addr of p[0]: 0x7fffebaf2210
addr of p[1]: 0x7fffebaf2240
addr of p[2]: 0x7fffebaf2270
addr of p[3]: 0x7fffebaf22a0
addr of p[4]: 0x7fffebaf22d0
addr of p[5]: 0x7fffebaf2300
addr of p[6]: 0x7fffebaf2330
addr of p[7]: 0x7fffebaf2360
addr of p[8]: 0x7fffebaf2390
addr of p[9]: 0x7fffebaf23c0
addr of p[10]: 0x7fffebaf23f0
addr of p[11]: 0x7fffebaf2420
addr of p[12]: 0x7fffebaf2450
addr of p[13]: 0x7fffebaf2480
addr of p[14]: 0x7fffebaf24b0
addr of p[15]: 0x7fffebaf24e0
$
</code></pre>
<p>Comme tu peux le voir, le tableau de struct avance de 0x30 octets en 0x30 octets,
donc de 48 octets en 48 octets en base 10.</p>
<p>C'est parce que le pointeur n'avance pas un par un comme on pourrait le croire
avec la boucle, mais <strong>sizeof (element)</strong> par <strong>sizeof (element)</strong>. Ici,
l'élément est la <strong>struct player</strong> qui fait 48 octets.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="mémoire-1"><a class="header" href="#mémoire-1">Mémoire</a></h1>
<p>Pour l'instant, tu n'as fait que jouer avec des variables locales aux fonctions
que tu codes. Rappelle toi que ces variables ne sont vivantes que le temps
d'exécution de la fonction.</p>
<p>Comment créer une zone mémoire qui survivrait à la fonction ? Comment créer une
<em>tableau</em> à taille variable ?</p>
<p>Dis bonjour à malloc et free.</p>
<h2 id="malloc"><a class="header" href="#malloc">Malloc</a></h2>
<p>Malloc (<strong>m</strong>emory <strong>alloc</strong>ator) alloue une zone mémoire dynamique appelée la
<strong>heap</strong> dans laquelle tu peux faire ce que bon te semble. Tu peux y accéder
comme un tableau.</p>
<p>Je t'invite à lire le <strong>man 3 malloc</strong>.</p>
<pre><code class="language-c">void *malloc(size_t size);
</code></pre>
<p>Malloc renvoie un <strong>pointeur sur void</strong>. Ca veut dire que tu peux créer un
pointeur du type que tu veux. Mais il peut aussi renvoyer <strong>NULL</strong>, qui est un
<em>alias</em> sur <strong>(void *) 0</strong>. C'est un <strong>pointeur sur l'adresse 0</strong>. Cette
adresse est particulière, tu n'as pas le droit de la déréférencer, sinon ton
programme crashera et t'affichera un <strong>segfault</strong>.</p>
<p>Il prend en entrée un <strong>size_t</strong>. C'est un <em>alias</em> sur <strong>unsigned int</strong>. cf.
<strong>man 3type size_t</strong>. C'est aussi ce que retourne <strong>strlen</strong>, profitons-en.</p>
<p>C'est le kernel (noyau) de Linux qui s'occupe de te trouver une zone dans ta
mémoire vive qui est libre.</p>
<p>Mettons que tu veuilles créer une zone mémoire pour accueillir une chaîne de
caractères de la taille que tu veux pour copier le contenu de <strong>argv[1]</strong> (le
premier argument de ton programme).</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *arg_copy(char *arg_to_copy)
{
    size_t size = strlen(arg_to_copy);
    char *arg = malloc(size + 1);

    if (arg == NULL)
    {
        return NULL;
    }

    for (size_t i = 0; i &lt; size; ++i)
    {
        arg[i] = arg_to_copy[i];
    }

    arg[size] = '\0';

    return arg;
}

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s ARG\n", argv[0]);
        return 1;
    }

    char *text = arg_copy(argv[1]);
    if (text == NULL)
    {
        printf("malloc failed\n");
        return 2;
    }

    printf("%s\n", text);

    return 0;
}
</code></pre>
<p>Décortiquons tout ça.</p>
<p><strong>text</strong> est un pointeur sur char, il faut que ma fonction <strong>arg_copy</strong> retourne
un pointeur sur char. J'envoie en paramètre <strong>argv[1]</strong>.</p>
<p>Dans la fonction <strong>arg_copy</strong>, je crée le pointeur sur char <strong>arg</strong>. Je demande
à malloc de lui allouer la taille de l'entrée <strong>+ 1</strong>. J'ai besoin de ce
caractère en plus pour écrire le caractère de fin de chaîne de caractères :
<strong>\0</strong>.</p>
<p>Admettons que j'envoie <strong>coucou</strong> en entrée. <strong>size</strong> a la valeur de retour de
<strong>strlen("coucou");</strong>, soit 6.</p>
<div class="table-wrapper"><table><thead><tr><th>Index</th><th>0</th><th>1</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th></tr></thead><tbody>
<tr><td>Emplacement</td><td>1</td><td>2</td><td>3</td><td>4</td><td>5</td><td>6</td><td>7</td></tr>
<tr><td>Valeur</td><td>c</td><td>o</td><td>u</td><td>c</td><td>o</td><td>u</td><td>\0</td></tr>
</tbody></table>
</div>
<p>Dans ce tableau, la taille <strong>size</strong> est de 6, et le caractère <strong>\0</strong> est au 7ème
emplacement pour indiquer la fin de la chaîne de caractère. D'où l'utilisation
du <strong>+ 1</strong>.</p>
<p>Maintenant que j'ai ma zone mémoire, je vais copier le contenu de
<strong>arg_to_copy</strong> dans cette zone avec une boucle.</p>
<p>L'avant-dernière ligne de la fonction peut être difficile à comprendre. Etant
donné que <strong>size</strong> égale 6, alors <strong>arg[size]</strong> = <strong>arg[6]</strong>. Si tu reprends le
tableau, l'<strong>index</strong> 6 est l'emplacement où doit se trouver le caractère <strong>\0</strong>.</p>
<p>Etant donné que ma boucle s'arrête juste avant de caractère, je l'écris après
les itérations.</p>
<p>J'aurai aussi pu changer la condition de ma boucle ainsi :</p>
<pre><code class="language-c">for (size_t i = 0; i &lt;= size; ++i)
</code></pre>
<p>Ce qui fait que <strong>i</strong> aurai atteint la valeur de <strong>size</strong>.</p>
<p>Mais je voulais réappuyer sur l'utilisation des index sur les chaînes de
caractères.</p>
<h3 id="segfault"><a class="header" href="#segfault">Segfault</a></h3>
<p>Pour te montrer pourquoi il est important de <strong>tester</strong> les retours de malloc,
tu vas faire un code qui segfault.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void *my_malloc(size_t length)
{
    (void) length;
    return NULL;
}

int main(void)
{
    char *text = my_malloc(10);

    text[0] = 'B';

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Segmentation fault (core dumped)
$
</code></pre>
<p>Voilà pourquoi il est essentiel de <strong>toujours</strong> vérifier le retour de malloc.
Imagine que tu livres un programme qui crash en production pour une erreur aussi
simple. Quelle honte !</p>
<h2 id="free"><a class="header" href="#free">Free</a></h2>
<p>Une fois que tu n'as plus besoin de ta zone mémoire, il faut la <strong>libérer</strong>.</p>
<p>La mémoire vive de ton PC est limitée. Si tu demandes sans cesse de la mémoire
sans la libérer, tu utiliseras de la mémoire inutilement que d'autres programmes
pourraient utiliser. C'est ce qu'on appelle une fuite mémoire (momory leak).</p>
<p>Imagine qu'à chaque fois que tu ouvres un onglet sur ton navigateur Internet,
celui-ci demande 100 Mo au kernel, mais qu'une fois l'onglet fermé, ton
navigateur ne libère pas les 100 Mo alloués. Si tu cumules les onglets, tu vas
vite te retrouver sans beaucoup de mémoire vive libre. Tu seras obligé de fermer
ton navigateur pour tout libérer.</p>
<p>Pour libérer la mémoire, tu peux faire appel à free. Je t'invite à lire le <strong>man
3 free</strong>.</p>
<pre><code class="language-c">char *text = malloc(10);

// du code...

free(text);
</code></pre>
<p>Après l'appel de free, tu ne dois surtout pas réutiliser la variable libérée. Tu
utiliserais une zone mémoire que ton programme considèrerait comme libre de ta
portée et qui pourrait contenir des valeurs allouées par ton programme et pas
par toi. Tes résultats se retrouveraient faussés.</p>
<p>Si on reprend le premier code de cette page, il faut donc ajouter <strong>free</strong> juste
après le <strong>printf</strong> de la fonction <strong>main</strong> qui est le dernier endroit où la
zone mémoire allouée est utilisée.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *arg_copy(char *arg_to_copy)
{
    size_t size = strlen(arg_to_copy);
    char *arg = malloc(size + 1);

    if (arg == NULL)
    {
        return NULL;
    }

    for (size_t i = 0; i &lt; size; ++i)
    {
        arg[i] = arg_to_copy[i];
    }

    arg[size] = '\0';

    return arg;
}

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s ARG\n", argv[0]);
        return 1;
    }

    char *text = arg_copy(argv[1]);
    if (text == NULL)
    {
        printf("malloc failed\n");
        return 2;
    }

    printf("%s\n", text);

    free(text);

    return 0;
}
</code></pre>
<p><strong>Vive la mémoire libre !</strong></p>
<h2 id="sécurité-avec-free"><a class="header" href="#sécurité-avec-free">Sécurité avec free</a></h2>
<p>Pour faire preuve de sécurité quand tu utilises free, tu peux utiliser une
fonction qui va libérer la zone mémoire et mettre l'adresse du pointeur sur
NULL.</p>
<p>free ne laisse ton pointeur sur laquelle il pointe, donc si tu tt'en sers encore
après, tu liras des valeurs qui ne t'appartiennent plus.</p>
<pre><code class="language-c">char *text = malloc(10);

// du code...

free(text);

printf("%s\n", text);
text[0] = 'g';
printf("%s\n", text);
</code></pre>
<p>Ce code compile et peut s'exécuter en donnant un comportement indéfini.</p>
<p>Pour ne pas rencontrer ce genre de bug, tu vas créer une fonction qui va libérer
la zone mémoire et mettre le pointeur sur NULL <strong>pour de bon</strong>. Ainsi si tu
utilises ton pointeur, tu auras un segfault. C'est très bien pour des phases de
tests.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

void ptr_char_destructor(char **ptr)
{
    free(*ptr);
    *ptr = NULL;
}

int main(void)
{
    char *text = malloc(2600);

    // du code

    ptr_char_destructor(&amp;text);

    // du code

    return 0;
}
</code></pre>
<p>Oulah oulah. Quelle est cette écriture ?</p>
<p>Etant donné que tu dois mettre <strong>pour de bon</strong> le pointeur à NULL, tu vas
coder une fonction qui va utiliser un <strong>pointeur de pointeur</strong>. Un double
pointeur.</p>
<p>Si un pointeur est une adresse qui pointe un type, alors un pointeur de pointeur
est une adresse qui pointe sur... une adresse.</p>
<p><img src="c/./memory/pointer_pointer.png" alt="multi pointeur" title="multi pointeur" /></p>
<p>Donc si tu modifies l'adresse pointée en la mettant à NULL, au retour de la
fonction <strong>ptr_char_destructor</strong>, la valeur du pointeur sera toujours à NULL.</p>
<p>Si tu l'utilises sans faire exprès, tu auras un segfault à l'exécution.</p>
<p>Par exemple, ce code segfault :</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void ptr_char_destructor(char **ptr)
{
    free(*ptr);
    *ptr = NULL;
}

int main(void)
{
    char *text = malloc(2600);

    // du code

    ptr_char_destructor(&amp;text);

    // du code

    text[0] = 'g';

    return 0;
}
</code></pre>
<h2 id="valgrind"><a class="header" href="#valgrind">Valgrind</a></h2>
<p>Valgrind (qu'on prononce <a href="https://valgrind.org/docs/manual/faq.html#faq.pronounce">"Val grine de"</a>)
est un outil pour déboguer et profiler tes programmes. Pour l'occasion, tu vas
l'utiliser pour vérifier que tu as bien libérer ta mémoire.</p>
<p>Prenons un simple et incorrect code.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

char *arg_copy(char *arg_to_copy)
{
    size_t size = strlen(arg_to_copy);
    char *arg = malloc(size + 1);

    if (arg == NULL)
    {
        return NULL;
    }

    for (size_t i = 0; i &lt; size; ++i)
    {
        arg[i] = arg_to_copy[i];
    }

    arg[size] = '\0';

    return arg;
}

int main(int argc, char *argv[])
{
    if (argc != 2)
    {
        printf("Usage: %s ARG\n", argv[0]);
        return 1;
    }

    char *text = arg_copy(argv[1]);
    if (text == NULL)
    {
        printf("malloc failed\n");
        return 2;
    }

    printf("%s\n", text);

    // free(text);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ valgrind ./mon_super_programme coucou
==4902== Memcheck, a memory error detector
==4902== Copyright (C) 2002-2024, and GNU GPL'd, by Julian Seward et al.
==4902== Using Valgrind-3.23.0 and LibVEX; rerun with -h for copyright info
==4902== Command: ./mon_super_programme coucou
==4902==
coucou
==4902==
==4902== HEAP SUMMARY:
==4902==     in use at exit: 7 bytes in 1 blocks
==4902==   total heap usage: 2 allocs, 1 frees, 1,031 bytes allocated
==4902==
==4902== LEAK SUMMARY:
==4902==    definitely lost: 7 bytes in 1 blocks
==4902==    indirectly lost: 0 bytes in 0 blocks
==4902==      possibly lost: 0 bytes in 0 blocks
==4902==    still reachable: 0 bytes in 0 blocks
==4902==         suppressed: 0 bytes in 0 blocks
==4902== Rerun with --leak-check=full to see details of leaked memory
==4902==
==4902== For lists of detected and suppressed errors, rerun with: -s
==4902== ERROR SUMMARY: 0 errors from 0 contexts (suppressed: 0 from 0)
</code></pre>
<p>Décortiquons tout ça.</p>
<p>Tu peux voir au début la commande exécutée.</p>
<pre><code class="language-text">==4902== Command: ./mon_super_programme coucou
</code></pre>
<p>Tu peux voir l'effet du <strong>printf</strong> au milieu des lignes.</p>
<p>Ensuite il y a deux parties qui nous résument l'utilisation mémoire.</p>
<pre><code class="language-text">==4902== HEAP SUMMARY:
==4902==     in use at exit: 7 bytes in 1 blocks
==4902==   total heap usage: 2 allocs, 1 frees, 1,031 bytes allocated
</code></pre>
<p><strong>in use at exit: 7 bytes in 1 blocks</strong> : c'est notre <strong>coucou\0</strong> qui n'a pas
été libéré.</p>
<p><strong>total heap usage: 2 allocs, 1 frees, 1,031 bytes allocated</strong> : la heap est la
zone mémoire dynamique. Comment peut-il y avoir 2 allocations alors que nous ne
faisons appel à malloc qu'une seule fois ?</p>
<p>Parce que nous ne faisons pas appel à malloc qu'une seule fois.</p>
<p><strong>printf</strong> fait aussi appel à malloc pour afficher le texte. Mais à l'inverse de
notre code, <strong>printf</strong> fait appel à free, c'est pour ça qu'on peut lire ensuite
qu'il y a un appel à free.</p>
<p>A la fin des logs, on nous indique qu'on peut relancer Valgrind avec l'argument
suivant :</p>
<pre><code class="language-text">==4902== Rerun with --leak-check=full to see details of leaked memory
</code></pre>
<pre><code class="language-text">$ valgrind --leak-check=full ./mon_super_programme coucou
==5307== Memcheck, a memory error detector
==5307== Copyright (C) 2002-2024, and GNU GPL'd, by Julian Seward et al.
==5307== Using Valgrind-3.23.0 and LibVEX; rerun with -h for copyright info
==5307== Command: ./mon_super_programme coucou
==5307==
coucou
==5307==
==5307== HEAP SUMMARY:
==5307==     in use at exit: 7 bytes in 1 blocks
==5307==   total heap usage: 2 allocs, 1 frees, 1,031 bytes allocated
==5307==
==5307== 7 bytes in 1 blocks are definitely lost in loss record 1 of 1
==5307==    at 0x48447A8: malloc (vg_replace_malloc.c:446)
==5307==    by 0x109194: arg_copy (in /tmp/tests/pediluve/c/mon_super_programme)
==5307==    by 0x10923B: main (in /tmp/tests/pediluve/c/mon_super_programme)
==5307==
==5307== LEAK SUMMARY:
==5307==    definitely lost: 7 bytes in 1 blocks
==5307==    indirectly lost: 0 bytes in 0 blocks
==5307==      possibly lost: 0 bytes in 0 blocks
==5307==    still reachable: 0 bytes in 0 blocks
==5307==         suppressed: 0 bytes in 0 blocks
==5307==
==5307== For lists of detected and suppressed errors, rerun with: -s
==5307== ERROR SUMMARY: 1 errors from 1 contexts (suppressed: 0 from 0)
</code></pre>
<p>Le nouveau bloc de texte intéressant se trouve en plein milieu :</p>
<pre><code class="language-text">==5307== 7 bytes in 1 blocks are definitely lost in loss record 1 of 1
==5307==    at 0x48447A8: malloc (vg_replace_malloc.c:446)
==5307==    by 0x109194: arg_copy (in /tmp/tests/pediluve/c/mon_super_programme)
==5307==    by 0x10923B: main (in /tmp/tests/pediluve/c/mon_super_programme)
</code></pre>
<p>Ce bloc se lit de bas en haut.</p>
<p>On peut lire que depuis la fonction <strong>main</strong>, on fait appel à la fonction
<strong>arg_copy</strong> qui elle-meme fait appel à la fonction <strong>malloc</strong> et que 7 octets
sont définitivement perdus depuis cet enchainement d'exécution.</p>
<p>Mais les emplacements ne sont pas humainement lisibles, on a des adresses
mémoire en hexadécimal. Nous allons ajouter un argument à la compilation pour
avoir des <strong>symboles de débug</strong>.</p>
<pre><code class="language-text">$ gcc -g test.c -o mon_super_programme
</code></pre>
<p>L'option <strong>-g</strong> permet d'ajouter des symboles de débug à ton programme. Ca te
permet de déboguer plus efficacement tes programmes. Mais attention à ne pas
livrer en production ce que tu produis avec des informations. Des gens mal
intentionnés pourraient s'en servir.</p>
<pre><code class="language-text">$ valgrind --leak-check=full ./mon_super_programme coucou
...
==5550== 7 bytes in 1 blocks are definitely lost in loss record 1 of 1
==5550==    at 0x48447A8: malloc (vg_replace_malloc.c:446)
==5550==    by 0x109194: arg_copy (test.c:8)
==5550==    by 0x10923B: main (test.c:33)
...
$
</code></pre>
<p>On peut lire ici que le premier appel à <strong>arg_copy</strong> se fait dans la fonction
<strong>main</strong> à la ligne 33, et que <strong>arg_copy</strong> fait appel à <strong>malloc</strong> ligne 8.</p>
<p>On sait où se trouve notre memory leak !</p>
<h3 id="recoder-malloc-et-free"><a class="header" href="#recoder-malloc-et-free">Recoder malloc et free</a></h3>
<p>Nous n'allons pas faire ça ici, mais dans les écoles d'informatiques, il y a un
exercice assez répandu qui est de recoder et remplacer malloc et free. C'est un
exercice ma foi fort sympathique.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="listes-chainées"><a class="header" href="#listes-chainées">Listes chainées</a></h1>
<p>Pour voir un ensemble d'exercices avancés, tu vas apprendre à utiliser les
listes chaînées. C'est une structure de données avancée (par rapport aux
tableaux, par exemple).</p>
<p>Une liste chaînée est juste une structure qui a en attribut un pointeur sur sa
propre structure.</p>
<p>Voici un bout de code pour mieux se rendre compte.</p>
<pre><code class="language-c">struct node
{
    int value;
    struct node *next;
};
</code></pre>
<p>Ainsi notre noeud peut aller dans une autre zone mémoire en pointant sur un
autre noeud qui aura d'autres valeurs, et ainsi de suite.</p>
<p>L'intérêt est que tu vas pouvoir ajouter un noeud quand bon te semble
dynamiquement.</p>
<p>Voici une représentation d'une liste chaînée.</p>
<p><img src="c/./linked_lists/linked_list.svg" alt="liste chaînée" title="liste chaînée" /></p>
<p>Chaque rectangle coloré en vert et rose est un noeud. Le premier est appelé
<strong>head</strong> car il est en tête de la liste. On sait que le dernier est en fin de
liste car son attribut <strong>next</strong> est à <strong>NULL</strong>.</p>
<p>Pour passer au noeud d'après, on utilise l'attribut <strong>next</strong>.</p>
<p>Commençons par créer une fonction pour créer un noeud avec une valeur envoyée en
paramètre. Maintenant que tu sais utiliser <strong>malloc</strong>, tu ne seras pas surpris
de le voir utilisé dans la fonction.</p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;

struct node
{
    int value;
    struct node *next;
};

struct node *node_constructor(int value)
{
    struct node *new = malloc(sizeof (struct node));
    if (new == NULL)
    {
        return NULL;
    }

    new-&gt;value = value;
    new-&gt;next = NULL;

    return new;
}
</code></pre>
<p>Fais bien attention à mettre <strong>next</strong> à <strong>NULL</strong>. On va s'en servir pour
parcourir la liste chaînée. On saura que nous sommes à la fin une fois que le
dernier noeud aura son <strong>next</strong> à <strong>NULL</strong>.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
    int value;
    struct node *next;
};

struct node *node_constructor(int value)
{
    struct node *new = malloc(sizeof (struct node));
    if (new == NULL)
    {
        return NULL;
    }

    new-&gt;value = value;
    new-&gt;next = NULL;

    return new;
}

int main(void)
{
    struct node *head = node_constructor(69);
    void *ptr_next = head-&gt;next;

    printf("head value: %d\n", head-&gt;value);
    printf("head next : %p\n", next);

    return 0;
}
</code></pre>
<p>La variable <strong>ptr_next</strong> m'est juste utile pour afficher dans printf ce que vaut
<strong>head-&gt;next</strong>. En temps normal tu n'as pas besoin de faire ça.</p>
<pre><code class="language-text">$ ./mon_super_programme
head value: 69
head next : (nil)
$
</code></pre>
<p><strong>(nil)</strong> est une écriture particulière de printf pour signifier que la valeur
de l'adresse à affcher est <strong>NULL</strong>.</p>
<p>Tu peux maintenant enchaîner les appels.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
    int value;
    struct node *next;
};

struct node *node_constructor(int value)
{
    struct node *new = malloc(sizeof (struct node));
    if (new == NULL)
    {
        return NULL;
    }

    new-&gt;value = value;
    new-&gt;next = NULL;

    return new;
}

int main(void)
{
    struct node *head = node_constructor(69);

    head-&gt;next = node_constructor(51);
    head-&gt;next-&gt;next = node_constructor(2600);
    head-&gt;next-&gt;next-&gt;next = node_constructor(42);

    printf("1: %d\n", head-&gt;value);
    printf("2: %d\n", head-&gt;next-&gt;value);
    printf("3: %d\n", head-&gt;next-&gt;next-&gt;value);
    printf("4: %d\n", head-&gt;next-&gt;next-&gt;next-&gt;value);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
1: 69
2: 51
3: 2600
4: 42
$
</code></pre>
<p>Et si tu faisais plutôt une fonction pour parcourir et afficher ta liste chaînée
?</p>
<p>Tu as deux moyen pour ça. Une fonction itérative qui utilise une boucle, et une
fonction récursive qui se rappelle elle-même.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
    int value;
    struct node *next;
};

struct node *node_constructor(int value)
{
    struct node *new = malloc(sizeof (struct node));
    if (new == NULL)
    {
        return NULL;
    }

    new-&gt;value = value;
    new-&gt;next = NULL;

    return new;
}

void node_printer_rec(struct node *n)
{
    if (n == NULL)
    {
        return;
    }

    printf("%d\n", n-&gt;value);

    node_printer_rec(n-&gt;next);
}

void node_printer_loop(struct node *n)
{
    while (n != NULL)
    {
        printf("%d\n", n-&gt;value);
        n = n-&gt;next;
    }
}

int main(void)
{
    struct node *head = node_constructor(69);

    head-&gt;next = node_constructor(51);
    head-&gt;next-&gt;next = node_constructor(2600);
    head-&gt;next-&gt;next-&gt;next = node_constructor(42);

    printf("Recursif:\n");
    node_printer_rec(head);

    printf("Loop:\n");
    node_printer_loop(head);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
Recursif:
69
51
2600
42
Loop:
69
51
2600
42
$
</code></pre>
<p>On va garder la façon de faire avec la boucle. Elle est plus efficace et rapide
que la récursive qui doit se rappeler à chaque fois.</p>
<p>En se basant sur cette technique, code une fonction <strong>node_append</strong> qui prend en
paramètre la <strong>head</strong> de la liste chaînée et la nouvelle <strong>value</strong> et ajoute à
la toute fin le nouveau neud avec la valeur.</p>
<p>ps: Tu peux tout à faire utiliser <strong>node_constructor</strong> pour ça.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
    int value;
    struct node *next;
};

struct node *node_constructor(int value)
{
    struct node *new = malloc(sizeof (struct node));
    if (new == NULL)
    {
        return NULL;
    }

    new-&gt;value = value;
    new-&gt;next = NULL;

    return new;
}

void node_append(struct node *head, int value)
{
    if (head == NULL)
    {
        return;
    }

    while (head-&gt;next != NULL)
    {
        head = head-&gt;next;
    }

    head-&gt;next = node_constructor(value);
}

void node_printer(struct node *n)
{
    while (n != NULL)
    {
        printf("%d\n", n-&gt;value);
        n = n-&gt;next;
    }
}

int main(void)
{
    struct node *head = node_constructor(69);

    node_append(head, 51);
    node_append(head, 2600);
    node_append(head, 42);

    node_printer(head);

    return 0;
}
</code></pre>
<p>Comme dans le <strong>node_printer</strong>, je vais parcourir la liste. Une fois arrivé au
dernier noeud qui n'a pas de <strong>next</strong>, je dis que son <strong>next</strong> est construit en
utilisant la fonction <strong>node_constructor</strong>.</p>
<p>Au cas où quelqu'un fait n'importe quoi avec ma fonction ou si je suis fatigué,
je vérifie quand même qu'on ne m'envoie pas une fonction inexistante, c'est à
dire avec la <strong>head à NULL</strong>, car je ne peux pas ajouter un noeud à rien.</p>
<pre><code class="language-text">$ ./mon_super_programme
69
51
2600
42
$
</code></pre>
<p>C'est bien. Il ne manque qu'une chose... <strong>LIBERER LA MEMOIRE !</strong></p>
<pre><code class="language-text">$ valgrind ./mon_super_programme
...
==9266== HEAP SUMMARY:
==9266==     in use at exit: 64 bytes in 4 blocks
==9266==   total heap usage: 5 allocs, 1 frees, 1,088 bytes allocated
==9266==
==9266== LEAK SUMMARY:
==9266==    definitely lost: 16 bytes in 1 blocks
==9266==    indirectly lost: 48 bytes in 3 blocks
==9266==      possibly lost: 0 bytes in 0 blocks
==9266==    still reachable: 0 bytes in 0 blocks
==9266==         suppressed: 0 bytes in 0 blocks
...
$
</code></pre>
<p>Tu vas créer une fonction <strong>node_destructor</strong> qui prend en paramètre un <strong>double
pointeur</strong> sur la head de type <strong>struct node</strong>, libère chaque noeud et met la
valeur de head à NULL <strong>pour de bon</strong>.</p>
<p>Attention à ne pas écrire quelque chose comme ceci :</p>
<pre><code class="language-c">while (node)
{
    free(node);
    node = node-&gt;next;
}
</code></pre>
<p>Si tu veux accéder à l'attribut d'une struct en ayant un double pointeur,
utilise cette notation :</p>
<pre><code class="language-c">(*node)-&gt;value;
</code></pre>
<p>Les parenthèses te servent à bien déréférencer node et pas node-value.</p>
<p>Une fois que tu as libérer une zone mémoire, tu ne dois plus l'utiliser.</p>
<p>Réfléchis à utiliser une deuxième variable.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

struct node
{
    int value;
    struct node *next;
};

struct node *node_constructor(int value)
{
    struct node *new = malloc(sizeof (struct node));
    if (new == NULL)
    {
        return NULL;
    }

    new-&gt;value = value;
    new-&gt;next = NULL;

    return new;
}

void node_append(struct node *head, int value)
{
    if (head == NULL)
    {
        return;
    }

    while (head-&gt;next != NULL)
    {
        head = head-&gt;next;
    }

    head-&gt;next = node_constructor(value);
}

void node_destructor(struct node **head)
{
    if (head == NULL || *head == NULL)
    {
        return;
    }

    struct node *sentinel = *head-&gt;next;
    struct node *to_free = NULL;

    while (sentinel != NULL)
    {
        to_free = sentinel;
        sentinel = sentinel-&gt;next;
        free(to_free);
    }

    free(*head);
    *head = NULL;
}

void node_printer(struct node *n)
{
    while (n != NULL)
    {
        printf("%d\n", n-&gt;value);
        n = n-&gt;next;
    }
}

int main(void)
{
    struct node *head = node_constructor(69);

    node_append(head, 51);
    node_append(head, 2600);
    node_append(head, 42);

    node_printer(head);

    node_destructor(&amp;head);

    return 0;
}
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
69
51
2600
42
$
</code></pre>
<pre><code class="language-text">$ valgrind ./mon_super_programme
==9462== HEAP SUMMARY:
==9462==     in use at exit: 0 bytes in 0 blocks
==9462==   total heap usage: 5 allocs, 5 frees, 1,088 bytes allocated
==9462==
==9462== All heap blocks were freed -- no leaks are possible
$
</code></pre>
<p>Super ! Tu sais maintenant créer une liste chaînée et faire les actions les plus
basiques !</p>
<p>Réfléchis maintenant à faire les fonctions suivantes :</p>
<p>Je ne donne par les corrections car il s'agit d'exercices très souvent présents
aux piscines (et qui sont notés) auxquels tu dois réfléchir par toi-même.</p>
<pre><code class="language-c">struct node
{
    int value;
    struct node *next;
};

/*
    Ajoute un noeud en remplaçant la tête.
    Retourne la nouvelle tête qui vient d'être ajoutée.

     head : [51 -&gt; 42 -&gt; NULL]

    node_insert(head, 69);

     head : [69 -&gt; 51 -&gt; 42 -&gt; NULL]
*/
    struct node *node_prepend(struct node *head, int value);

/*
    Ajoute un nouveau noeud avec la valeur 'value' à l'indexième position

    Index :  0     1     2
     head : [69 -&gt; 51 -&gt; 42 -&gt; NULL]

    node_insert(head, 2600, 42);

    Index :  0     1     2       3
     head : [69 -&gt; 51 -&gt; 2600 -&gt; 42 -&gt; NULL]
*/
    void node_insert(struct node *head, int value, unsigned int index);

/*
    Renvoie l'index dans la liste du premier noeud qui contient la valeur
    'value'
*/

    unsigned int node_find(struct node *head, int value);

/*
    Supprime le premier noeud dont on rencontre la valeur 'value'
    Raccroche le noeud précédent avec le noeud suivant

    head : [69 -&gt; 51 -&gt; 42 -&gt; 51 -&gt; NULL]

    node_remove(head, 51);

    head : [69 -&gt; 42 -&gt; 51 -&gt; NULL]
*/
    void node_remove(struct node *head, int value);

/*
    Ajoute la deuxième liste à la suite de la première liste

    head1 : [69 -&gt; 51 -&gt; NULL]
    head2 : [42 -&gt; 2600 -&gt; 51 -&gt; NULL]

    node_concat(head1, head2);

    head1 : [69 -&gt; 51 -&gt; 42 -&gt; 2600 -&gt; 51 -&gt; NULL]
    head2 : [42 -&gt; 2600 -&gt; 51 -&gt; NULL]
*/
    void node_concat(struct node *head1, struct node *head2);

/*
    Trie la liste dans l'ordre croissant

    head : [69 -&gt; 51 -&gt; 42 -&gt; 2600 -&gt; 51 -&gt; NULL]

    node_sort(head);

    head : [42 -&gt; 51 -&gt; 51 -&gt; 69 -&gt; 2600 -&gt; NULL]

*/
    void node_sort(struct node *head);

/*
    Inverse l'ordre des éléments de la liste et retourne la nouvelle tête

    head : [69 -&gt; 51 -&gt; 42 -&gt; 2600 -&gt; 51 -&gt; NULL]

    node_reverse(head);

    head : [51 -&gt; 2600 -&gt; 42 -&gt; 51 -&gt; 69 -&gt; NULL]
*/
    struct node *node_reverse(struct node *head);

/*
    Coupe la liste en deux à partir de l'indexième position
    La première liste aura NULL à partir de la coupure

    Retourne la tête de la seconde liste

    Index :  0     1     2       3
     head : [69 -&gt; 51 -&gt; 2600 -&gt; 42 -&gt; NULL]

    struct node *head2 = node_split(head, 1);

    head1 : [69 -&gt; 51 -&gt; NULL]
    head2 : [2600 -&gt; 42 -&gt; NULL]
*/

    struct node *node_split(struct list *head, unsigned int index);
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gdb"><a class="header" href="#gdb">GDB</a></h1>
<p>GDB signifie <strong>G</strong>nu <strong>D</strong>e<strong>B</strong>ugger. C'est un débogueur qui te permet de voir
plus en profondeur comment s'exécute ton programme, remonter la trace des bugs,
etc.</p>
<p>Je ne vais pas te montrer tout l'envers du décort avec gdb, ça serait beaucoup
trop long et ça mériterait un livre complet. Je vais plutôt te montrer quelques
commandes de bases qui te seront déjà bien utiles.</p>
<h2 id="symbole-de-débug"><a class="header" href="#symbole-de-débug">Symbole de débug</a></h2>
<p>Si tu veux utiliser GDB, je te conseille de <strong>toujours</strong> inclure les symboles de
débug.</p>
<h2 id="exemples-1"><a class="header" href="#exemples-1">Exemples</a></h2>
<p>Voici le code que l'on va déboguer.</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

void upperchar(char *str, unsigned int index)
{
    str[index] -= 32; 
}

void uppercase(char *str)
{
    size_t str_len = strlen(str);
    for (size_t i = 0; i &lt; str_len; ++i)
    {
        if ('a' &lt;= str[i] &amp;&amp; str[i] &lt;= 'z')
        {
            upperchar(str, i);
        }
    }
}

int main(void)
{
    char *text = "je suis en majuscule";

    printf("%s\n", text);

    uppercase(text);

    printf("%s\n", text);

    return 0;
}
</code></pre>
<pre><code class="language-c">$ ./mon_super_programme
je suis en majuscule
segmentation fault (core dumped)  ./mon_super_programme
$
</code></pre>
<h3 id="exécution"><a class="header" href="#exécution">Exécution</a></h3>
<pre><code class="language-text">$ gcc test.c -g -o mon_super_programme
$
</code></pre>
<p>Pour déboguer ton programme, appelle gdb avec le nom de ton exécutable.</p>
<pre><code class="language-text">$ gdb mon_super_programme
GNU gdb (GDB) 15.1
Copyright (C) 2024 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
Type "show copying" and "show warranty" for details.
This GDB was configured as "x86_64-pc-linux-gnu".
Type "show configuration" for configuration details.
For bug reporting instructions, please see:
&lt;https://www.gnu.org/software/gdb/bugs/&gt;.
Find the GDB manual and other documentation resources online at:
    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.

For help, type "help".
Type "apropos word" to search for commands related to "word"...
/home/gelules/.config/gdb/gdbinit:1: Error in sourced command file:
No symbol table is loaded.  Use the "file" command.
Reading symbols from mon_super_programme...
(gdb)
</code></pre>
<p>Tu peux lire que GDB a bien charger ton programme, et tu as maintenant un
prompt.</p>
<p>Si tu veux quitter GDB, exécuter <strong>exit</strong> ou effecute la combinaison de touches
<strong>ctrl+d</strong>. Si tu es en débug, il se peut que tu dois faire cette manipulation deux fois
d'affilées.</p>
<h3 id="afficher-le-code-source"><a class="header" href="#afficher-le-code-source">Afficher le code source</a></h3>
<p>Ceci fonctionne avec les codes compilés avec les symboles de débug.</p>
<pre><code class="language-text">(gdb) tui enable
</code></pre>
<p><img src="c/./gdb/tui_enable.png" alt="gdb affiche le code source" title="gdb affiche le code source" /></p>
<p>Si tu utilises les touches fléchées, tu parcouras le code. Mais GDB te permet
avec les touches fléchées de parcourir ton historique de commandes.</p>
<p>Pour te refocaliser sur la fenêtre des commandes, exécute</p>
<pre><code class="language-text">(gdb) foc cmd
</code></pre>
<p>Pour refocaliser le code source, exécute</p>
<pre><code class="language-text">(gdb) foc src
</code></pre>
<h3 id="exécuter-le-programme"><a class="header" href="#exécuter-le-programme">Exécuter le programme</a></h3>
<p>Pour exécuter le programme normalement dans GDB, exécute <strong>run</strong> ou <strong>r</strong> pour
aller plus vite.</p>
<p>Si GDB te demande de télécharger et activer debuginfo, répond yes. Ca ne te sera
pas utile maintenant, mais ça te fait des informations de débug supplémentaires.
Ce n'est pas négligeable.</p>
<pre><code class="language-text">(gdb) run
...
je suis en majuscule

Program received signal SIGSEGV, Segmentation fault.
0x0000555555555170 in upperchar (str=0x555555556004 "je suis en majuscule", index=0) at test.c:6
6	    str[index] -= 32;
(gdb)
</code></pre>
<p><img src="c/./gdb/segfault.png" alt="gdb affiche le segfault" title="gdb affiche le segfault" /></p>
<p>GDB t'indique que le segfault a lieu dans la fonction <strong>upperchar</strong> à la ligne
6, et te met en surbrillance la ligne exécutée qui segfault. Elle t'affiche
aussi les paramètres de la fonction.</p>
<h3 id="backtrace"><a class="header" href="#backtrace">Backtrace</a></h3>
<p>Tu peux utiliser la commande <strong>backtrace</strong> ou <strong>bt</strong> pour aller plus vite pour
voir où tu es et d'où tu viens.</p>
<pre><code class="language-text">(gdb) backtrace
#0  0x0000555555555170 in upperchar (str=0x555555556004 "je suis en majuscule", index=0) at test.c:6
#1  0x00005555555551d3 in uppercase (str=0x555555556004 "je suis en majuscule") at test.c:16
#2  0x0000555555555211 in main () at test.c:27
(gdb)
</code></pre>
<p>Ca se lit de bas en haut.</p>
<p>Tu étais dans le main, à la ligne 27 tu as appelé uppercase et à la ligne 16 tu
as appelé upperchar avec l'index à 0.</p>
<p>str n'est pas à NULL (0x0), elle est à l'adresse 0x555555556004 et on voit
qu'elle pointe vers une chaîne de caractères qui contient notre texte.</p>
<p>Tu devines que tu n'as pas le droit de mofidier <strong>str</strong>.</p>
<p>Retournons dans le main.</p>
<pre><code class="language-c">    char *text = "je suis en majuscule";
</code></pre>
<p>Rappelle toi, tu n'as pas le droit de modifier un pointeur sur un <strong>string
literal</strong>, tu dois créer un tableau pour ça.</p>
<p>Fixons ça avec :</p>
<pre><code class="language-c">    char text[] = "je suis en majuscule";
</code></pre>
<pre><code class="language-text">$ ./mon_super_programme
je suis en majuscule
JE SUIS EN MAJUSCULE
$
</code></pre>
<p>Hourra ! Ca fonctionne !</p>
<p>Je vais quand même te montrer quelques commandes qui pourraient s'avérer utiles.</p>
<h3 id="start"><a class="header" href="#start">start</a></h3>
<p>La commande <strong>start</strong> crée un <strong>breakpoint</strong>, un point d'arrêt, au tout début de
ton programme. Ca te permet de commencer à déboguer ton programme en restant au
début pour faire de la vérification avec de <strong>continuer</strong> l'exécution</p>
<h3 id="continue"><a class="header" href="#continue">continue</a></h3>
<p>Quand tu es dans un breakpoint, le programme est à l'arrêt. Utilise la commande
<strong>continue</strong> ou <strong>c</strong> pour aller plus vite pour reprendre le cours d'exécution.</p>
<h3 id="breakpoints"><a class="header" href="#breakpoints">breakpoints</a></h3>
<p>Tu peux créer des breakpoints avec la commande <strong>break</strong> ou <strong>break</strong> pour
aller plus vite, suivi d'une adresse mémoire, d'un nom de fonction ou d'un
numéro de ligne.</p>
<p>Sache que GDB autorise l'autocomplétion, si tu mets un début de nom de fonction,
il peut autocompléter en appuyant sur la touche de tabulation.</p>
<p>Dans le code que j'ai donné au début. Si je fais</p>
<pre><code class="language-text">(gdb) break upperchar
Breakpoint 1 at 0x1164: file test.c, line 6.
(gdb)
</code></pre>
<p>J'ai bien un breakpoint qui se fera à la fonction upperchar.</p>
<p>Pour lister les breakpoints, tu peux exécuter la commande <strong>info breakpoints</strong>.</p>
<pre><code class="language-text">(gdb) info breakpoints
Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x0000000000001164 in upperchar at test.c:6
(gdb)
</code></pre>
<p>Pour supprimer un breakpoint, exécute <strong>delete breakpoints
NUMERO_DU_BREAKPOINT</strong>.</p>
<h3 id="next-et-step"><a class="header" href="#next-et-step">next et step</a></h3>
<p>Si tu veux avancer pas à pas, tu peux utiliser les commandes <strong>next</strong> ou <strong>n</strong>
pour aller plus vite, et <strong>step</strong> ou <strong>s</strong> pour aller plus vite.</p>
<p><strong>next</strong> ne rentre pas dans une fonction pendant le débug, gdb exécutera tout le
code qui doit s'y exécuter en gardant le focus sur la fonction dans laquelle tu
es.</p>
<p><strong>step</strong> rentre dans la fonction</p>
<p>Si tu appuies sur Entrée alors que le prompt est vide, GDB rééexuctera ta
dernière commande.</p>
<p>La ligne de code que GDB affiche sera la ligne qui <strong>sera</strong> exécutée une fois
que tu entreras <strong>next</strong> ou <strong>step</strong>.</p>
<pre><code class="language-text">(gdb) start
Temporary breakpoint 1 at 0x5555555551fe: file test.c, line 22.
Starting program: /tmp/tests/pediluve/c/mon_super_programme
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/usr/lib/libthread_db.so.1".

Temporary breakpoint 1, main () at test.c:22
22	{
(gdb) n
23	    char text[] = "je suis en majuscule";
(gdb)
25	    printf("%s\n", text);
(gdb)
je suis en majuscule
27	    uppercase(text);
(gdb) s
uppercase (str=0x7fffffffe610 "je suis en majuscule") at test.c:11
11	    size_t str_len = strlen(str);
(gdb) n
12	    for (size_t i = 0; i &lt; str_len; ++i)
(gdb)
14	        if ('a' &lt;= str[i] &amp;&amp; str[i] &lt;= 'z')
(gdb)
16	            upperchar(str, i);
(gdb) s
upperchar (str=0x7fffffffe610 "je suis en majuscule", index=0) at test.c:6
6	    str[index] -= 32;
(gdb)
7	}
(gdb)
</code></pre>
<p><img src="c/./gdb/next_step.png" alt="next et step dans GDB" title="next et step dans GDB" /></p>
<h3 id="exécuter-son-programme-avec-des-arguments-sur-argv"><a class="header" href="#exécuter-son-programme-avec-des-arguments-sur-argv">Exécuter son programme avec des arguments sur argv</a></h3>
<p>Si tu dois exécuter ton programme avec des arguments, exécute gdb normalement en
donnant le nom du programme. Une fois dans le prompt de GDB, exécute</p>
<pre><code class="language-text">(gdb) start argument_1 argument_2 argument_3
</code></pre>
<p>ou</p>
<pre><code class="language-text">(gdb) run argument_1 argument_2 argument_3
</code></pre>
<p>pour lancer le débug avec des arguments.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="assembleur"><a class="header" href="#assembleur">Assembleur</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="auteurs"><a class="header" href="#auteurs">Auteurs</a></h1>
<p>Gélules</p>
<ul>
<li><a href="https://www.youtube.com/@gelules">Youtube</a></li>
<li><a href="https://www.twitch.tv/gelules">Twitch</a></li>
<li><a href="https://discord.gg/kingdown">Discord (Association Kingdown)</a></li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
